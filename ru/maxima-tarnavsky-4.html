<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" xml:lang="ru" lang="ru">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="copyright" content="© 2002–2014 Команда разработчиков Maxima." />
<title>Тихон Тарнавский. Maxima. Алгебра и начала анализа // Maxima CAS</title>
<link rel="stylesheet" href="../main.css" />
<link rel="shortcut icon" href="../i/favicon.png" media="all" />
<link rel="alternate" type="application/rss+xml" title="Новости Maxima" href="feed.xml" />
</head>
<body>
<p class="langnav">
<a href="../index.html" xml:lang="en" lang="en">English</a> · <a href="../es/index.html" xml:lang="es" lang="es">Español</a>
</p>
<h1>
<a href="/ru/" title="Перейти на главную страницу">
<img src="../i/logo.png" alt="MξΣ" width="135" height="135" class="mks" />
</a> <a href="/ru/" title="Перейти на главную страницу">Система компьютерной алгебры Maxima</a>
</h1>
<ul class="nav">
<li>
<a href="documentation.html">Документация</a>
</li>
<li>
<a href="faq.html">Ответы на часто задаваемые вопросы</a>
</li>
<li>
<a href="screenshots.html">Снимки экрана</a>
</li>
<li>
<a href="download.html">Загрузка</a>
</li>
<li>
<a href="http://sourceforge.net/p/maxima/bugs/">Отчеты об ошибках</a>
</li>
<li>
<a href="http://sourceforge.net/projects/maxima">Сайт разработчиков</a>
</li>
<li>
<a href="3rdpartycode.html">Дополнительные пакеты</a>
</li>
<li>
<a href="relatedprojects.html">Связанные проекты</a>
</li>
<li>
<a href="lisp.html">Ссылки по Lisp</a>
</li>
<li>
<a href="compalg.html">Компьютерная алгебра</a>
</li>
<li>
<a href="http://sourceforge.net/p/maxima/wiki/Home/">Wiki</a>
</li>
<li style="border: none">
<a href="maximalist.html">Списки рассылки</a>
</li>
<li class="sflink">
<a href="http://sourceforge.net/projects/maxima" title="Project page at SourceForge.net">
<img src="http://sflogo.sourceforge.net/sflogo.php?group_id=4933&amp;type=10" alt="Get Maxima -- GPL CAS based on DOE-MACSYMA at SourceForge.net. Fast, secure and Free Open Source software downloads" />
</a>
</li>
</ul>
<div class="body">
<h2 style="padding-top: 0; margin-top: 0">Тихон Тарнавский. Maxima. Алгебра и начала анализа</h2>
<p>Впервые было опубликовано в «<a href="http://www.linuxformat.ru/">Linux Format</a>» <a href="http://www.linuxformat.ru/download/84.pdf">№10 (84), октябрь 2006 г</a>.</p>
<p>Из встроенного функционала Maxima в первую очередь стоит обратить внимание на несколько групп функций: работу с пределами, дифференцирование, интегрирование, поиск решений уравнений — как «просто», так и дифференциальных.</p>
<h3>«Предельничаем»…</h3>
<p>Собственно полноценных функций для нахождения предела существует в Maxima аж одна. Но зато какая! Она может принимать три различных варианта списка аргументов, и кроме того, на ее действие влияют еще и три флага. Но давайте по порядку. Зовут эту функции вполне соответственно ее действию: <kbd>limit</kbd>; и в самом стандартном варианте ее вызов выглядит как <kbd>limit(выражение, переменная, точка)</kbd>, то есть то, что в математической записи выглядит как lim<sub>
<var>x</var>→<var>a</var>
</sub> <var>f</var>(<var>x</var>), в контексте Maxima запишется как <kbd>limit(f(x), x, a)</kbd>:</p>
<p class="labeled-image">
<img src="i/tarnavsky/4/maxima4-01.png" alt="" />
</p>
<p>Maxima может искать пределы не только в конечных точках, но и на бесконечности. Среди стандартных обозначений программы существуют универсальные названия для разных бесконечностей: плюс-бесконечность записывается через <kbd>inf</kbd> (от слова <em>infinity</em>, как нетрудно догадаться), минус-бесконечность — через <kbd>minf</kbd> (от <em>minus infinity</em>); для комплексных чисел бесконечность, как известно, одна, и она (комплексная бесконечность) обозначается полным словом <kbd>infinity</kbd>. При работе с пределами все три обозначения могут как использоваться при вводе, так и возникать в виде найденного значения предела; отдельно здесь надо отметить один момент касательно работы с интерфейсом к Maxima в редакторе TeXmacs: символы <kbd>inf</kbd> и <kbd>minf</kbd> при выводе здесь отображаются в своей традиционной математической нотации, то есть как ∞ и −∞; символ вместо <kbd>inf</kbd> можно, кроме того, использовать еще и при вводе.</p>
<p class="labeled-image">
<img src="i/tarnavsky/4/maxima4-02.png" alt="" />
</p>
<p>Второй вариант вызова функции <kbd>limit()</kbd> — это расширенная версия первого: <kbd>limit(выражение, переменная, точка, направление)</kbd>, для поиска односторонних пределов. Для предела справа в качестве «направления» указывается <kbd>plus</kbd>, для предела слева — <kbd>minus</kbd>:</p>
<p class="labeled-image">
<img src="i/tarnavsky/4/maxima4-03.png" alt="" />
</p>
<p>Пределы справа и слева еще иногда называют соответственно пределами сверху и снизу. Хотя правильнее в таком случае говорить полностью: «предел при <var>x</var>, стремящемся к <var>a</var> сверху», в том числе чтобы не создавать путаницы с верхним и нижним пределами, которые суть совершенно другое.</p>
<p>Кроме упомянутых выше бесконечностей, на выходе возможно появление и еще двух обозначений, на случай, если заданный предел не существует: <kbd>ind</kbd> (от слова <em>indefinite</em> — <em>неопределенный</em>) и <kbd>und</kbd> (от слова <em>undefined</em> — опять же <em>неопределенный</em>). В документации первое из этих обозначений описано как <em>indefinite but bounded</em> (<em>не определен, но ограничен</em>), что дает предположить, что функция, не имеющая предела, при этом ограничена либо в окрестности предельной точки, либо на всей прямой. Какое из этих предположений имелось в виду, мне так и не удалось понять, потому как на практике ни одно из них не соответствует действительности. Вывода <kbd>ind</kbd> мне не удалось добиться ни на одной функции, радикально отличающейся от «канонической» (в том смысле, что фигурирующей в стандартном примере из комплекта) функции <kbd>sin(1/x)</kbd>.</p>
<p class="labeled-image">
<img src="i/tarnavsky/4/maxima4-04-thumb.png" alt="" />
</p>
<p>Здесь все правильно, <kbd>tan(1/x)</kbd> не ограничена в окрестности нуля. А вот дальше начинаются чудеса:</p>
<p class="labeled-image">
<a href="i/tarnavsky/4/maxima4-05.png">
<img src="i/tarnavsky/4/maxima4-05-thumb.png" alt="" />
</a>
</p>
<p>Как видите, первая функция имеет конечные односторонние пределы в нуле, а вторая ограничена вообще на всей оси — и тем не менее… Но это, думаю, не столь критично: главное, что наличие любого из этих символов в качестве вывода дает нам понять, что искомого предела не существует.</p>
<p>Функция <kbd>limit()</kbd> в третьем варианте — <kbd>limit(выражение)</kbd> — предназначена уже не для поиска собственно пределов, а для упрощения выражений, содержащих символы <kbd>inf</kbd> и <kbd>minf</kbd>:</p>
<p class="labeled-image">
<img src="i/tarnavsky/4/maxima4-06.png" alt="" />
</p>
<p>Выражения такого рода могут возникать, к примеру, при подстановках в формулы результатов вычисления каких-то других пределов или интегралов.</p>
<p>Такая способность — принимать различные списки аргументов — не является в Maxima чем-то особенным; она свойственна очень многим встроенным функциям, как и различное действие в зависимости от значений разнообразных переключателей. Это достаточно удобно: не нужно запоминать много разных имен функций (для поиска пределов, к примеру, используется исключительно функция <kbd>limit</kbd>); для вычисления производных, в том числе и частных, — функция <kbd>diff</kbd> (с которой мы уже бегло ознакомились в первой статье и сейчас продолжим это знакомство); для нахождения интегралов, как определенных, так и неопределенных — функция integrate (с которой мы тоже сегодня познакомимся). Имена наиболее часто используемых функций запомнить несложно, а о дополнительных ключах или флагах, в случае чего, можно прочитать во встроенной справке, набрав <kbd>? имя-функции</kbd>.</p>
<p>Об этих самых ключах к функции limit и осталось рассказать. Первый ключ называется <kbd>lhospitallim</kbd> и задает максимальное количество применений правила Лопиталя; название ключа и происходит от фамилии ученого, давшей название самому правилу, которая в оригинале пишется как <em>L’Hospital</em>. Напомню, правило это гласит, что в случае неопределенности вида 0/0 или можно продифференцировать числитель и знаменатель — и предел от этого не изменится. Ограничитель количества применений этого правила нужен для того, чтобы избежать зацикливаний, которые могут случиться для бесконечно дифференцируемых функций, у которых в данной точке равны нулю либо бесконечности все производные. По умолчанию значение <kbd>lhospitallim</kbd> равно четырем, и мне не удалось сходу придумать пример, когда этого не хватает — ведь функция поиска предела использует не только правило Лопиталя, но и другие соотношения; и для всех заданных мною соотношений двух функций с корнями выше четвертого порядка в искомой точке предел был успешно найден и при умолчательном значении.</p>
<p>Второй ключ к функции <kbd>limit</kbd> — это флаг <kbd>limsubst</kbd>, который, будучи выставлен в <kbd>true</kbd>, позволяет этой функции производить подстановки внутрь неизвестных выражений. По умолчанию этот флаг равен <kbd>false</kbd>, что исключает ошибки вроде такой:</p>
<p class="labeled-image">
<img src="i/tarnavsky/4/maxima4-07.png" alt="" />
</p>
<p>И, наконец, последний дополнительный параметр — еще один флаг, по имени <kbd>tlimswitch</kbd>. По умолчанию он тоже выключен, а если его включить, функция <kbd>limit</kbd> будет, при невозможности найти предел другими способами, пытаться его найти путем разложения подпредельной функции в ряд Тейлора в окрестности заданной точки:</p>
<p class="labeled-image">
<a href="i/tarnavsky/4/maxima4-08.png">
<img src="i/tarnavsky/4/maxima4-08-thumb.png" alt="" />
</a>
</p>
<p>Но в случае поиска односторонних пределов, в тех точках, где они не равны между собой, то есть полного предела не существует, этим флагом нужно пользоваться с осторожностью: при его включении функция <kbd>limit</kbd> может вернуть в качестве полного предела один из односторонних:</p>
<p class="labeled-image">
<a href="i/tarnavsky/4/maxima4-09.png">
<img src="i/tarnavsky/4/maxima4-09-thumb.png" alt="" />
</a>
</p>
<p>Реально у этой функции в точке ноль только предел справа равен единице; а предел слева — нулю.</p>
<p>И последнее: почему я употребил в начале по отношению к функции <kbd>limit()</kbd> слово «полноценная». Потому что кроме нее существует еще одна «недофункция» — <kbd>tlimit()</kbd>; она представляет собой фактически просто-напросто вызов самой функции <kbd>limit()</kbd> с поднятым флагом <kbd>tlimswitch</kbd>, то есть пытается при необходимости разложить «подпредельную» функцию в ряд Тейлора вне зависимости от реального значения этого флага. Другими словами вызов <kbd>tlimit(аргументы)</kbd> полностью аналогичен записи <kbd>limit(аргументы)</kbd>, <kbd>tlimswitch:true</kbd>; только чуть короче. И аргументы она может принимать точно такие же.</p>
<h3>…дифференцируем и интегрируем</h3>
<p>О функции <kbd>diff</kbd> я кое-что уже рассказывал в первой статье, и здесь это «кое-что» только напомню. В двух упомянутых тогда вариантах вызова эта функция принимала один либо два аргумента. С двумя, <kbd>diff(выражение, переменная)</kbd>, она возвращает производную от «выражения» по заданной переменной; с одним, <kbd>diff(выражение)</kbd> — полный дифференциал заданного выражения. Другими словами, запись <kbd>diff(f, x)</kbd> равнозначна математическому обозначению d<var>f</var>/d<var>x</var>, а <kbd>diff(f)</kbd> — d<var>f</var>.</p>
<p>Но это еще не все. Кроме одного либо двух, эта функция может также принимать любое нечетное число агрументов вида <kbd>diff(выражение, переменная, порядок, переменная, порядок, …)</kbd> и возвращает при этом производную либо смешанную частную производную от выражения заданных порядков по заданным переменным. К примеру, <kbd>diff(f, x, 3)</kbd> означает d<sup>3</sup>
<var>f</var>/d<var>x</var>
<sup>3</sup>, а <kbd>diff(f, x, 1, y, 2, z, 1)</kbd> — d<sup>4</sup>
<var>f</var>/d<var>x</var>d<var>y</var>
<sup>2</sup>d<var>z</var>. Единственный флаг, имеющий прямое отношение к самой функции <kbd>diff</kbd> — это флаг derivabbrev, который влияет на отображение производных в ячейках вывода Maxima. По умолчанию он равен <kbd>false</kbd>, и производные обозначаются в виде дробей с буквой d; если же его выставить в <kbd>true</kbd>, производные будут отображаться в сокращенном виде, с переменными дифференцирования записанными в виде индексов:</p>
<p class="labeled-image">
<a href="i/tarnavsky/4/maxima4-10.png">
<img src="i/tarnavsky/4/maxima4-10-thumb.png" alt="" />
</a>
</p>
<p>Кроме того, функция <kbd>diff</kbd> используется еще и для обозначения производных в дифференциальных уравнениях. Но об этом чуть позже, а сейчас перейдем к интегрированию.</p>
<p>Основная функция интегрирования называется, как я уже говорил, <kbd>integrate</kbd> и имеет два варианта вызова: для нахождения неопределенного и определенного интегралов. Первый выглядит как <kbd>integrate(выражение, переменная)</kbd>, второй — как <kbd>integrate(выражение, переменная, нижний-предел, верхний-предел)</kbd>:</p>
<p class="labeled-image">
<img src="i/tarnavsky/4/maxima4-11.png" alt="" />
</p>
<p>Вы, наверное, обратили внимание еще на один момент в ячейках <kbd>%i4</kbd>–<kbd>%o4</kbd>. Когда в выражении используется какой-либо независимый символ, результат, вообще говоря, может зависеть от значения этого символа. Если при этом о возможных значениях символа ничего не известно, то Maxima задаст вам один или несколько вопросов об этом значении, и решение будет искать в зависимости от ваших ответов на них. Так, в этом примере значение определенного интеграла напрямую зависит от знака параметра a:</p>
<p class="labeled-image">
<img src="i/tarnavsky/4/maxima4-12.png" alt="" />
</p>
<p>Кроме обычных определенных интегралов Maxima умеет искать также и несобственные интегралы, то есть такие, у которых неограничена либо область интегрирования, либо подынтегральная функция; и делается это все той же функцией <kbd>integrate</kbd>:</p>
<p class="labeled-image">
<img src="i/tarnavsky/4/maxima4-13.png" alt="" />
</p>
<p>В случае, если искомый интеграл не сходится, будет выдано сообщение об ошибке, говорящее о том, что интеграл расходящийся:</p>
<p class="labeled-image">
<a href="i/tarnavsky/4/maxima4-14.png">
<img src="i/tarnavsky/4/maxima4-14-thumb.png" alt="" />
</a>
</p>
<p>В случае, если интеграл не может быть найден, он либо целиком возвращается в несовершенном виде, либо упрощается частично и на выходе получается некоторая формула, включающая в несовершенном виде интеграл той части подынтегрального выражения, которую проинтегрировать не удалось:</p>
<p class="labeled-image">
<img src="i/tarnavsky/4/maxima4-15.png" alt="" />
</p>
<p>Кроме функций <kbd>diff</kbd> и <kbd>integrate</kbd>, в Maxima есть еще много разнообразных возможностей, связанных с производными и интегралами, в частности, функции для численного расчета значений определенных интегралов, а также инструменты, применимые при работе с дифференциальными и интегральными уравнениями. И разнообразны они настолько, что для того, чтобы рассмотреть подробно и с примерами их все, не хватило бы всего этого цикла. А более тезисно, хотя и на английском языке, они описаны в документации. Посему с этой темой на этом прекращаем и движемся дальше.</p>
<h3>Решайте, сударь!</h3>
<p>А дальше мы рассмотрим уравнения и их системы, и даже не столько рассмотрим, сколько порешим… то есть, конечно, порешаем. Уравнения и системы уравнений решаются в Maxima тоже одной и той же функцией, и тоже уже вам слегка знакомой по первой статье: это функция <kbd>solve</kbd>. Но прежде чем рассмотреть ее подробнее, нужно сказать пару слов о списках, или векторах, в Maxima; поскольку именно в виде списков solve возвращает корни, да и принимает параметры в случае решения системы уравнений, а не одного уравнения.</p>
<p>Синтаксис списков в Maxima весьма прост; это перечисление элементов в квадратных скобках: <kbd>[элемент1, элемент2, …, элементN]</kbd>. Особенность — не в синтаксисе. Основное достоинство Maximaльных списков в том, что их элементами могут быть совершенно любые выражения: символы, арифметические выражения, вызовы функций, присвоения, уравнения, другие списки… Додумать можете сами. Поэтому списки и во встроенных функциях применяются достаточно широко. Функция <kbd>solve</kbd> в своем простейшем варианте, для решения одиночного уравнения, в качестве аргументов никаких списков, напомню, не принимает (а принимает либо уравнение и символ, относительно которого его надо решать, либо только уравнение, если символ в нем всего один). А вот в качестве результата она уже и в таком варианте возвращает список, состоящий из всех корней заданного уравнения:</p>
<p class="labeled-image">
<a href="i/tarnavsky/4/maxima4-16.png">
<img src="i/tarnavsky/4/maxima4-16-thumb.png" alt="" />
</a>
</p>
<p>Как видите, функция <kbd>solve</kbd> находит все комплексные корни уравнения, а не только действительные.</p>
<p>К элементу списка можно обратиться с помощью тех же квадратных скобок, указав в них номер элемента после имени списка. Напомню, что равенство, переданное в качестве дополнительного параметра функции ev, означает подстановку переменной в вычисляемое выражение. Вот так мы можем осуществить проверку решения, подставив корень из выданного списка в исходное уравнение:</p>
<p class="labeled-image">
<img src="i/tarnavsky/4/maxima4-17.png" alt="" />
</p>
<p>Точно таким же образом можно обратиться и к любому другому элементу списка:</p>
<p class="labeled-image">
<a href="i/tarnavsky/4/maxima4-18.png">
<img src="i/tarnavsky/4/maxima4-18-thumb.png" alt="" />
</a>
</p>
<p>Вообще говоря, в качестве первого аргумента функции <kbd>solve</kbd> можно задавать не только уравнение, а вообще любое выражение. При этом «корни выражения» (не являющегося уравнением) ищутся в том самом смысле, в каком эта фраза понимается в математике: корни выражения — это те значения переменной, на которых выражение обращается в ноль. Возможность такой записи позволяет, к примеру, легко найти критические точки любой непрерывной функции (а заодно и вычислить значения функции в этих точках):</p>
<p class="labeled-image">
<img src="i/tarnavsky/4/maxima4-19.png" alt="" />
</p>
<p>В этом примере есть еще два важных момента. Первый — функция <kbd>%th()</kbd>. Она, как видно из контекста, вызывается как <kbd>%th(n)</kbd> и возвращает <var>n</var>-ю с конца ячейку вывода. Это, так же как и обозначения <kbd>%</kbd> и <kbd>_</kbd>, удобно, чтобы не обращать внимания на номера ячеек, и кроме того, применимо в командных файлах Maxima, которые могут загружаться в том числе и прямо из интерактивной сессии (с помощью функции <kbd>load</kbd>) — и тогда просто заранее неизвестно, начиная с какой ячейки данный файл загружен. И второй момент: здесь проиллюстрировано, что в Maxima операция индексирования списка доступна не только по отношению к именам переменных, но и к вызовам функций; другими словами, если функция возвращает список значений, мы можем выбрать одно конкретное из них, написав его номер в квадратных скобках прямо после вызова функции.</p>
<p>Вернемся к функции <kbd>solve</kbd>. А именно, перейдем теперь к решению систем уравнений. Для этого существует такой вариант записи: <kbd>solve([уравнение1, уравнение2, …], [переменная1, переменная2, …])</kbd>; либо сокращенный, аналогично варианту для одиночного уравнения: если количество уравнений и количество неизвестных равны, список неизвестных можно не писать: <kbd>solve([уравнение1, уравнение2  …])</kbd> (не забудьте квадратные скобки, иначе Maxima примет его за вариант с одним уравнением).</p>
<p class="labeled-image">
<a href="i/tarnavsky/4/maxima4-20.png">
<img src="i/tarnavsky/4/maxima4-20-thumb.png" alt="" />
</a>
</p>
<p>Здесь возвращается список из нескольких списков, каждый из которых соответствует одному решению системы. В качестве подстановок можно использовать как такие списки целиком (например, в данном контексте, <kbd>%o1[1]</kbd>), так и отдельные их элементы (например, <kbd>%o1[1][1]</kbd>).</p>
<p>В случае, когда уравнений меньше, чем неизвестных, <kbd>solve</kbd> поступит точно так же, как и в случае одного уравнения с несколькими символами: все неуказанные будет воспринимать как параметры:</p>
<p class="labeled-image">
<a href="i/tarnavsky/4/maxima4-21.png">
<img src="i/tarnavsky/4/maxima4-21-thumb.png" alt="" />
</a>
</p>
<p>Если <kbd>solve</kbd> не находит точных решений, она может, как и <kbd>integrate</kbd>, вернуть уравнение или систему уравнений в некотором упрощенном виде, а может и самостоятельно попытаться решить систему численно:</p>
<p class="labeled-image">
<a href="i/tarnavsky/4/maxima4-22.png">
<img src="i/tarnavsky/4/maxima4-22-thumb.png" alt="" />
</a>
</p>
<p>В таком случае, если вам все же нужны точные значения корней (в аналитической записи), либо если они не найдены даже в числах, можно попробовать решить уравнения по очереди, выражая одно неизвестное через другое:</p>
<p class="labeled-image">
<img src="i/tarnavsky/4/maxima4-23.png" alt="" />
</p>
<p>И подставляя в оставшиеся уравнения:</p>
<p class="labeled-image">
<a href="i/tarnavsky/4/maxima4-24.png">
<img src="i/tarnavsky/4/maxima4-24-thumb.png" alt="" />
</a>
</p>
<p>Теперь можем подставить обратно — и найти значения второй неизвестной, например, для первого и последнего корней из последнего списка:</p>
<p class="labeled-image">
<a href="i/tarnavsky/4/maxima4-25.png">
<img src="i/tarnavsky/4/maxima4-25-thumb.png" alt="" />
</a>
</p>
<p>Функция <kbd>solve</kbd> имеет довольно большое количество различных переключателей, из которых может пригодиться в своем не-умолчательном значении в первую очередь один: <kbd>solveradcan</kbd>. Умолчание здесь равно <kbd>false</kbd>, а выставив этот флаг в <kbd>true</kbd>, мы заставим <kbd>solve</kbd>, помимо его умолчательного поведения, применять <kbd>radcan</kbd> — функцию по упрощению показательных, логарифмических и степенных (с рациональными степенями) функций. Это делает работу функции <kbd>solve</kbd> более медленной (потому по умолчанию этот режим и выключен), но в некоторых случаях может помочь разрешить проблемы, которые без этого ключа приведут к невозможности найти точное решение.</p>
<h3>И снова дифференцируем и интегрируем</h3>
<p>Помимо «просто» уравнений, Maxima позволяет также решать и обыкновенные дифференциальные уравнения первого и второго порядка. Функций, непосредственно занимающихся решением таких уравнений, существует две. Первая из них занимается поиском частных решений линейных дифференциальных уравнений и систем таких уравнений; зовут ее <kbd>desolve</kbd>, от слов <em>differential equation solve</em>. Эта функция принимает два аргумента, первый из которых — уравнение либо список уравнений, а второй — соответственно одна переменная или список переменных. Если не заданы значения функций и/или их производных в нуле, то в найденном решении они просто отображаются в виде <kbd>f(0)</kbd> или</p>
<p class="labeled-image">
<img src="i/tarnavsky/4/maxima4-26.png" alt="" />
</p>
<p>задать эти значения позволяет функция <kbd>atvalue(выражение, переменная = точка, значение)</kbd>; то есть, в данном случае <kbd>atvalue(f(x), x=0, значение)</kbd> или <kbd>atvalue('diff(f(x)), x=0, значение)</kbd>. Производные в уравнениях и системах, решаемых с помощью этой функции, должны быть записаны непременно в виде <kbd>'diff(f(x), x)</kbd>, а не просто <kbd>'diff(f, x)</kbd>, а сами функции, соответственно, тоже в виде <kbd>f(x)</kbd>, а не <kbd>f</kbd> — нужно продемонстрировать зависимость функции от ее аргумента.</p>
<p class="labeled-image">
<a href="i/tarnavsky/4/maxima4-27.png">
<img src="i/tarnavsky/4/maxima4-27-thumb.png" alt="" />
</a>
</p>
<p>И конечно же, точно так же как для обычных уравнений и систем, здесь мы тоже можем проверить решение с помощью подстановки, но только надо еще дополнительно задать принудительное вычисление производных, так как в уравнениях они фигурируют в несовершенной форме:</p>
<p class="labeled-image">
<img src="i/tarnavsky/4/maxima4-28.png" alt="" />
</p>
<p>Вторая функция из этой группы называется <kbd>ode2</kbd> и предназначена она для решения обыкновенных дифференциальных уравнений первого и второго порядка; ее название происходит от фразы <em>ordinary differential equations of 1st or 2nd order</em>. Пишется она так: <kbd>ode2(уравнение, зависимая-переменная, независимая-переменная)</kbd>. Здесь уже независимая переменная указывается в списке параметров функции явно, и потому обозначения вида <kbd>y(x)</kbd> не нужны: и функция, и переменная обозначаются просто одиночными буквами. Также в отличие от предыдущей функции, <kbd>ode2</kbd> ищет не частное, а общее решение. Произвольная константа в решении уравнения первого порядка обозначена через <kbd>%c</kbd>; в решении уравнения второго порядка таких констант, естественно, две, и обозначаются они как <kbd>%k1</kbd> и <kbd>%k2</kbd>.</p>
<p class="labeled-image">
<img src="i/tarnavsky/4/maxima4-29.png" alt="" />
</p>
<p>В дополнение к функции <kbd>ode2</kbd> существуют три функции для поиска частных решений на основе полученных общих. Иначе говоря, эти функции, получая конкретные условия относительно значения функции-решения в заданной точке, находят исходя из этих значений соответствующие им величины интегральных констант. Одна из этих функций предназначена для обработки решения дифференциального уравнения первого порядка. Она называется <kbd>ic1</kbd> (<em>i</em> от <em>initial value</em> — <em>начальное значение</em>; <em>c</em> от <em>constant</em> — <em>константа</em>; <em>1</em> от <em>1<sup>st</sup> order</em> — <em>первого порядка</em>) и принимает три аргумента: первый — само решение, в том виде, в котором его находит функция <kbd>ode2</kbd>; второй — значение независимой переменной (<var>x</var>-координаты), третий — значение функции (зависимой переменной, <var>у</var>) при этом значении <var>x</var> и возвращает частное решение, проходящее через точку с заданными координатами (<var>x</var>, <var>y</var>):</p>
<p class="labeled-image">
<img src="i/tarnavsky/4/maxima4-30.png" alt="" />
</p>
<p>И две функции работают с решениями уравнений второго порядка. Так как в общем решении уравнения второго порядка фигурируют две независимые константы, то эти функции задают уже по два условия для поиска частного решения. Первая функция выглядит как <kbd>ic2(общее решение, x, функция-в-точке-x, производная-в-точке-x)</kbd>. Расшифровка названия аналогична предыдущей функции. Действует тоже аналогично ей, а в качестве второго условия задает значение производной в той же заданной точке:</p>
<p class="labeled-image">
<img src="i/tarnavsky/4/maxima4-31.png" alt="" />
</p>
<p>И последняя функция называется <kbd>bc2</kbd> (<em>b</em> от <em>boundary value</em> — граничное значение; а дальше все как в предыдущей). Ее аргументы: первым, как и в двух остальных вариантах, идет само общее решение, возвращенное функцией <kbd>ode2</kbd>; после него идут две пары значений: <var>x</var>
<sub>0</sub>, <var>y</var>
<sub>0</sub>, <var>x</var>
<sub>1</sub>, <var>y</var>
<sub>1</sub>, задающие две точки, через которые должен проходить график функции-решения:</p>
<p class="labeled-image">
<img src="i/tarnavsky/4/maxima4-32.png" alt="" />
</p>
<p>Касательно дифференциальных уравнений все этими функциями и заканчивается, никаких дополнительных ключей к ним не предназначено.</p>
<p>В следующий раз мы поговорим о средствах построения графиков функций и о средствах автоматизации: условных операторах, циклах и управляющих условиях, налагаемых на различные символы и выражения.</p>
</div>
<div class="footer">
<p>Вопросы о Maxima или этого сайта: <a href="maximalist.html">Списки рассылки</a>
</p>
</div>
</body>
</html>