<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Maxima — практически законченная система компьютерной алгебры, написанная на Lisp, с упором на символьные вычисления. Она основана на DOE-MACSYMA и лицензированна под GPL. В числе возможностей Maxima — символьное интегрирование, построение трехмерных графиков, решение ОДУ.">
<meta name="keywords" content="Maxima, CAS, computer algebra, mathematics, Lisp, symbolic computation, MACSYMA, GPL, free, ODE, plotting, система компьютерной алгебры, компьютерная алгебра, математика, символьные вычисления, свободно">
<title>Maxima &ndash; максимум свободы символьных вычислений</title>
<link rel="stylesheet" href="../maxima.css">
<link rel="icon" type="../image/svg+xml" href="img/maxima.svg">
<link rel="alternate icon" href="../img/favicon.ico">
</head>
<body>
<div class="header">
<img style="float:left" src="../img/maxima.svg">
<h1>Maxima</h1>
<p>Система компьютерной алгебры</p>
</div>
<div class="row">
<div class="leftcolumn">
<div class="card">
<h2>Тихон Тарнавский. Maxima. Алгебра и начала анализа</h2>
<p>Впервые было опубликовано в
«<a href="http://www.linuxformat.ru/">Linux
Format</a>» <a href="http://www.linuxformat.ru/download/84.pdf">№10 (84),
октябрь 2006 г</a>.</p>
<p>Из встроенного функционала Maxima в первую очередь стоит обратить
внимание на несколько групп функций: работу с пределами,
дифференцирование, интегрирование, поиск решений уравнений — как
«просто», так и дифференциальных.</p>
<h3>«Предельничаем»…</h3>
<p>Собственно полноценных функций для нахождения предела существует в
Maxima аж одна. Но зато какая! Она может принимать три различных
варианта списка аргументов, и кроме того, на ее действие влияют еще и
три флага. Но давайте по порядку. Зовут эту функции вполне
соответственно ее действию: <code>limit</code>; и в самом стандартном
варианте ее вызов выглядит
как <code>limit(выражение, переменная, точка)</code>, то есть то, что
в математической записи выглядит как
lim<sub><var>x</var>→<var>a</var></sub> <var>f</var>(<var>x</var>), в
контексте Maxima запишется как <code>limit(f(x), x, a)</code>:</p>
<img class="contract" src="i/tarnavsky/4/maxima4-01.png" alt="">
<p>Maxima может искать пределы не только в конечных точках, но и на
бесконечности. Среди стандартных обозначений программы существуют
универсальные названия для разных бесконечностей: плюс-бесконечность
записывается через <code>inf</code> (от слова <em>infinity</em>, как
нетрудно догадаться), минус-бесконечность — через <code>minf</code>
(от <em>minus infinity</em>); для комплексных чисел бесконечность, как
известно, одна, и она (комплексная бесконечность) обозначается полным
словом <code>infinity</code>. При работе с пределами все три
обозначения могут как использоваться при вводе, так и возникать в виде
найденного значения предела; отдельно здесь надо отметить один момент
касательно работы с интерфейсом к Maxima в редакторе TeXmacs:
символы <code>inf</code> и <code>minf</code> при выводе здесь
отображаются в своей традиционной математической нотации, то есть как
∞ и −∞; символ вместо <code>inf</code> можно, кроме того, использовать
еще и при вводе.</p>
<img class="contract" src="i/tarnavsky/4/maxima4-02.png" alt="">
<p>Второй вариант вызова функции <code>limit()</code> — это
расширенная версия
первого: <code>limit(выражение, переменная, точка, направление)</code>,
для поиска односторонних пределов. Для предела справа в качестве
«направления» указывается <code>plus</code>, для предела
слева — <code>minus</code>:</p>
<img class="contract" src="i/tarnavsky/4/maxima4-03.png" alt="">
<p>Пределы справа и слева еще иногда называют соответственно пределами
сверху и снизу. Хотя правильнее в таком случае говорить полностью:
«предел при <var>x</var>, стремящемся к <var>a</var> сверху», в том
числе чтобы не создавать путаницы с верхним и нижним пределами,
которые суть совершенно другое.</p>
<p>Кроме упомянутых выше бесконечностей, на выходе возможно появление
и еще двух обозначений, на случай, если заданный предел не
существует: <code>ind</code> (от
слова <em>indefinite</em> — <em>неопределенный</em>)
и <code>und</code> (от слова <em>undefined</em> — опять
же <em>неопределенный</em>). В документации первое из этих обозначений
описано как <em>indefinite but bounded</em> (<em>не определен, но
ограничен</em>), что дает предположить, что функция, не имеющая
предела, при этом ограничена либо в окрестности предельной точки, либо
на всей прямой. Какое из этих предположений имелось в виду, мне так и
не удалось понять, потому как на практике ни одно из них не
соответствует действительности. Вывода <code>ind</code> мне не удалось
добиться ни на одной функции, радикально отличающейся от
«канонической» (в том смысле, что фигурирующей в стандартном примере
из комплекта) функции <code>sin(1/x)</code>.</p>
<img class="contract" src="i/tarnavsky/4/maxima4-04.png" alt="">
<p>Здесь все правильно, <code>tan(1/x)</code> не ограничена в
окрестности нуля. А вот дальше начинаются чудеса:</p>
<img class="contract" src="i/tarnavsky/4/maxima4-05.png" alt="">
<p>Как видите, первая функция имеет конечные односторонние пределы в
нуле, а вторая ограничена вообще на всей оси — и тем не менее… Но это,
думаю, не столь критично: главное, что наличие любого из этих символов
в качестве вывода дает нам понять, что искомого предела не
существует.</p>
<p>Функция <code>limit()</code> в третьем
варианте — <code>limit(выражение)</code> — предназначена уже не для
поиска собственно пределов, а для упрощения выражений, содержащих
символы <code>inf</code> и <code>minf</code>:</p>
<img class="contract" src="i/tarnavsky/4/maxima4-06.png" alt="">
<p>Выражения такого рода могут возникать, к примеру, при подстановках
в формулы результатов вычисления каких-то других пределов или
интегралов.</p>
<p>Такая способность — принимать различные списки аргументов — не
является в Maxima чем-то особенным; она свойственна очень многим
встроенным функциям, как и различное действие в зависимости от
значений разнообразных переключателей. Это достаточно удобно: не нужно
запоминать много разных имен функций (для поиска пределов, к примеру,
используется исключительно функция <code>limit</code>); для вычисления
производных, в том числе и частных, — функция <code>diff</code> (с
которой мы уже бегло ознакомились в первой статье и сейчас продолжим
это знакомство); для нахождения интегралов, как определенных, так и
неопределенных — функция integrate (с которой мы тоже сегодня
познакомимся). Имена наиболее часто используемых функций запомнить
несложно, а о дополнительных ключах или флагах, в случае чего, можно
прочитать во встроенной справке,
набрав <code>? имя-функции</code>.</p>
<p>Об этих самых ключах к функции limit и осталось рассказать. Первый
ключ называется <code>lhospitallim</code> и задает максимальное
количество применений правила Лопиталя; название ключа и происходит от
фамилии ученого, давшей название самому правилу, которая в оригинале
пишется как <em>L’Hospital</em>. Напомню, правило это гласит, что в
случае неопределенности вида 0/0 или можно продифференцировать
числитель и знаменатель — и предел от этого не изменится. Ограничитель
количества применений этого правила нужен для того, чтобы избежать
зацикливаний, которые могут случиться для бесконечно дифференцируемых
функций, у которых в данной точке равны нулю либо бесконечности все
производные. По умолчанию значение <code>lhospitallim</code> равно
четырем, и мне не удалось сходу придумать пример, когда этого не
хватает — ведь функция поиска предела использует не только правило
Лопиталя, но и другие соотношения; и для всех заданных мною
соотношений двух функций с корнями выше четвертого порядка в искомой
точке предел был успешно найден и при умолчательном значении.</p>
<p>Второй ключ к функции <code>limit</code> — это
флаг <code>limsubst</code>, который, будучи выставлен
в <code>true</code>, позволяет этой функции производить подстановки
внутрь неизвестных выражений. По умолчанию этот флаг
равен <code>false</code>, что исключает ошибки вроде такой:</p>
<img class="contract" src="i/tarnavsky/4/maxima4-07.png" alt="">
<p>И, наконец, последний дополнительный параметр — еще один флаг, по
имени <code>tlimswitch</code>. По умолчанию он тоже выключен, а если
его включить, функция <code>limit</code> будет, при невозможности
найти предел другими способами, пытаться его найти путем разложения
подпредельной функции в ряд Тейлора в окрестности заданной точки:</p>
<img class="contract" src="i/tarnavsky/4/maxima4-08.png" alt="">
<p>Но в случае поиска односторонних пределов, в тех точках, где они не
равны между собой, то есть полного предела не существует, этим флагом
нужно пользоваться с осторожностью: при его включении
функция <code>limit</code> может вернуть в качестве полного предела
один из односторонних:</p>
<img class="contract" src="i/tarnavsky/4/maxima4-09.png" alt="">
<p>Реально у этой функции в точке ноль только предел справа равен
единице; а предел слева — нулю.</p>
<p>И последнее: почему я употребил в начале по отношению к
функции <code>limit()</code> слово «полноценная». Потому что кроме нее
существует еще одна «недофункция» — <code>tlimit()</code>; она
представляет собой фактически просто-напросто вызов самой
функции <code>limit()</code> с поднятым
флагом <code>tlimswitch</code>, то есть пытается при необходимости
разложить «подпредельную» функцию в ряд Тейлора вне зависимости от
реального значения этого флага. Другими словами
вызов <code>tlimit(аргументы)</code> полностью аналогичен
записи <code>limit(аргументы)</code>, <code>tlimswitch:true</code>;
только чуть короче. И аргументы она может принимать точно такие
же.</p>
<h3>…дифференцируем и интегрируем</h3>
<p>О функции <code>diff</code> я кое-что уже рассказывал в первой
статье, и здесь это «кое-что» только напомню. В двух упомянутых тогда
вариантах вызова эта функция принимала один либо два аргумента. С
двумя, <code>diff(выражение, переменная)</code>, она возвращает
производную от «выражения» по заданной переменной; с
одним, <code>diff(выражение)</code> — полный дифференциал заданного
выражения. Другими словами, запись <code>diff(f, x)</code> равнозначна
математическому обозначению d<var>f</var>/d<var>x</var>,
а <code>diff(f)</code> — d<var>f</var>.</p>
<p>Но это еще не все. Кроме одного либо двух, эта функция может также
принимать любое нечетное число агрументов
вида <code>diff(выражение, переменная, порядок, переменная, порядок, …)</code>
и возвращает при этом производную либо смешанную частную производную
от выражения заданных порядков по заданным переменным. К
примеру, <code>diff(f, x, 3)</code> означает
d<sup>3</sup><var>f</var>/d<var>x</var><sup>3</sup>,
а <code>diff(f, x, 1, y, 2, z, 1)</code> —
d<sup>4</sup><var>f</var>/d<var>x</var>d<var>y</var><sup>2</sup>d<var>z</var>. Единственный
флаг, имеющий прямое отношение к самой функции <code>diff</code> — это
флаг derivabbrev, который влияет на отображение производных в ячейках
вывода Maxima. По умолчанию он равен <code>false</code>, и производные
обозначаются в виде дробей с буквой d; если же его выставить
в <code>true</code>, производные будут отображаться в сокращенном
виде, с переменными дифференцирования записанными в виде индексов:</p>
<img class="contract" src="i/tarnavsky/4/maxima4-10.png" alt="">
<p>Кроме того, функция <code>diff</code> используется еще и для
обозначения производных в дифференциальных уравнениях. Но об этом чуть
позже, а сейчас перейдем к интегрированию.</p>
<p>Основная функция интегрирования называется, как я уже
говорил, <code>integrate</code> и имеет два варианта вызова: для
нахождения неопределенного и определенного интегралов. Первый выглядит
как <code>integrate(выражение, переменная)</code>, второй —
как <code>integrate(выражение, переменная, нижний-предел, верхний-предел)</code>:</p>
<img class="contract" src="i/tarnavsky/4/maxima4-11.png" alt="">
<p>Вы, наверное, обратили внимание еще на один момент в
ячейках <code>%i4</code>–<code>%o4</code>. Когда в выражении
используется какой-либо независимый символ, результат, вообще говоря,
может зависеть от значения этого символа. Если при этом о возможных
значениях символа ничего не известно, то Maxima задаст вам один или
несколько вопросов об этом значении, и решение будет искать в
зависимости от ваших ответов на них. Так, в этом примере значение
определенного интеграла напрямую зависит от знака параметра a:</p>
<img class="contract" src="i/tarnavsky/4/maxima4-12.png" alt="">
<p>Кроме обычных определенных интегралов Maxima умеет искать также и
несобственные интегралы, то есть такие, у которых неограничена либо
область интегрирования, либо подынтегральная функция; и делается это
все той же функцией <code>integrate</code>:</p>
<img class="contract" src="i/tarnavsky/4/maxima4-13.png" alt="">
<p>В случае, если искомый интеграл не сходится, будет выдано сообщение
об ошибке, говорящее о том, что интеграл расходящийся:</p>
<img class="contract" src="i/tarnavsky/4/maxima4-14.png" alt="">
<p>В случае, если интеграл не может быть найден, он либо целиком
возвращается в несовершенном виде, либо упрощается частично и на
выходе получается некоторая формула, включающая в несовершенном виде
интеграл той части подынтегрального выражения, которую
проинтегрировать не удалось:</p>
<img class="contract" src="i/tarnavsky/4/maxima4-15.png" alt="">
<p>Кроме функций <code>diff</code> и <code>integrate</code>, в Maxima
есть еще много разнообразных возможностей, связанных с производными и
интегралами, в частности, функции для численного расчета значений
определенных интегралов, а также инструменты, применимые при работе с
дифференциальными и интегральными уравнениями. И разнообразны они
настолько, что для того, чтобы рассмотреть подробно и с примерами их
все, не хватило бы всего этого цикла. А более тезисно, хотя и на
английском языке, они описаны в документации. Посему с этой темой на
этом прекращаем и движемся дальше.</p>
<h3>Решайте, сударь!</h3>
<p>А дальше мы рассмотрим уравнения и их системы, и даже не столько
рассмотрим, сколько порешим… то есть, конечно, порешаем. Уравнения и
системы уравнений решаются в Maxima тоже одной и той же функцией, и
тоже уже вам слегка знакомой по первой статье: это
функция <code>solve</code>. Но прежде чем рассмотреть ее подробнее,
нужно сказать пару слов о списках, или векторах, в Maxima; поскольку
именно в виде списков solve возвращает корни, да и принимает параметры
в случае решения системы уравнений, а не одного уравнения.</p>
<p>Синтаксис списков в Maxima весьма прост; это перечисление элементов
в квадратных
скобках: <code>[элемент1, элемент2, …, элементN]</code>. Особенность —
не в синтаксисе. Основное достоинство Maximaльных списков в том, что
их элементами могут быть совершенно любые выражения: символы,
арифметические выражения, вызовы функций, присвоения, уравнения,
другие списки… Додумать можете сами. Поэтому списки и во встроенных
функциях применяются достаточно широко. Функция <code>solve</code> в
своем простейшем варианте, для решения одиночного уравнения, в
качестве аргументов никаких списков, напомню, не принимает (а
принимает либо уравнение и символ, относительно которого его надо
решать, либо только уравнение, если символ в нем всего один). А вот в
качестве результата она уже и в таком варианте возвращает список,
состоящий из всех корней заданного уравнения:</p>
<img class="contract" src="i/tarnavsky/4/maxima4-16.png" alt="">
<p>Как видите, функция <code>solve</code> находит все комплексные
корни уравнения, а не только действительные.</p>
<p>К элементу списка можно обратиться с помощью тех же квадратных
скобок, указав в них номер элемента после имени списка. Напомню, что
равенство, переданное в качестве дополнительного параметра функции ev,
означает подстановку переменной в вычисляемое выражение. Вот так мы
можем осуществить проверку решения, подставив корень из выданного
списка в исходное уравнение:</p>
<img class="contract" src="i/tarnavsky/4/maxima4-17.png" alt="">
<p>Точно таким же образом можно обратиться и к любому другому элементу списка:</p>
<img  class="contract" src="i/tarnavsky/4/maxima4-18.png" alt="">
<p>Вообще говоря, в качестве первого аргумента
функции <code>solve</code> можно задавать не только уравнение, а
вообще любое выражение. При этом «корни выражения» (не являющегося
уравнением) ищутся в том самом смысле, в каком эта фраза понимается в
математике: корни выражения — это те значения переменной, на которых
выражение обращается в ноль. Возможность такой записи позволяет, к
примеру, легко найти критические точки любой непрерывной функции (а
заодно и вычислить значения функции в этих точках):</p>
<img class="contract" src="i/tarnavsky/4/maxima4-19.png" alt="">
<p>В этом примере есть еще два важных момента. Первый —
функция <code>%th()</code>. Она, как видно из контекста, вызывается
как <code>%th(n)</code> и возвращает <var>n</var>-ю с конца ячейку
вывода. Это, так же как и обозначения <code>%</code> и <code>_</code>,
удобно, чтобы не обращать внимания на номера ячеек, и кроме того,
применимо в командных файлах Maxima, которые могут загружаться в том
числе и прямо из интерактивной сессии (с помощью
функции <code>load</code>) — и тогда просто заранее неизвестно,
начиная с какой ячейки данный файл загружен. И второй момент: здесь
проиллюстрировано, что в Maxima операция индексирования списка
доступна не только по отношению к именам переменных, но и к вызовам
функций; другими словами, если функция возвращает список значений, мы
можем выбрать одно конкретное из них, написав его номер в квадратных
скобках прямо после вызова функции.</p>
<p>Вернемся к функции <code>solve</code>. А именно, перейдем теперь к
решению систем уравнений. Для этого существует такой вариант
записи: <code>solve([уравнение1, уравнение2, …],
[переменная1, переменная2, …])</code>; либо сокращенный, аналогично
варианту для одиночного уравнения: если количество уравнений и
количество неизвестных равны, список неизвестных можно не
писать: <code>solve([уравнение1, уравнение2  …])</code> (не забудьте
квадратные скобки, иначе Maxima примет его за вариант с одним
уравнением).</p>
<img class="contract" src="i/tarnavsky/4/maxima4-20.png" alt="">
<p>Здесь возвращается список из нескольких списков, каждый из которых
соответствует одному решению системы. В качестве подстановок можно
использовать как такие списки целиком (например, в данном
контексте, <code>%o1[1]</code>), так и отдельные их элементы
(например, <code>%o1[1][1]</code>).</p>
<p>В случае, когда уравнений меньше, чем
неизвестных, <code>solve</code> поступит точно так же, как и в случае
одного уравнения с несколькими символами: все неуказанные будет
воспринимать как параметры:</p>
<img class="contract" src="i/tarnavsky/4/maxima4-21.png" alt="">
<p>Если <code>solve</code> не находит точных решений, она может, как
и <code>integrate</code>, вернуть уравнение или систему уравнений в
некотором упрощенном виде, а может и самостоятельно попытаться решить
систему численно:</p>
<img class="contract" src="i/tarnavsky/4/maxima4-22.png" alt="">
<p>В таком случае, если вам все же нужны точные значения корней (в
аналитической записи), либо если они не найдены даже в числах, можно
попробовать решить уравнения по очереди, выражая одно неизвестное
через другое:</p>
<img class="contract" src="i/tarnavsky/4/maxima4-23.png" alt="">
<p>И подставляя в оставшиеся уравнения:</p>
<img class="contract" src="i/tarnavsky/4/maxima4-24.png" alt="">
<p>Теперь можем подставить обратно — и найти значения второй
неизвестной, например, для первого и последнего корней из последнего
списка:</p>
<img class="contract" src="i/tarnavsky/4/maxima4-25-thumb.png" alt="">
<p>Функция <code>solve</code> имеет довольно большое количество
различных переключателей, из которых может пригодиться в своем
не-умолчательном значении в первую очередь
один: <code>solveradcan</code>. Умолчание здесь
равно <code>false</code>, а выставив этот флаг в <code>true</code>, мы
заставим <code>solve</code>, помимо его умолчательного поведения,
применять <code>radcan</code> — функцию по упрощению показательных,
логарифмических и степенных (с рациональными степенями) функций. Это
делает работу функции <code>solve</code> более медленной (потому по
умолчанию этот режим и выключен), но в некоторых случаях может помочь
разрешить проблемы, которые без этого ключа приведут к невозможности
найти точное решение.</p>
<h3>И снова дифференцируем и интегрируем</h3>
<p>Помимо «просто» уравнений, Maxima позволяет также решать и
обыкновенные дифференциальные уравнения первого и второго
порядка. Функций, непосредственно занимающихся решением таких
уравнений, существует две. Первая из них занимается поиском частных
решений линейных дифференциальных уравнений и систем таких уравнений;
зовут ее <code>desolve</code>, от слов <em>differential equation
solve</em>. Эта функция принимает два аргумента, первый из которых —
уравнение либо список уравнений, а второй — соответственно одна
переменная или список переменных. Если не заданы значения функций
и/или их производных в нуле, то в найденном решении они просто
отображаются в виде <code>f(0)</code> или</p>
<img class="contract" src="i/tarnavsky/4/maxima4-26.png" alt="">
<p>задать эти значения позволяет
функция <code>atvalue(выражение, переменная = точка, значение)</code>;
то есть, в данном случае <code>atvalue(f(x), x=0, значение)</code>
или <code>atvalue('diff(f(x)), x=0, значение)</code>. Производные в
уравнениях и системах, решаемых с помощью этой функции, должны быть
записаны непременно в виде <code>'diff(f(x), x)</code>, а не
просто <code>'diff(f, x)</code>, а сами функции, соответственно, тоже
в виде <code>f(x)</code>, а не <code>f</code> — нужно
продемонстрировать зависимость функции от ее аргумента.</p>
<img class="contract" src="i/tarnavsky/4/maxima4-27.png" alt="">
<p>И конечно же, точно так же как для обычных уравнений и систем,
здесь мы тоже можем проверить решение с помощью подстановки, но только
надо еще дополнительно задать принудительное вычисление производных,
так как в уравнениях они фигурируют в несовершенной форме:</p>
<img class="contract" src="i/tarnavsky/4/maxima4-28.png" alt="">
<p>Вторая функция из этой группы называется <code>ode2</code> и
предназначена она для решения обыкновенных дифференциальных уравнений
первого и второго порядка; ее название происходит от
фразы <em>ordinary differential equations of 1st or 2nd
order</em>. Пишется она
так: <code>ode2(уравнение, зависимая-переменная, независимая-переменная)</code>. Здесь
уже независимая переменная указывается в списке параметров функции
явно, и потому обозначения вида <code>y(x)</code> не нужны: и функция,
и переменная обозначаются просто одиночными буквами. Также в отличие
от предыдущей функции, <code>ode2</code> ищет не частное, а общее
решение. Произвольная константа в решении уравнения первого порядка
обозначена через <code>%c</code>; в решении уравнения второго порядка
таких констант, естественно, две, и обозначаются они
как <code>%k1</code> и <code>%k2</code>.</p>
<img class="contract" src="i/tarnavsky/4/maxima4-29.png" alt="">
<p>В дополнение к функции <code>ode2</code> существуют три функции для
поиска частных решений на основе полученных общих. Иначе говоря, эти
функции, получая конкретные условия относительно значения
функции-решения в заданной точке, находят исходя из этих значений
соответствующие им величины интегральных констант. Одна из этих
функций предназначена для обработки решения дифференциального
уравнения первого порядка. Она называется <code>ic1</code> (<em>i</em>
от <em>initial value</em> — <em>начальное значение</em>; <em>c</em>
от <em>constant</em> — <em>константа</em>; <em>1</em>
от <em>1<sup>st</sup> order</em> — <em>первого порядка</em>) и
принимает три аргумента: первый — само решение, в том виде, в котором
его находит функция <code>ode2</code>; второй — значение независимой
переменной (<var>x</var>-координаты), третий — значение функции
(зависимой переменной, <var>у</var>) при этом значении <var>x</var> и
возвращает частное решение, проходящее через точку с заданными
координатами (<var>x</var>, <var>y</var>):</p>
<img class="contract" src="i/tarnavsky/4/maxima4-30.png" alt="">
<p>И две функции работают с решениями уравнений второго порядка. Так
как в общем решении уравнения второго порядка фигурируют две
независимые константы, то эти функции задают уже по два условия для
поиска частного решения. Первая функция выглядит
как <code>ic2(общее решение, x, функция-в-точке-x, производная-в-точке-x)</code>. Расшифровка
названия аналогична предыдущей функции. Действует тоже аналогично ей,
а в качестве второго условия задает значение производной в той же
заданной точке:</p>
<img class="contract" src="i/tarnavsky/4/maxima4-31.png" alt="">
<p>И последняя функция называется <code>bc2</code> (<em>b</em>
от <em>boundary value</em> — граничное значение; а дальше все как в
предыдущей). Ее аргументы: первым, как и в двух остальных вариантах,
идет само общее решение, возвращенное функцией <code>ode2</code>;
после него идут две пары
значений: <var>x</var> <sub>0</sub>, <var>y</var><sub>0</sub>, <var>x</var><sub>1</sub>, <var>y</var><sub>1</sub>,
задающие две точки, через которые должен проходить график
функции-решения:</p>
<img class="contract" src="i/tarnavsky/4/maxima4-32.png" alt="">
<p>Касательно дифференциальных уравнений все этими функциями и
заканчивается, никаких дополнительных ключей к ним не
предназначено.</p>
<p>В следующий раз мы поговорим о средствах построения графиков
функций и о средствах автоматизации: условных операторах, циклах и
управляющих условиях, налагаемых на различные символы и выражения.</p>
</div>
</div>
<div class="rightcolumn">
<div class="menu">
<ul>
  <li><a href="index.html">главная страница</a></li>
  <li><a href="download.html">Загрузка</a></li>
  <li><a href="documentation.html">Документация</a></li>
  <li><a href="../project.html">Maxima Project</a></li>
  <li><a href="maximalist.html">Списки рассылки</a></li>
  <li><a href="faq.html">Ответы на часто задаваемые вопросы</a></li>
  <li><a href="compalg.html">Компьютерная алгебра</a></li>
  <li><a href="lisp.html">Ссылки по Lisp</a></li>
  <li><a href="3rdpartycode.html">Дополнительные пакеты</a></li>
  <li><a href="relatedprojects.html">Связанные проекты</a></li>
</ul>
</div>
</div>
</div>
<div class="footer">
<p>Любые вопросы о Maxima или этом сайте должны быть заданы в <a href="maximalist.html">списке рассылки</a>.</p>
<span>Последняя модификация: 2022/03/30 11:50:14 UTC</span>
</div>
</body>
</html>
