<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Maxima — практически законченная система компьютерной алгебры, написанная на Lisp, с упором на символьные вычисления. Она основана на DOE-MACSYMA и лицензированна под GPL. В числе возможностей Maxima — символьное интегрирование, построение трехмерных графиков, решение ОДУ.">
<meta name="keywords" content="Maxima, CAS, computer algebra, mathematics, Lisp, symbolic computation, MACSYMA, GPL, free, ODE, plotting, система компьютерной алгебры, компьютерная алгебра, математика, символьные вычисления, свободно">
<title>Maxima &ndash; максимум свободы символьных вычислений</title>
<link rel="stylesheet" href="../maxima.css">
<link rel="icon" type="../image/svg+xml" href="img/maxima.svg">
<link rel="alternate icon" href="../img/favicon.ico">
</head>
<body>
<div class="header">
<img style="float:left" src="../img/maxima.svg">
<h1>Maxima</h1>
<p>Система компьютерной алгебры</p>
</div>
<div class="row">
<div class="leftcolumn">
<div class="card">
<h2>Тихон Тарнавский. Maxima — укротитель выражений</h2>
<p>Впервые было опубликовано в
«<a href="http://www.linuxformat.ru/">Linux
Format</a>» <a href="http://www.linuxformat.ru/download/83.pdf">№9
(83), сентябрь 2006 г</a>.</p>
<p>В этот раз я расскажу о штатных возможностях Maxima по упрощению и
прочим преобразованиям выражений. В частности, речь пойдет об
автоматическом раскрытии скобок и вынесении за скобки; об упрощении
как арифметических действий над некоторыми элементами, так и выражений
с участием степенных, показательных и логарифмических функций; а также
об обработке тригонометрических выражений. Все эти функции призваны
облегчать читаемость математических формул и повышать простоту их
восприятия, а посему стоит уделить этому уроку достаточно внимания:
при верном использовании данные манипуляции позволят сэкономить в
процессе работы значительное количество времени.</p>
<h3>Выражаясь рационально…</h3>
<p>Существенная часть интересующих нас сегодня функций предназначена
для преобразования рациональных выражений. Напомню, рациональным
называется выражение, состоящее только из арифметических операторов и
возведения в натуральную степень; естественно, элементы такого
выражения могут содержать и неарифметические и нестепенные функции —
тогда такие элементы с точки зрения рационального выражения считаются
атомарными, т.е. неделимыми и непреобразуемыми.</p>
<p>Функции, работающие с рациональными выражениями, описаны в разделе
документации «<em>Polynomials</em>»; потому как рациональные функции с
математической точки зрения рассматриваются как расширение многочленов
(полиномов) — примерно так же, как рациональные числа считаются
расширением целых (многочлены, кстати, тоже иногда называют целыми
функциями; хотя общий математический смысл этого термина несколько
шире).</p>
<p>Имена всех функций Maxima по обработке рациональных выражений
содержат буквосочетание <code>rat</code>, но не от
слова <em>крыса</em>, а от слова <em>rational</em>. И начнем мы
знакомство с ними с функции, которая так и
называется: <code>rat(выражение)</code>. Эта функция преобразовывает
рациональное выражение к так называемой <em>канонической форме</em>
(<em>Canonical Rational Expression</em>, <em>CRE</em>). То есть
раскрывает все скобки, затем приводит все к общему знаменателю,
суммирует и сокращает; кроме того, приводит все числа в конечной
десятичной записи к рациональным.</p>
<img class="contract" src="i/tarnavsky/3/maxima3-01.png" alt="">
<p>Тут надо заметить, что атомарные элементы, т.е. символы и числа, в
канонической форме рационального выражения в Maxima имеют другое
внутреннее представление. При работе в интерфейсах Maxima и xMaxima об
этом напоминает приписка <code>/R/</code> после имени ячейки вывода (в
wxMaxima и TeXmacs такая приписка отсутствует). При этом внешне, на
видимом пользователю уровне, каноническая форма ничем, кроме этого
обозначения, от общей не отличается. Но один достаточно интересный
момент здесь есть: если каноническая форма рационального выражения
используется в других рациональных выражениях, то последние также
автоматически приводятся к канонической форме:</p>
<img class="contract" src="i/tarnavsky/3/maxima3-02.png" alt="">
<p>Это может быть достаточно удобно, если вам нужно пошагово проделать
большое количество рациональных преобразований: вы можете, один раз
вызвав <code>rat()</code>, ссылаться на предыдущие ячейки и благодаря
этому далее автоматически видеть на каждом шаге итоговое выражение в
канонической, а значит, достаточно компактной и удобной к восприятию,
форме. Если на каком-то этапе такое поведение станет вам мешать, вы
можете вернуть выражение из канонической к общей форме с помощью
функции <code>ratdisrep(выражение)</code>. Кроме того, каноническая
форма автоматически «отменяется» и в случае любых преобразований, не
являющихся рациональными:</p>
<img class="contract" src="i/tarnavsky/3/maxima3-03.png" alt="">
<p>Здесь, хотя <code>%o2</code> было выражением в канонической
форме, <code>%o3</code> — уже выражение общего вида, так как оно не
является рациональным.</p>
<p>Скажем пару слов о приведении конечной десятичной записи чисел к
рациональной. Конечная десятичная запись считается по определению
приблизительной, что и понятно, т.к. при вычислениях самой Maxima
такая запись может возникнуть исключительно при применении
приближенных методов либо при ручном указании о переводе числа в
десятичную запись из математической, в результате чего результат тоже,
вероятнее всего, окажется приблизительным. Эта приблизительность
учитывается и при переводе в рациональные числа, а ее уровень, то есть
мера, на которую рациональное число при переводе может отклониться от
конечной десятичной записи, регулируется
переменной <code>ratepsilon</code>, равной по
умолчанию <code>2.0e-8</code>, т.е. <code>0.00000002</code>. Если
такое положение вещей вас не устраивает, вы можете убедить Maxima
оставлять десятичную запись чисел как есть, установив
в <code>true</code> значение флага <code>keepfloat</code> (по
умолчанию он равен <code>false</code>).</p>
<p>Следующая функция раскрывает скобки в рациональном выражении и
называется <code>ratexpand()</code> (одно из значений
слова <em>expand</em> и есть «раскрыть скобки»). Здесь также действует
опция <code>keepfloat</code>. Кроме нее, есть еще одна
опция — <code>ratdenomdivide</code>; по умолчанию она установлена
в <code>true</code>, что приводит к тому, что каждая дробь, в которой
числитель является суммой, распадается на сумму дробей с одинаковым
знаменателем. Если же сбросить эту опцию в <code>false</code>, тогда
все дроби с одинаковым знаменателем будут, напротив, объединены в одну
дробь с числителем в виде суммы числителей изначальных дробей. То есть
внешне результат будет в этом случае выглядеть почти так же, как и у
функции <code>rat()</code>; к тому же единственная видимая
пользователю разница проявляется только в рациональных выражениях от
нескольких переменных (или различных иррациональных
выражений). Заключается эта разница в том, что
после <code>ratexpand()</code> и в числителе, и в знаменателе дроби
все скобки будут раскрыты, в случае же <code>rat()</code> слагаемые,
где присутствуют, скажем, две переменных, будут сгруппированы, и одна
из них будет вынесена за скобки (в документации такая форма записи
называется «рекурсивной» (<em>recursive</em>):</p>
<img class="contract" src="i/tarnavsky/3/maxima3-04.png" alt="">
<p>Кроме того, разница, конечно, заключается и во внутреннем
представлении: с точки зрения программы, после ratexpand() выражение
будет по-прежнему общего вида. Соответственно и все результаты
дальнейших рациональных действий с выражением не будут автоматически
«канонизироваться». Я специально обращаю ваше внимание на схожесть
между результатами этих двух различных функций, поскольку в
документации эта схожесть никак не обозначена: в описании обеих
функций и примерах к ним нет вообще никаких ссылок друг на друга.</p>
<p>Помимо флага <code>ratdenomdivide</code>, есть также функция,
собирающая воедино дроби с одинаковыми знаменателями; зовут
ее <code>combine()</code>:</p>
<img class="contract" src="i/tarnavsky/3/maxima3-05.png" alt="">
<p>В дополнение к функции <code>ratexpand()</code> есть также
флаг <code>ratexpand</code>, который по умолчанию
равен <code>false</code>, а будучи установлен в <code>true</code>,
приводит к тому, что все рациональные выражения в канонической форме
отображаются и преобразовываются к общему виду сразу же с раскрытыми
скобками:</p>
<img class="contract" src="i/tarnavsky/3/maxima3-06.png" alt="">
<p>Обратите внимание, что при применении этого флага выражение
сохраняет каноническую форму.</p>
<p>Действует в этом случае и флаг <code>ratdenomdivide</code>
(напомню, что в строке <code>%i1</code> этот флаг был установлен
локально, используя сокращенную запись функции <code>ev()</code>):</p>
<img class="contract" src="i/tarnavsky/3/maxima3-07.png" alt="">
<p>Иными словами, флаг ratexpand по своему действию аналогичен
одноименной функции, но действует он на все без исключения
канонические рациональные выражения и при этом оставляет их в
канонической внутренней записи и изменяет только внешнее отображение
этой записи, сохраняя при этом и дальнейшую автоматическую
«канонизацию».</p>
<h3>…и не только рационально.</h3>
<p>Помимо <code>ratexpand()</code> есть также и функция
«просто» <code>expand()</code>. Различий между ними несколько,
наиболее принципиальные таковы. Вопервых, <code>ratexpand()</code>
раскрывает только рациональное выражение «верхнего уровня», все же
подвыражения, не являющиеся рациональными, обрабатываются как
атомарные, то есть внутрь них она не залезает; <code>expand()</code>
же раскрывает скобки на всех уровнях вложенности:</p>
<img class="contract" src="i/tarnavsky/3/maxima3-08.png" alt="">
<p>Во-вторых, <code>ratexpand()</code> приводит дроби-слагаемые к
общему знаменателю, а <code>expand()</code> этого не делает;
в-третьих, на функцию expand не действует
переключатель <code>ratdenomdivide</code>:</p>
<img class="contract" src="i/tarnavsky/3/maxima3-09.png" alt="">
<p>И в-четвертых, <code>expand()</code> не преобразовывает к
рациональным числам конечную десятичную запись — опять-таки, вне
зависимости от флага <code>keepfloat</code>.</p>
<p>Функция <code>expand()</code>, в отличие от своего рационального
сородича, имеет несколько вариаций — в виде отдельных функций с
похожими названиями, которые раскрывают скобки несколько
по-разному. Первую мы уже рассмотрели. Вторая
называется <code>expandwrt(выражение, x, y, …, v)</code>,
где <em>wrt</em> расшифровывается как «with respect to…», то есть
«относительно…». Она раскрывает скобки не везде, а только относительно
тех символов, которые заданы в списке аргументов после
выражения. Другими словами, только там, где из скобок можно вынести
хотя бы один из перечисленных символов:</p>
<img class="contract" src="i/tarnavsky/3/maxima3-10.png" alt="">
<p>(На предупреждение, возникающее при первом вызове
функций <code>expandwrt*()</code>, можете не обращать внимания — на
функционале, о котором идет речь, оно никоим образом не
отражается.)</p>
<p>Если в выражении встречаются дроби, то по умолчанию эта функция
раскрывает скобки только в их числителях, оставляя знаменатели в
покое. Изменить это поведение можно
переключателем <code>expandwrt_denom</code>, установив его
в <code>true</code> (по умолчанию он равен <code>false</code>):</p>
<img class="contract" src="i/tarnavsky/3/maxima3-11.png" alt="">
<p>И, наконец, последняя функция из этого
семейства — <code>expandwrt_factored(выражение, x, y, …, v)</code> —
раскрывает скобки лишь в тех слагаемых, где упомянутые символы
встречаются не в одном, а в каждом из сомножителей:</p>
<img class="contract" src="i/tarnavsky/3/maxima3-12.png" alt="">
<p>Раскрытием возведения в целую степень можно управлять как в
контексте функции <code>expand()</code>, так и отдельно. В первом
случае применяются переменные maxposex и maxnegex, определяющие
соответственно максимальные положительный и отрицательный показатель
степени, которые будут раскрываться этой функцией. По умолчанию оба
параметра равны <code>1000</code>. Переназначить их можно не только
глобально, но и в контексте одного конкретного вызова
функции <code>expand()</code> — в таком случае это делается с помощью
дополнительных аргументов, задаваемых после выражения:</p>
<img class="contract" src="i/tarnavsky/3/maxima3-13.png" alt="">
<p>В противовес <code>maxposex</code> и <code>maxnegex</code> можно
задать максимальные положительную и отрицательную степени, которые
будут раскрываться автоматически, без вызова функций
группы <code>expand</code>. За это отвечают
переменные <code>expop</code> и <code>expon</code>, и по умолчанию они
равны нулю, то есть автоматически степени не раскрываются вообще.</p>
<p>Кроме самостоятельной функции <code>expand()</code>, существуют
также флаги <code>expand</code> и <code>expand(p, n)</code> у
функции <code>ev()</code>. Запись выражение, <code>expand</code>
равносильна <code>expand(ev(выражение))</code>, а
выражение <code>expand(p, n)</code> — <code>expand(ev(выражение, p, n))</code>.</p>
<p>Возможности управлять раскрытием скобок на этом не
заканчиваются. Еще одна функция — <code>distrib()</code> —
представляет как бы облегченный вариант <code>expand()</code>. Она
действует аналогично <code>expand()</code>, но только на один уровень
в глубину:</p>
<img class="contract" src="i/tarnavsky/3/maxima3-14.png" alt="">
<p>В противоположность функциям <code>*expand*()</code>, раскрывающим
скобки, можно также и разложить выражение на множители, то есть
максимально повыносить все за скобки. Делается это с помощью
функции <code>factor()</code>:</p>
<img class="contract" src="i/tarnavsky/3/maxima3-15.png" alt="">
<p>Если функции <code>factor()</code> передать целое число, она
разложит его на простые множители; если же передать рациональное
число — на множители будут разложены его числитель и знаменатель:</p>
<img class="contract" src="i/tarnavsky/3/maxima3-16.png" alt="">
<p>Если многочлен не может быть представлен в виде произведения нескольких сомножителей, его можно попытаться преобразовать в сумму таких произведений с помощью функции <code>factorsum()</code>:</p>
<img class="contract" src="i/tarnavsky/3/maxima3-17.png" alt="">
<p>Функция <code>factorsum()</code> умеет раскладывать на множители
только независимые слагаемые, то есть такие, которые не содержат
одинаковых переменных. Если мы раскроем скобки в выражении, содержащем
в двух разных местах один и тот же символ, то так как коэффициенты при
этом символе после раскрытия сгруппируются, <code>factorsum()</code>
не сможет понять, каким именно образом разгруппировать их обратно:</p>
<img class="contract" src="i/tarnavsky/3/maxima3-18.png" alt="">
<p>Нужно заметить, что функции <code>factor()</code>
и <code>factorsum()</code>, хотя и не имеют в имени
приставки <code>rat</code>, все же ведут себя в смысле разбора
передаваемых им выражений не как <code>expand()</code> и
сопутствующие, а как <code>ratexpend()</code>; то есть на любой
не-рациональной функции останавливаются и внутрь не идут:</p>
<img class="contract" src="i/tarnavsky/3/maxima3-19.png" alt="">
<p>Впрочем, об этом можно догадаться из документации, так как
функции <code>factor*</code> описаны не в разделе «Simplification»,
куда относятся <code>expand*</code>, а, так же, как
и <code>rat*</code>, в разделе «Polynomials».</p>
<p>Выносить за скобки, а также раскрывать эти скобки можно не только
специальной функцией, но и дополнительным флагом ко все той же
канонической форме рациональных выражений. Флаг этот
зовут <code>ratfac</code>, и по умолчанию он равен <code>false</code>,
то есть вынесение за скобки не происходит. Если же его установить в
true, то в каждом рациональном выражении, приведенном к канонической
форме, все будет максимально вынесено за скобки, но без вызова
функции <code>factor()</code>; например, в примере ниже не произошло
обратного свертывания <code>(x+1)2</code>, хотя, будучи применен к
первоначальному выражению, флаг <code>ratfa</code>c сохранил и этот
множитель нераскрытым (также можете сравнить этот пример с аналогичным
примером к функциям <code>ratexpand()</code>
и <code>rat()</code>):</p>
<img class="contract" src="i/tarnavsky/3/maxima3-20.png" alt="">
<h3>Проще простого</h3>
<p>Итак, о преобразованиях выражений мы уже поговорили достаточно —
теперь перейдем к их упрощению. Об элементарных упрощениях мы уже
говорили в предыдущий раз: они могут производиться автоматически, на
что влияет установленный флаг <code>simp</code>; и по умолчанию именно
так и происходит.</p>
<p>Здесь тоже все начинается с рациональных выражений, которыми
занимается функция <code>ratsimp(выражение)</code>. Она упрощает
выражение за счет рациональных преобразований, но, в отличие от
остальных функций по обработке рациональных выражений, работает в том
числе и «вглубь», то есть иррациональные части выражения не
рассматриваются как атомарные, а упрощаются, в том числе, и все
рациональные элементы внутри них:</p>
<img class="contract" src="i/tarnavsky/3/maxima3-21.png" alt="">
<p>На <code>ratsimp()</code> действуют те же флаги, что и
на <code>rat()</code>: и <code>ratexpand</code>,
и <code>keepfloat</code>, и <code>ratfac</code>. Но отличается она
от <code>rat()</code> или <code>ratexpand()</code> не только умением
работать «в глубину», но и некоторыми дополнительными рациональными
преобразованиями, которые не поддерживаются этими двумя функциями:</p>
<img class="contract" src="i/tarnavsky/3/maxima3-23.png" alt="">
<p>Кроме функции <code>ratsimp()</code>, есть еще и дополнительный
переключатель — <code>ratsimpexpons</code>. По умолчанию он установлен
в <code>false</code>; если же назначить ему
значение <code>true</code> — это приведет к автоматическому упрощению
показателей степени:</p>
<img class="contract" src="i/tarnavsky/3/maxima3-24.png" alt="">
<p>Функция <code>ratsimp()</code> — это уже достаточно мощный, и в то
же время весьма быстрый, механизм упрощения; но, конечно, не
достаточный: ведь те действия, которые можно упростить в разнообразных
математических выражениях, не ограничиваются рациональными. Поэтому
все же основной плюс этой функции — это скорость. А для более
серьезных упрощений существует расширенный
вариант — <code>fullratsimp(выражение)</code>. Эта функция
последовательно применяет к переданному выражению
функцию <code>ratsimp()</code>, а также некоторые нерациональные
преобразования — и повторяет эти действия в цикле до тех пор, пока
выражение не перестанет в процессе них изменяться. За счет этого
функция работает несколько медленнее, чем <code>ratsimp()</code>, зато
дает более надежный результат — к некоторым выражениям, которые она
может упростить с ходу, <code>ratsimp()</code> пришлось бы применять
несколько раз, а иногда та и вообще не справилась бы с задачей.</p>
<img class="contract" src="i/tarnavsky/3/maxima3-25.png" alt="">
<p>И третья основная функция упрощения выражений — уже никак с
предыдущими двумя не
соотносящаяся — <code>radcan(выражение)</code>. Если <code>ratsimp()</code>
и <code>fullratsimp()</code> ориентированы на упрощение рациональных
действий, то <code>radcan()</code> занимается упрощением
логарифмических, экспоненциальных функций и степенных с нецелыми
рациональными показателями, то есть корней (радикалов). Например,
выражение из второго примера в этом разделе <code>radcan()</code>
сможет упростить сильнее,
чем <code>ratsimp()/fullratsimp()</code>:</p>
<img class="contract" src="i/tarnavsky/3/maxima3-26.png" alt="">
<p>В некоторых случаях наилучшего результата можно добиться,
комбинируя <code>radcan()</code> с <code>ratsimp()</code>
или <code>fullratsimp()</code>.</p>
<p>С функцией <code>radcan()</code> смежны по действию еще два
управляющих ключа. Один из них
называется <code>%e_to_numlog</code>. Влияет он не на саму функцию, а
на автоматическое упрощение. Если выставить его в <code>true</code>,
то выражения вида <code>e(r*log(выражение))</code>,
где <code>r</code> — рациональное число, будут автоматически
раскрываться в выражение <code>r</code>. Функция <code>radcan()</code>
делает такие преобразования независимо от значения ключа. Второй
ключ — <code>radexpand</code> (от <em>radical</em>, не путать
с <code>ratexpand</code>) — влияет на упрощение квадратного корня из
четной степени какого-либо выражения. Он, в отличие от большинства
переключателей, имеет не два, а три значения: при
значении <code>all</code>, <code>sqrt(x2)</code> будет раскрываться
в <code>x</code> — как для действительных, так и для комплексных
чисел; при значении <code>true</code> (по
умолчанию), <code>sqrt(x2)</code> для действительных чисел
превращается в <code>|x|</code>, а для комплексных не преобразуется; а
при значении <code>false</code>, <code>sqrt(x2)</code> не будет
упрощаться вообще.</p>
<p>Следующие две функции и один флаг относятся к упрощению
факториалов. Функция <code>factcomb(выражение)</code> проводит
упрощения вида <code>n!*(n+1) = (n+1)!</code> и тому
подобные. Функция <code>minfactorial</code>, напротив, сокращает
факториалы, то есть действует по
принципу <code>n!/(n–1)! = n</code>. И флаг <code>sumsplitfact</code>,
который изначально установлен в <code>true</code>, находясь в
состоянии <code>false</code>, приводит к тому, что после того, как
отработает <code>factcomb</code>, <code>minfactorial</code> вызывается
автоматически.</p>
<h3>Вот под таким углом…</h3>
<p>И напоследок поговорим о функциях для преобразования
тригонометрических формул. Здесь так же, как и у рациональных функций,
присутствует общая для всех приставка — <code>trig</code>;
расшифровывать ее, думаю, особой нужды нет. Начнем по традиции с
функции <code>trigexpand(выражение)</code>. Она, как нетрудно
догадаться, раскрывает скобки в тригонометрических выражениях:</p>
<img class="contract" src="i/tarnavsky/3/maxima3-27.png" alt="">
<p>Здесь, как обычно, есть несколько управляющих флагов, первый из
которых опять же является тезкой самой функции. Он приводит к
повторному раскрытию всех синусов-косинусов, то есть фактически
равнозначен повторному вызову самой функции:</p>
<img class="contract" src="i/tarnavsky/3/maxima3-28.png" alt="">
<p>Второй флаг — <code>halfangles</code> — управляет раскрытием формул
половинных углов. Оба эти флага по умолчанию сброшены. А следующие два
флага — <code>trigexpandplus</code> и <code>trigexpandtimes</code> —
отвечают соответственно за применение формул сумм углов и кратных
углов. То есть в примере выше сначала сработал
флаг <code>trigexpandplus</code>, а
затем — <code>trigexpandtimes</code>. Эти флаги по умолчанию
установлены, что и видно из примера.</p>
<p>Кроме всего уже упомянутого, есть еще флаги <code>trigsign</code>
и <code>triginverses</code>. Первый принимает традиционные два
значения (по умолчанию — <code>true</code>) и регулирует вынос знака
за пределы тригонометрической функции, то есть, к
примеру, <code>sin(–x)</code> упростится до <code>–sin(x)</code>,
а <code>cos(–x)</code> —
до <code>cos(x)</code>. Флаг <code>triginverses</code> — трехзначный,
и умолчательное его значение равно <code>all</code>. Он отвечает за
обработку сочетаний вида <code>sin(asin(x))</code>
или <code>atan(tan(x))</code>. Значение <code>all</code> позволяет
раскрывать эти сочетания в обоих направлениях (напомню, что при этом
часть корней будет теряться); значение <code>true</code> оставляет
разрешенным раскрытие только вида <code>sin(asin(x))</code>, то есть
блокирует вариант с потерями периодических значений; а
случай <code>false</code> запрещает оба направления
преобразований.</p>
<p>Функция, обратная <code>trigexpand()</code>,
называется <code>trigreduce(выражение)</code> — здесь, в полном
соответствии со значением слова <code>reduce</code>, действуют формулы
понижения степени. Например, применив дважды эту функцию к результату
предыдущего примера, мы получим его в исходном виде.</p>
<img class="contract" src="i/tarnavsky/3/maxima3-29.png" alt="">
<p>Эту функцию можно вызвать с более полным списком
аргументов: <code>trigreduce(выражение, переменная)</code> — тогда
формулы понижения степени будут применяться только по отношению к
заданной переменной (переменная может быть, как и почти везде, не
только отдельным символом, но и выражением).</p>
<p>Третья функция занимается уже упрощением, и зовут ее,
соответственно, trigsimp(выражение). Она старается упростить любое
тригонометрическое выражение, используя известные формулы, такие как
sin<sup>2</sup>(<var>x</var>) + cos<sup>2</sup>(<var>x</var>) = 1 и
тому подобные. Для наилучшего результата ее можно комбинировать
с <code>trigreduce()</code>, <code>ratsimp()/fullratsimp()</code>
и <code>radcan()</code>.</p>
<p>Этим возможности Maxima по преобразованию и упрощению разнообразных
выражений еще не совсем исчерпаны, но основные из них мы рассмотрели в
полной мере. В следующий раз поговорим немного о применении некоторых
встроенных функций, о работе с векторами, матрицами и множествами и,
возможно, о работе с логикой, с уравнениями и неравенствами, а также
их системами.</p>
</div>
</div>
<div class="rightcolumn">
<div class="menu">
<ul>
  <li><a href="index.html">главная страница</a></li>
  <li><a href="download.html">Загрузка</a></li>
  <li><a href="documentation.html">Документация</a></li>
  <li><a href="../project.html">Maxima Project</a></li>
  <li><a href="maximalist.html">Списки рассылки</a></li>
  <li><a href="faq.html">Ответы на часто задаваемые вопросы</a></li>
  <li><a href="compalg.html">Компьютерная алгебра</a></li>
  <li><a href="lisp.html">Ссылки по Lisp</a></li>
  <li><a href="3rdpartycode.html">Дополнительные пакеты</a></li>
  <li><a href="relatedprojects.html">Связанные проекты</a></li>
</ul>
</div>
</div>
</div>
<div class="footer">
<p>Любые вопросы о Maxima или этом сайте должны быть заданы в <a href="maximalist.html">списке рассылки</a>.</p>
<span>Последняя модификация: 2022/03/30 11:58:26 UTC</span>
</div>
</body>
</html>
