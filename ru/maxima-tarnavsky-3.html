<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="HandheldFriendly" content="true">
<meta name="copyright" content="© 2002–2014 Maxima CAS development team.">
<meta name="keywords" content="Maxima, CAS, computer algebra, mathematics, Lisp, symbolic computation, MACSYMA, GPL, free, ODE, plotting, система компьютерной алгебры, компьютерная алгебра, математика, символьные вычисления, свободно">
<title>Maxima - Руководства</title>
<!-- This site uses Bootstrap http://getbootstrap.com -->
<link rel="stylesheet" href="../css/bootstrap.min.css">
<link rel="shortcut icon" href="../i/favicon.ico" media="all">
<style type="text/css">
.mx-content {background:#f2f2f2;color:#333;padding: 0 1.5em 1.5em 1.5em;}
</style>
</head>
<body style="padding-top:50px;" id="top">
<a class="sr-only sr-only-focusable" href="#content">Перейти к основному содержанию</a>
<!-- Begin navigation bar -->
<header class="navbar navbar-inverse navbar-fixed-top" role="banner">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>                        
      </button>
      <a href="./index.html" class="navbar-brand" title="Перейти на
      главную страницу" style="padding: 0 0.75rem 0 1.5rem"><img
      src="../i/logo.png" width="56" height="56" alt="Maxima"></a>
    </div>
    <nav class="collapse navbar-collapse" id="myNavbar">
      <ul class="nav navbar-nav">
        <li><a href="../download.html">Загрузка</a></li>
        <li><a href="./documentation.html">Документация</a></li>
        <li><a href="../project.html" >проект</a></li>
        <li><a href="#top" >верх страницы</a></li>
      </ul>
    </nav>
  </div>
</header>
<!-- End navigation bar -->
<!-- Begin page -->
<div class="container-fluid">
  <!-- Begin content row -->
  <div class="row">
    <!-- Begin content column -->
    <div class="col-sm-9 col-md-8 mx-content" id="content">
      <h1>Тихон Тарнавский. Maxima — укротитель выражений</h1>
      <p>Впервые было опубликовано в
      «<a href="http://www.linuxformat.ru/">Linux
      Format</a>» <a href="http://www.linuxformat.ru/download/83.pdf">№9
      (83), сентябрь 2006 г</a>.</p>
      <p>В этот раз я расскажу о штатных возможностях Maxima по
      упрощению и прочим преобразованиям выражений. В частности, речь
      пойдет об автоматическом раскрытии скобок и вынесении за скобки;
      об упрощении как арифметических действий над некоторыми
      элементами, так и выражений с участием степенных, показательных
      и логарифмических функций; а также об обработке
      тригонометрических выражений. Все эти функции призваны облегчать
      читаемость математических формул и повышать простоту их
      восприятия, а посему стоит уделить этому уроку достаточно
      внимания: при верном использовании данные манипуляции позволят
      сэкономить в процессе работы значительное количество
      времени.</p>
      <h2>Выражаясь рационально…</h2>
      <p>Существенная часть интересующих нас сегодня функций
      предназначена для преобразования рациональных
      выражений. Напомню, рациональным называется выражение, состоящее
      только из арифметических операторов и возведения в натуральную
      степень; естественно, элементы такого выражения могут содержать
      и неарифметические и нестепенные функции — тогда такие элементы
      с точки зрения рационального выражения считаются атомарными,
      т.е. неделимыми и непреобразуемыми.</p>
      <p>Функции, работающие с рациональными выражениями, описаны в
      разделе документации «<em>Polynomials</em>»; потому как
      рациональные функции с математической точки зрения
      рассматриваются как расширение многочленов (полиномов) —
      примерно так же, как рациональные числа считаются расширением
      целых (многочлены, кстати, тоже иногда называют целыми
      функциями; хотя общий математический смысл этого термина
      несколько шире).</p>
      <p>Имена всех функций Maxima по обработке рациональных выражений
      содержат буквосочетание <code>rat</code>, но не от
      слова <em>крыса</em>, а от слова <em>rational</em>. И начнем мы
      знакомство с ними с функции, которая так и
      называется: <code>rat(выражение)</code>. Эта функция
      преобразовывает рациональное выражение к так
      называемой <em>канонической форме</em> (<em>Canonical Rational
      Expression</em>, <em>CRE</em>). То есть раскрывает все скобки,
      затем приводит все к общему знаменателю, суммирует и сокращает;
      кроме того, приводит все числа в конечной десятичной записи к
      рациональным.</p>
      <div class="well" style="background: #fff;">
        <img src="i/tarnavsky/3/maxima3-01.png" alt="">
      </div>
      <p>Тут надо заметить, что атомарные элементы, т.е. символы и
      числа, в канонической форме рационального выражения в Maxima
      имеют другое внутреннее представление. При работе в интерфейсах
      Maxima и xMaxima об этом напоминает приписка <code>/R/</code>
      после имени ячейки вывода (в wxMaxima и TeXmacs такая приписка
      отсутствует). При этом внешне, на видимом пользователю уровне,
      каноническая форма ничем, кроме этого обозначения, от общей не
      отличается. Но один достаточно интересный момент здесь есть:
      если каноническая форма рационального выражения используется в
      других рациональных выражениях, то последние также автоматически
      приводятся к канонической форме:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/3/maxima3-02.png" alt="">
      </div>
      <p>Это может быть достаточно удобно, если вам нужно пошагово
      проделать большое количество рациональных преобразований: вы
      можете, один раз вызвав <code>rat()</code>, ссылаться на
      предыдущие ячейки и благодаря этому далее автоматически видеть
      на каждом шаге итоговое выражение в канонической, а значит,
      достаточно компактной и удобной к восприятию, форме. Если на
      каком-то этапе такое поведение станет вам мешать, вы можете
      вернуть выражение из канонической к общей форме с помощью
      функции <code>ratdisrep(выражение)</code>. Кроме того,
      каноническая форма автоматически «отменяется» и в случае любых
      преобразований, не являющихся рациональными:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/3/maxima3-03.png" alt="">
      </div>
      <p>Здесь, хотя <code>%o2</code> было выражением в канонической
      форме, <code>%o3</code> — уже выражение общего вида, так как оно
      не является рациональным.</p>
      <p>Скажем пару слов о приведении конечной десятичной записи
      чисел к рациональной. Конечная десятичная запись считается по
      определению приблизительной, что и понятно, т.к. при вычислениях
      самой Maxima такая запись может возникнуть исключительно при
      применении приближенных методов либо при ручном указании о
      переводе числа в десятичную запись из математической, в
      результате чего результат тоже, вероятнее всего, окажется
      приблизительным. Эта приблизительность учитывается и при
      переводе в рациональные числа, а ее уровень, то есть мера, на
      которую рациональное число при переводе может отклониться от
      конечной десятичной записи, регулируется
      переменной <code>ratepsilon</code>, равной по
      умолчанию <code>2.0e-8</code>,
      т.е. <code>0.00000002</code>. Если такое положение вещей вас не
      устраивает, вы можете убедить Maxima оставлять десятичную запись
      чисел как есть, установив в <code>true</code> значение
      флага <code>keepfloat</code> (по умолчанию он
      равен <code>false</code>).</p>
      <p>Следующая функция раскрывает скобки в рациональном выражении
      и называется <code>ratexpand()</code> (одно из значений
      слова <em>expand</em> и есть «раскрыть скобки»). Здесь также
      действует опция <code>keepfloat</code>. Кроме нее, есть еще одна
      опция — <code>ratdenomdivide</code>; по умолчанию она
      установлена в <code>true</code>, что приводит к тому, что каждая
      дробь, в которой числитель является суммой, распадается на сумму
      дробей с одинаковым знаменателем. Если же сбросить эту опцию
      в <code>false</code>, тогда все дроби с одинаковым знаменателем
      будут, напротив, объединены в одну дробь с числителем в виде
      суммы числителей изначальных дробей. То есть внешне результат
      будет в этом случае выглядеть почти так же, как и у
      функции <code>rat()</code>; к тому же единственная видимая
      пользователю разница проявляется только в рациональных
      выражениях от нескольких переменных (или различных
      иррациональных выражений). Заключается эта разница в том, что
      после <code>ratexpand()</code> и в числителе, и в знаменателе
      дроби все скобки будут раскрыты, в случае же <code>rat()</code>
      слагаемые, где присутствуют, скажем, две переменных, будут
      сгруппированы, и одна из них будет вынесена за скобки (в
      документации такая форма записи называется «рекурсивной»
      (<em>recursive</em>):</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/3/maxima3-04.png" alt="">
      </div>
      <p>Кроме того, разница, конечно, заключается и во внутреннем представлении: с точки зрения программы, после ratexpand() выражение будет по-прежнему общего вида. Соответственно и все результаты дальнейших рациональных действий с выражением не будут автоматически «канонизироваться». Я специально обращаю ваше внимание на схожесть между результатами этих двух различных функций, поскольку в документации эта схожесть никак не обозначена: в описании обеих функций и примерах к ним нет вообще никаких ссылок друг на друга.</p>
<p>Помимо флага <code>ratdenomdivide</code>, есть также функция, собирающая воедино дроби с одинаковыми знаменателями; зовут ее <code>combine()</code>:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/3/maxima3-05.png" alt="">
      </div>
      <p>В дополнение к функции <code>ratexpand()</code> есть также
      флаг <code>ratexpand</code>, который по умолчанию
      равен <code>false</code>, а будучи установлен
      в <code>true</code>, приводит к тому, что все рациональные
      выражения в канонической форме отображаются и преобразовываются
      к общему виду сразу же с раскрытыми скобками:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/3/maxima3-06.png" alt="">
      </div>
      <p>Обратите внимание, что при применении этого флага выражение
      сохраняет каноническую форму.</p>
      <p>Действует в этом случае и флаг <code>ratdenomdivide</code>
      (напомню, что в строке <code>%i1</code> этот флаг был установлен
      локально, используя сокращенную запись
      функции <code>ev()</code>):</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/3/maxima3-07.png" alt="">
      </div>
      <p>Иными словами, флаг ratexpand по своему действию аналогичен
      одноименной функции, но действует он на все без исключения
      канонические рациональные выражения и при этом оставляет их в
      канонической внутренней записи и изменяет только внешнее
      отображение этой записи, сохраняя при этом и дальнейшую
      автоматическую «канонизацию».</p>
      <h2>…и не только рационально.</h2>
      <p>Помимо <code>ratexpand()</code> есть также и функция
      «просто» <code>expand()</code>. Различий между ними несколько,
      наиболее принципиальные
      таковы. Вопервых, <code>ratexpand()</code> раскрывает только
      рациональное выражение «верхнего уровня», все же подвыражения,
      не являющиеся рациональными, обрабатываются как атомарные, то
      есть внутрь них она не залезает; <code>expand()</code> же
      раскрывает скобки на всех уровнях вложенности:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/3/maxima3-08.png" alt="">
      </div>
      <p>Во-вторых, <code>ratexpand()</code> приводит дроби-слагаемые
      к общему знаменателю, а <code>expand()</code> этого не делает;
      в-третьих, на функцию expand не действует
      переключатель <code>ratdenomdivide</code>:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/3/maxima3-09.png" alt="">
      </div>
      <p>И в-четвертых, <code>expand()</code> не преобразовывает к
      рациональным числам конечную десятичную запись — опять-таки, вне
      зависимости от флага <code>keepfloat</code>.</p>
      <p>Функция <code>expand()</code>, в отличие от своего
      рационального сородича, имеет несколько вариаций — в виде
      отдельных функций с похожими названиями, которые раскрывают
      скобки несколько по-разному. Первую мы уже рассмотрели. Вторая
      называется <code>expandwrt(выражение, x, y, …, v)</code>,
      где <em>wrt</em> расшифровывается как «with respect to…», то
      есть «относительно…». Она раскрывает скобки не везде, а только
      относительно тех символов, которые заданы в списке аргументов
      после выражения. Другими словами, только там, где из скобок
      можно вынести хотя бы один из перечисленных символов:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/3/maxima3-10.png" alt="">
      </div>
      <p>(На предупреждение, возникающее при первом вызове
      функций <code>expandwrt*()</code>, можете не обращать внимания —
      на функционале, о котором идет речь, оно никоим образом не
      отражается.)</p>
      <p>Если в выражении встречаются дроби, то по умолчанию эта
      функция раскрывает скобки только в их числителях, оставляя
      знаменатели в покое. Изменить это поведение можно
      переключателем <code>expandwrt_denom</code>, установив его
      в <code>true</code> (по умолчанию он
      равен <code>false</code>):</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/3/maxima3-11.png" alt="">
      </div>
      <p>И, наконец, последняя функция из этого
      семейства — <code>expandwrt_factored(выражение, x, y, …, v)</code> —
      раскрывает скобки лишь в тех слагаемых, где упомянутые символы
      встречаются не в одном, а в каждом из сомножителей:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/3/maxima3-12.png" alt="">
      </div>
      <p>Раскрытием возведения в целую степень можно управлять как в
      контексте функции <code>expand()</code>, так и отдельно. В
      первом случае применяются переменные maxposex и maxnegex,
      определяющие соответственно максимальные положительный и
      отрицательный показатель степени, которые будут раскрываться
      этой функцией. По умолчанию оба параметра
      равны <code>1000</code>. Переназначить их можно не только
      глобально, но и в контексте одного конкретного вызова
      функции <code>expand()</code> — в таком случае это делается с
      помощью дополнительных аргументов, задаваемых после
      выражения:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/3/maxima3-13.png" alt="">
      </div>
      <p>В противовес <code>maxposex</code> и <code>maxnegex</code>
      можно задать максимальные положительную и отрицательную степени,
      которые будут раскрываться автоматически, без вызова функций
      группы <code>expand</code>. За это отвечают
      переменные <code>expop</code> и <code>expon</code>, и по
      умолчанию они равны нулю, то есть автоматически степени не
      раскрываются вообще.</p>
      <p>Кроме самостоятельной функции <code>expand()</code>,
      существуют также флаги <code>expand</code>
      и <code>expand(p, n)</code> у функции <code>ev()</code>. Запись
      выражение, <code>expand</code>
      равносильна <code>expand(ev(выражение))</code>, а
      выражение <code>expand(p, n)</code> —
      <code>expand(ev(выражение, p, n))</code>.</p>
      <p>Возможности управлять раскрытием скобок на этом не
      заканчиваются. Еще одна функция — <code>distrib()</code> —
      представляет как бы облегченный
      вариант <code>expand()</code>. Она действует
      аналогично <code>expand()</code>, но только на один уровень в
      глубину:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/3/maxima3-14.png" alt="">
      </div>
      <p>В противоположность функциям <code>*expand*()</code>,
      раскрывающим скобки, можно также и разложить выражение на
      множители, то есть максимально повыносить все за
      скобки. Делается это с помощью
      функции <code>factor()</code>:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/3/maxima3-15.png" alt="">
      </div>
      <p>Если функции <code>factor()</code> передать целое число, она
      разложит его на простые множители; если же передать рациональное
      число — на множители будут разложены его числитель и
      знаменатель:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/3/maxima3-16.png" alt="">
      </div>
<p>Если многочлен не может быть представлен в виде произведения нескольких сомножителей, его можно попытаться преобразовать в сумму таких произведений с помощью функции <code>factorsum()</code>:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/3/maxima3-17.png" alt="">
      </div>
      <p>Функция <code>factorsum()</code> умеет раскладывать на
      множители только независимые слагаемые, то есть такие, которые
      не содержат одинаковых переменных. Если мы раскроем скобки в
      выражении, содержащем в двух разных местах один и тот же символ,
      то так как коэффициенты при этом символе после раскрытия
      сгруппируются, <code>factorsum()</code> не сможет понять, каким
      именно образом разгруппировать их обратно:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/3/maxima3-18.png" alt="">
      </div>
      <p>Нужно заметить, что функции <code>factor()</code>
      и <code>factorsum()</code>, хотя и не имеют в имени
      приставки <code>rat</code>, все же ведут себя в смысле разбора
      передаваемых им выражений не как <code>expand()</code> и
      сопутствующие, а как <code>ratexpend()</code>; то есть на любой
      не-рациональной функции останавливаются и внутрь не идут:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/3/maxima3-19.png" alt="">
      </div>
      <p>Впрочем, об этом можно догадаться из документации, так как
      функции <code>factor*</code> описаны не в разделе
      «Simplification», куда относятся <code>expand*</code>, а, так
      же, как и <code>rat*</code>, в разделе «Polynomials».</p>
      <p>Выносить за скобки, а также раскрывать эти скобки можно не
      только специальной функцией, но и дополнительным флагом ко все
      той же канонической форме рациональных выражений. Флаг этот
      зовут <code>ratfac</code>, и по умолчанию он
      равен <code>false</code>, то есть вынесение за скобки не
      происходит. Если же его установить в true, то в каждом
      рациональном выражении, приведенном к канонической форме, все
      будет максимально вынесено за скобки, но без вызова
      функции <code>factor()</code>; например, в примере ниже не
      произошло обратного свертывания <code>(x+1)2</code>, хотя,
      будучи применен к первоначальному выражению,
      флаг <code>ratfa</code>c сохранил и этот множитель нераскрытым
      (также можете сравнить этот пример с аналогичным примером к
      функциям <code>ratexpand()</code> и <code>rat()</code>):</p>
      <div class="well" style="background: #fff;">
        <img src="i/tarnavsky/3/maxima3-20.png" alt="">
      </div>
      <h2>Проще простого</h2>
      <p>Итак, о преобразованиях выражений мы уже поговорили
      достаточно — теперь перейдем к их упрощению. Об элементарных
      упрощениях мы уже говорили в предыдущий раз: они могут
      производиться автоматически, на что влияет установленный
      флаг <code>simp</code>; и по умолчанию именно так и
      происходит.</p> 
      <p>Здесь тоже все начинается с рациональных выражений, которыми
      занимается функция <code>ratsimp(выражение)</code>. Она упрощает
      выражение за счет рациональных преобразований, но, в отличие от
      остальных функций по обработке рациональных выражений, работает
      в том числе и «вглубь», то есть иррациональные части выражения
      не рассматриваются как атомарные, а упрощаются, в том числе, и
      все рациональные элементы внутри них:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/3/maxima3-21.png" alt="">
      </div>
      <p>На <code>ratsimp()</code> действуют те же флаги, что и
      на <code>rat()</code>: и <code>ratexpand</code>,
      и <code>keepfloat</code>, и <code>ratfac</code>. Но отличается
      она от <code>rat()</code> или <code>ratexpand()</code> не только
      умением работать «в глубину», но и некоторыми дополнительными
      рациональными преобразованиями, которые не поддерживаются этими
      двумя функциями:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/3/maxima3-23.png" alt="">
      </div>
      <p>Кроме функции <code>ratsimp()</code>, есть еще и
      дополнительный переключатель — <code>ratsimpexpons</code>. По
      умолчанию он установлен в <code>false</code>; если же назначить
      ему значение <code>true</code> — это приведет к автоматическому
      упрощению показателей степени:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/3/maxima3-24.png" alt="">
      </div>
      <p>Функция <code>ratsimp()</code> — это уже достаточно мощный, и
      в то же время весьма быстрый, механизм упрощения; но, конечно,
      не достаточный: ведь те действия, которые можно упростить в
      разнообразных математических выражениях, не ограничиваются
      рациональными. Поэтому все же основной плюс этой функции — это
      скорость. А для более серьезных упрощений существует расширенный
      вариант — <code>fullratsimp(выражение)</code>. Эта функция
      последовательно применяет к переданному выражению
      функцию <code>ratsimp()</code>, а также некоторые нерациональные
      преобразования — и повторяет эти действия в цикле до тех пор,
      пока выражение не перестанет в процессе них изменяться. За счет
      этого функция работает несколько медленнее,
      чем <code>ratsimp()</code>, зато дает более надежный результат —
      к некоторым выражениям, которые она может упростить с
      ходу, <code>ratsimp()</code> пришлось бы применять несколько
      раз, а иногда та и вообще не справилась бы с задачей.</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/3/maxima3-25.png" alt="">
      </div>
      <p>И третья основная функция упрощения выражений — уже никак с
      предыдущими двумя не
      соотносящаяся — <code>radcan(выражение)</code>. Если <code>ratsimp()</code>
      и <code>fullratsimp()</code> ориентированы на упрощение
      рациональных действий, то <code>radcan()</code> занимается
      упрощением логарифмических, экспоненциальных функций и степенных
      с нецелыми рациональными показателями, то есть корней
      (радикалов). Например, выражение из второго примера в этом
      разделе <code>radcan()</code> сможет упростить сильнее,
      чем <code>ratsimp()/fullratsimp()</code>:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/3/maxima3-26.png" alt="">
      </div>
      <p>В некоторых случаях наилучшего результата можно добиться,
      комбинируя <code>radcan()</code> с <code>ratsimp()</code>
      или <code>fullratsimp()</code>.</p>
      <p>С функцией <code>radcan()</code> смежны по действию еще два
      управляющих ключа. Один из них
      называется <code>%e_to_numlog</code>. Влияет он не на саму
      функцию, а на автоматическое упрощение. Если выставить его
      в <code>true</code>, то выражения
      вида <code>e(r*log(выражение))</code>, где <code>r</code> —
      рациональное число, будут автоматически раскрываться в
      выражение <code>r</code>. Функция <code>radcan()</code> делает
      такие преобразования независимо от значения ключа. Второй
      ключ — <code>radexpand</code> (от <em>radical</em>, не путать
      с <code>ratexpand</code>) — влияет на упрощение квадратного
      корня из четной степени какого-либо выражения. Он, в отличие от
      большинства переключателей, имеет не два, а три значения: при
      значении <code>all</code>, <code>sqrt(x2)</code> будет
      раскрываться в <code>x</code> — как для действительных, так и
      для комплексных чисел; при значении <code>true</code> (по
      умолчанию), <code>sqrt(x2)</code> для действительных чисел
      превращается в <code>|x|</code>, а для комплексных не
      преобразуется; а при
      значении <code>false</code>, <code>sqrt(x2)</code> не будет
      упрощаться вообще.</p>
      <p>Следующие две функции и один флаг относятся к упрощению
      факториалов. Функция <code>factcomb(выражение)</code> проводит
      упрощения вида <code>n!*(n+1) = (n+1)!</code> и тому
      подобные. Функция <code>minfactorial</code>, напротив, сокращает
      факториалы, то есть действует по
      принципу <code>n!/(n–1)! = n</code>. И
      флаг <code>sumsplitfact</code>, который изначально установлен
      в <code>true</code>, находясь в состоянии <code>false</code>,
      приводит к тому, что после того, как
      отработает <code>factcomb</code>, <code>minfactorial</code>
      вызывается автоматически.</p>
      <h2>Вот под таким углом…</h2>
      <p>И напоследок поговорим о функциях для преобразования
      тригонометрических формул. Здесь так же, как и у рациональных
      функций, присутствует общая для всех
      приставка — <code>trig</code>; расшифровывать ее, думаю, особой
      нужды нет. Начнем по традиции с
      функции <code>trigexpand(выражение)</code>. Она, как нетрудно
      догадаться, раскрывает скобки в тригонометрических
      выражениях:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/3/maxima3-27.png" alt="">
      </div>
      <p>Здесь, как обычно, есть несколько управляющих флагов, первый
      из которых опять же является тезкой самой функции. Он приводит к
      повторному раскрытию всех синусов-косинусов, то есть фактически
      равнозначен повторному вызову самой функции:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/3/maxima3-28.png" alt="">
      </div>
      <p>Второй флаг — <code>halfangles</code> — управляет раскрытием
      формул половинных углов. Оба эти флага по умолчанию сброшены. А
      следующие два флага — <code>trigexpandplus</code>
      и <code>trigexpandtimes</code> — отвечают соответственно за
      применение формул сумм углов и кратных углов. То есть в примере
      выше сначала сработал флаг <code>trigexpandplus</code>, а
      затем — <code>trigexpandtimes</code>. Эти флаги по умолчанию
      установлены, что и видно из примера.</p>
      <p>Кроме всего уже упомянутого, есть еще
      флаги <code>trigsign</code> и <code>triginverses</code>. Первый
      принимает традиционные два значения (по
      умолчанию — <code>true</code>) и регулирует вынос знака за
      пределы тригонометрической функции, то есть, к
      примеру, <code>sin(–x)</code> упростится
      до <code>–sin(x)</code>, а <code>cos(–x)</code> —
      до <code>cos(x)</code>. Флаг <code>triginverses</code> —
      трехзначный, и умолчательное его значение
      равно <code>all</code>. Он отвечает за обработку сочетаний
      вида <code>sin(asin(x))</code>
      или <code>atan(tan(x))</code>. Значение <code>all</code>
      позволяет раскрывать эти сочетания в обоих направлениях
      (напомню, что при этом часть корней будет теряться);
      значение <code>true</code> оставляет разрешенным раскрытие
      только вида <code>sin(asin(x))</code>, то есть блокирует вариант
      с потерями периодических значений; а случай <code>false</code>
      запрещает оба направления преобразований.</p>
      <p>Функция, обратная <code>trigexpand()</code>,
      называется <code>trigreduce(выражение)</code> — здесь, в полном
      соответствии со значением слова <code>reduce</code>, действуют
      формулы понижения степени. Например, применив дважды эту функцию
      к результату предыдущего примера, мы получим его в исходном
      виде.</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/3/maxima3-29.png" alt="">
      </div>
      <p>Эту функцию можно вызвать с более полным списком
      аргументов: <code>trigreduce(выражение, переменная)</code> —
      тогда формулы понижения степени будут применяться только по
      отношению к заданной переменной (переменная может быть, как и
      почти везде, не только отдельным символом, но и выражением).</p>
      <p>Третья функция занимается уже упрощением, и зовут ее,
      соответственно, trigsimp(выражение). Она старается упростить
      любое тригонометрическое выражение, используя известные формулы,
      такие как
      sin<sup>2</sup>(<var>x</var>) + cos<sup>2</sup>(<var>x</var>) = 1
      и тому подобные. Для наилучшего результата ее можно комбинировать
      с <code>trigreduce()</code>, <code>ratsimp()/fullratsimp()</code>
      и <code>radcan()</code>.</p>
      <p>Этим возможности Maxima по преобразованию и упрощению
      разнообразных выражений еще не совсем исчерпаны, но основные из
      них мы рассмотрели в полной мере. В следующий раз поговорим
      немного о применении некоторых встроенных функций, о работе с
      векторами, матрицами и множествами и, возможно, о работе с
      логикой, с уравнениями и неравенствами, а также их
      системами.</p>
    </div>
    <!-- End content column -->
    <!-- Begin info and menu column -->
    <div class="col-sm-3 col-md-4 hidden-print">
      <!-- Begin menu list -->
      <ul class="nav nav-pills nav-stacked">
        <li><a href="./index.html">главная страница</a></li>
        <li class="dropdown active"><a class="dropdown-toggle"
        data-toggle="dropdown" href="./documentation.html">Документация
        <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li><a href="./documentation.html">Maxima Руководства</a></li>
          <li><a href="../faq.html">часто задаваемые вопросы</a></li>
          <li><a href="../compalg.html">Компьютерная алгебра</a></li>
          <li><a href="../lisp.html">Ссылки по Lisp</a></li>
        </ul>
        </li>
        <li class="dropdown"><a class="dropdown-toggle"
        data-toggle="dropdown" href="../project.html">проект
        <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li><a href="../project.html">проект Maxima</a></li>
          <li><a href="../3rdpartycode.html">Дополнительные пакеты</a></li>
          <li><a href="../relatedprojects.html">Связанные проекты</a></li>
        </ul>
        </li>
        <li><a href="../download.html">Загрузка</a></li>
        <li><a href="../maximalist.html">Списки рассылки</a></li>
      </ul>
      <!-- End menu list -->
    </div>
    <!-- End info and menu column -->
  </div>
  <!-- End content row -->
</div>
<!-- End page -->
<br>
<!-- Begin project info -->
<footer role="contentinfo">
  <div class="container-fluid">
    <div class="row">
      <div class="col-sm-9 col-md-8 text-center">
        <p>Вопросы о Maxima или этого сайта: <a href="../maximalist.html">Списки
        рассылки</a></p>
        <p><a href="http://sourceforge.net/projects/maxima" >организовано
        Sourceforge</a></p>
      </div>
    </div>
  </div>
</footer>
<!-- End project info -->
<!-- Scripts section -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<script src="../js/bootstrap.min.js"></script>
<script type="text/javascript">
function ChangeLanguage() {
 var selectbox = document.changelang.elements["page"];
 var selectedIndex = selectbox.selectedIndex;
 var page = selectbox.options[selectedIndex].value;
 selectbox.options[0].selected = true;
 location.href = page;}
</script>
</body>
</html>
