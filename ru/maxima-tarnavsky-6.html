<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="HandheldFriendly" content="true">
<meta name="copyright" content="© 2002–2015 Maxima CAS development team.">
<meta name="keywords" content="Maxima, CAS, computer algebra, mathematics, Lisp, symbolic computation, MACSYMA, GPL, free, ODE, plotting, система компьютерной алгебры, компьютерная алгебра, математика, символьные вычисления, свободно">
<title>Maxima - Руководства</title>
<!-- This site uses Bootstrap http://getbootstrap.com -->
<link rel="stylesheet" href="../css/bootstrap.min.css">
<link rel="shortcut icon" href="../i/favicon.ico" media="all">
<style type="text/css">
.mx-content {background:#f2f2f2;color:#333;padding: 0 1.5em 1.5em 1.5em;}
</style>
</head>
<body style="padding-top:50px;" id="top">
<a class="sr-only sr-only-focusable" href="#content">Перейти к основному содержанию</a>
<!-- Begin navigation bar -->
<header class="navbar navbar-inverse navbar-fixed-top" role="banner">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>                        
      </button>
      <a href="./index.html" class="navbar-brand" title="Перейти на
      главную страницу" style="padding: 0 0.75rem 0 1.5rem"><img
      src="../i/logo.png" width="56" height="56" alt="Maxima"></a>
    </div>
    <nav class="collapse navbar-collapse" id="myNavbar">
      <ul class="nav navbar-nav">
        <li><a href="../download.html">Загрузка</a></li>
        <li><a href="./documentation.html">Документация</a></li>
        <li><a href="../project.html" >проект</a></li>
        <li><a href="#top" >верх страницы</a></li>
      </ul>
    </nav>
  </div>
</header>
<!-- End navigation bar -->
<!-- Begin page -->
<div class="container-fluid">
  <!-- Begin content row -->
  <div class="row">
    <!-- Begin content column -->
    <div class="col-sm-9 col-md-8 mx-content" id="content">
      <h1>Тихон Тарнавский. Maxima. Работа c файлами и фактами</h1>
      <p>Впервые было опубликовано в
      «<a href="http://www.linuxformat.ru/">Linux
      Format</a>» <a href="http://www.linuxformat.ru/download/86.pdf">№12 (86),
      декабрь 2006 г</a>.</p>
      <p>В прошлый раз мы остановились на возможностях
      программирования, предназначенных для написания собственных
      функций и модулей к Maxima — и теперь для их полноценного
      использования рассмотрим несколько инструментов работы с
      файлами, позволяющих сохранять и загружать эти функции и модули
      на диск и с диска. Далее речь пойдет о наложении определенных
      условий на неизвестные и значения функций. Напоследок
      познакомимся с функциями по работе… с функциями: это один из
      очень мощных инструментов, позаимствованных из функционального
      программирования; а также разберем несколько более крупных
      учебных примеров, использующих многое из изученного нами во всех
      статьях цикла.</p>
      <h2>Учимся читать и писать</h2>
      <p>Среди средств для операций с файлами функции с наиболее
      очевидными именами — save и load — имеют, вопреки привычной для
      Maxima логичности всех названий, различный контекст. Первая
      предназначена для выгрузки Maxima-выражений в виде исходных
      кодов на Lisp, так что если вы не знаток Lisp (да и реализации
      внутренних механизмов Maxima), то эта функция представляет лишь
      чисто академический интерес. Посему подробнее мы займемся
      другими функциями — для обработки так называемых пакетных
      (batch) файлов, хранящих выражения уже в синтаксисе самой
      Maxima. А поскольку в виде таких файлов поставляется немалое
      количество функционала Maxima, то начнем с загрузки. И вот о
      второй из очевидно-именуемых функций здесь уже будет
      рассказано.</p>
      <p>Функции чтения файлов с выражениями Maxima существует
      три: <code>demo(<var>имя-файла</var>)</code>, <code>batch(<var>имя-файла</var>)</code>
      и <code>batchload(<var>имя-файла</var>)</code>. Первая
      предназначена для загрузки так называемых демо-файлов,
      задуманных, как и явствует из названия, для демонстрационных
      примеров. Она загружает демо-файл и выполняет его в пошаговом
      режиме, ожидая нажатия <code>Enter</code> после выполнения
      каждой строки. В составе Maxima поставляется значительное
      количество демо-файлов; упоминания о них можно найти в
      документации, а сами файлы несложно обнаружить среди содержимого
      пакета <code>maxima-share</code> (либо, в случае отсутствия
      такового в вашем дистрибутиве, просто <code>maxima</code>) по их
      расширению — <code>.dem</code>.</p>
      <p>Функция <code>batch()</code> загружает Maxima-файл с
      расширением <code>.mac</code> или <code>.mc</code> (от
      первоначального названия программы — Macsyma) и выполняет
      содержащиеся в нем выражения так, как если бы они вводились
      прямо в текущей сессии, то есть с отображением результата
      каждого выражения и назначением
      меток <code>%iN</code>, <code>%oN</code>. Функция <code>batchload()</code>,
      напротив, подгружает пакетный файл «молча»: все назначенные в
      нем функции и переменные становятся доступны, но результаты не
      видны, и весь хранимый ввод-вывод, включая значения
      символов <code>%</code> и <code>_</code> и результаты,
      возвращаемые функцией <code>%th()</code>, остается тем же, что и
      до вызова.</p>
      <p>Функции <code>batch()</code> и <code>batchload()</code>
      используют при поиске файлов для загрузки путь (точнее сказать,
      шаблон, потому как в нем содержатся не только имена каталогов,
      но и допустимые расширения файлов), который хранится в
      переменной <code>file_search_maxima</code>. По умолчанию эта
      переменная содержит все каталоги, в которые
      устанавливаются <code>.mac</code>-файлы из пакетов Maxima, а
      также <code>~/.maxima</code>, предназначенный для
      пользовательских файлов. Для других функций загрузки существуют
      отдельные переменные: <code>file_search_lisp</code>
      и <code>file_search_demo</code>, смысл которых понятен из их
      названий.</p>
      <p>Ну и под конец здесь нужно вспомнить о вышеназванной функции
      load. Она, фактически, является оберткой над двумя функциями:
      уже описанной выше <code>batchload()</code>
      и <code>loadfile()</code>, вторая, совершенно аналогично первой,
      загружает файл, но уже не с выражениями Maxima, а с исходным
      кодом Lisp, то есть является парной к
      функции <code>save()</code>. Функцию <code>load()</code> можно,
      в принципе, использовать вместо <code>batchload()</code>:
      путь <code>file_search_maxima</code> задан в ней раньше,
      чем <code>file_search_lisp</code>, так что в случае
      неоднозначности она будет загружать файлы Maxima; а кроме того,
      так короче.</p>
      <p>Некоторый функционал Maxima содержится в неподгружаемых
      автоматически внешних файлах, которые, соответственно, нужно
      принудительно загрузить перед использованием:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/6/maxima6-01.png" alt="">
      </div>
      <p>Помимо ручной загрузки нужного файла, можно также настроить
      Maxima на автоматическую подгрузку в случае вызова заданной
      функции. Делается это так:
      <code>setup_autoload(<var>имя-файла</var>, <var>имена-функций</var>)</code>;
      нужные функции здесь перечисляются через запятую прямо после
      имени файла. Удобнее, конечно, будет не вызывать
      функцию <code>setup_autoload()</code> вручную (так в ней и толку
      немного), а настроить Maxima на автоматический ее запуск при
      старте программы. Файл, который, при его наличии, вызывается при
      каждом запуске Maxima, называется <code>maxima-init.mac</code> и
      самое логичное для него местоположение — все тот же
      каталог <code>~/.maxima</code>. Конечно, он может содержать не
      только вызовы функции <code>setup_autoload()</code>, а любые
      выражения Maxima, которые вы хотите выполнять при каждом ее
      запуске. Использование этой функции может сделать вашу работу с
      Maxima намного более удобной в том случае, если вы часто
      используете некоторые из внешних функций Maxima или функции,
      вами же и написанные.</p>
      <p>Для полноценного чтения файлов всего сказанного уже вполне
      достаточно, теперь перейдем к записи в них. Тут нас в первую
      очередь интересует функция <code>stringout()</code>, которая
      позволяет выгружать в файл любые выражения и функции Maxima в
      точно таком виде, в каком их загружают
      функции <code>demo()</code>, <code>batch()</code>
      и <code>batchload()</code>. С ее помощью можно писать выражения,
      которые вы хотите иметь во внешнем модуле, находясь
      непосредственно в интерфейсе Maxima, с последующей записью в
      этот самый модуль. Для выгрузки функций в один из стандартных
      каталогов Maxima (самым логичным вариантом будет, пожалуй,
      упомянутый выше <code>~/.maxima</code>) имя файла во всех
      вариантах вызова функции <code>stringout()</code> нужно задавать
      с полным путем; в случае задания имени без пути файл будет
      создан в текущем каталоге, то есть в том, откуда производился
      запуск Maxima.</p>
      <p>Здесь, чтобы было интереснее и не приходилось писать в файлы
      всякую ерунду, немного прервемся и создадим пару небольших
      функций.</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/6/maxima6-02.png">
      </div>
      <p>Эта функция возвращает список всех простых чисел, меньших чем
      заданное целое число. Сначала мы проверяем, является ли аргумент
      целым числом и делаем это простейшим образом: в случае
      невыполнения условия оператор <code>if</code>, напомню,
      вернет <code>false</code>. Генерируется список тоже самым
      простым и коротким в реализации способом —
      рекурсией. (примечание для людей, далеких от программирования:
      рекурсивная функция — это функция, вызывающая саму себя; чаще
      всего такие функции строятся по принципу индукции). Здесь
      используется функция Maxima по имени <code>prev_prime()</code>,
      которая возвращает простое число, предшествующее заданному
      целому.</p>
      <p>У рекурсии, при всей ее простоте реализации, есть неоспоримый
      минус — только один, но весьма существенный: чрезвычайная
      требовательность к объему памяти. Поэтому, для обеспечения
      возможности получать последовательности из больших простых
      чисел, добавим в наш учебный пример еще одну функцию:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/6/maxima6-03.png" alt="">
      </div>
      <p>Смысл, думаю, понятен по аналогии с предыдущей: теперь мы еще
      и ограничили возвращаемый список снизу.</p>
      <p>Теперь, когда у нас уже есть <code>primesbetween()</code>,
      первую функцию можно написать по «принципу чайника» — сведя
      задачу к предыдущей:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/6/maxima6-04.png" alt="">
      </div>
      <p>Теперь вернемся к <code>stringout()</code>. Эта функция, как
      и многие другие, может принимать несколько различных вариантов
      аргументов, первым из которых всегда выступает имя файла для
      записи, а остальные отвечают за то, что же именно будет туда
      записано. В варианте
      <code>stringout(<var>имя-файла</var>, [<var>начало</var>, <var>конец</var>])</code>
      записаны будут ячейки ввода с номерами от «начала» до «конца»
      включительно:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/6/maxima6-05.png" alt="">
      </div>
      <pre>$ cat .maxima/primes.mac
primes(n):=if integerp(n) then (if n &lt;= 2 then [] else
append(primes(prev_prime(n)),[prev_prime(n)]));
primesbetween(n,m):=if integerp(n) and integerp(m) then
(if m &lt;= 2 or prev_prime(m) &lt;= n then [] else
append(primesbetween(n,prev_prime(m)),[prev_prime(m)]));</pre>
      <p>Как видите, по умолчанию вывод получается не слишком
      красивым, поэтому сразу рассмотрим один ключ, влияющий на его
      формат. Долго рассказывать о нем смысла нет, лучше показать на
      примере:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/6/maxima6-06.png" alt="">
      </div>
      <pre>$ cat .maxima/primes.mac
primes(x):=if integerp(x)
      then (if x &lt;= 2 then []
              else append(primes(prev_prime(x)),[prev_prime(x)]));
primesbetween(n,m):=if integerp(n) and integerp(m)
            then (if m &lt;= 2 or prev_prime(m) &lt;= n then []
                    else append(primesbetween(n,prev_prime(m)),
                            [prev_prime(m)]));</pre>
      <p>Представления о правилах отступов у создателей этой опции
      несколько специфичные, но тем не менее, результат стал намного
      читабельнее. Так что, если вы планируете сохранять выражения
      Maxima не только для того, чтобы потом загружать их обратно, а
      желаете редактировать созданные файлы, я рекомендую вам
      прописать <code>grind:true</code> глобально в
      файле <code>~/.maxima/maxima-init.mac</code>.</p>
      <p>Идем дальше. С помощью ключевого слова <code>input</code>
      можно выгрузить в файл все ячейки ввода разом:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/6/maxima6-07.png" alt="">
      </div>
      <pre>$ cat primes-sample.mac
primes(n):=if integerp(n)
      then (if n &lt;= 2 then []
              else append(primes(prev_prime(n)),[prev_prime(n)]));
primesbetween(n,m):=if integerp(n) and integerp(m)
            then (if m &lt;= 2 or prev_prime(m) &lt;= n then []
                    else append(primesbetween(n,prev_prime(m)),
                            [prev_prime(m)]));
primes1(n):=primesbetween(1,n);
stringout(".maxima/primes.mac",[1,2]);
grind:true;
stringout(".maxima/primes.mac",[1,2]);
(N:[random(100000)],for i thru 9 do N:append(N,[N[i]+random(100000)]),N);
(P:[],for i thru 10 do P:append(P,primesbetween(N[i]-50,N[i])),P);</pre>
      <p>Кроме <code>input</code>, есть еще два ключевых
      слова: <code>functions</code> и <code>values</code>. Первое
      позволяет записать определения всех функций, второе — присвоение
      всем символам выражений их текущих значений:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/6/maxima6-08.png" alt="">
      </div>
      <pre>$ cat .maxima/primes.mac
primes(n):=if integerp(n)
      then (if n &lt;= 2 then []
               else append(primes(prev_prime(n)),[prev_prime(n)]));
primesbetween(n,m):=if integerp(n) and integerp(m)
             then (if m &lt;= 2 or prev_prime(m) &lt;= n then []
                     else append(primesbetween(n,prev_prime(m)),
                             [prev_prime(m)]));
primes1(n):=primesbetween(1,n);
$ cat primes-sample.mac
primes(n):=if integerp(n)
      then (if n &lt;= 2 then []
               else append(primes(prev_prime(n)),[prev_prime(n)]));
primesbetween(n,m):=if integerp(n) and integerp(m)
             then (if m &lt;= 2 or prev_prime(m) &lt;= n then []
                     else append(primesbetween(n,prev_prime(m)),
                             [prev_prime(m)]));
primes1(n):=primesbetween(1,n);
N:[49900,61971,153219,244360,290427,347723,396481,465378,522906,568462];
P:[49853,49871,49877,49891,61927,61933,61949,61961,61967,153191,244313,244333,
  244339,244351,244357,290383,290393,290399,290419,347707,347717,396437,
  396443,396449,396479,465331,465337,465373,522857,522871,522881,522883,
  522887,568433,568439,568441,568453];</pre>
      <p>И кроме всего этого, функцию <code>stringout()</code> можно
      вызвать с непосредственным перечислением в аргументах конкретных
      выражений. В этом случае, надо заметить, будут сохраняться не
      ячейки, содержащие заданные выражения, а именно сами
      выражения. То есть, если перечислить символ, для которого задано
      значение, то в файл будет записано только это значение. С
      именами функций, заданными непосредственно, дело обстоит не
      лучше: функцию таким образом задать, по сути, вообще нельзя:
      если просто написать ее имя, то вместо функции будет подставлен
      одноименный символ (или его значение, если оно задано). Но из
      обеих ситуаций есть выход. Для функций — штатный:
      функция <code>fundef</code>, которая принимает имя любой
      пользовательской функции и возвращает ее определение в точности
      в таком же виде, в каком оно было введено (или могло бы быть
      введено) в «командной строке» Maxima, с точностью до
      пробелов:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/6/maxima6-09.png" alt="">
      </div>
      <pre>$ cat .maxima/primesbetween.mac
primesbetween(n,m):=if integerp(n) and integerp(m)
           then (if m &lt;= 2 or prev_prime(m) &lt;= n then []
                   else append(primesbetween(n,prev_prime(m)),
                           [prev_prime(m)]));
$ cat .maxima/primes1.mac
primes(n):=if integerp(n)
      then (if n &lt;= 2 then []
              else append(primes(prev_prime(n)),[prev_prime(n)]));
primes1(n):=primesbetween(1,n);</pre>
      <p>А для символов можно использовать небольшую хитрость:
      блокировать вычисление переданного выражения, а в нем написать
      сначала сам символ, а потом через двоеточие — его же, предварив
      знаком принудительного вычисления (два апострофа):</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/6/maxima6-10.png" alt="">
      </div>
      <pre>$ cat random-primes.mac
P:[49853,49871,49877,49891,61927,61933,61949,61961,61967,153191,244313,244333,
  244339,244351,244357,290383,290393,290399,290419,347707,347717,396437,
  396443,396449,396479,465331,465337,465373,522857,522871,522881,522883,
  522887,568433,568439,568441,568453];</pre>
      <p>В довершение темы работы с файлами стоит обратить внимание
      еще на один момент: при загрузке файлы в текущем каталоге не
      ищутся — и как раз для него надо задавать путь, причем полный, а
      не через <code>./<var>имя-файла</var></code>:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/6/maxima6-11.png" alt="">
      </div>
      <h2>«Прослушайте объявление»</h2>
      <p>Теперь поговорим о функциях, позволяющих налагать
      определенные условия на выражения, которыми оперирует
      Maxima. Таких функций существует две, и достаточно
      разноплановых; но определенная связь между ними есть, так как
      все условия, заданные ими на данный момент, хранятся в общей
      «базе». Первая из этих функций называется <code>declare</code>
      (<em>объявлять</em>). С ее помощью можно объявлять весьма
      разнообразные факты о произвольных символах или выражениях;
      синтаксис ее весьма прост:
      <code>declare(<var>имя</var>, <var>факт</var>)</code> или
      <code>declare(<var>имя<sub>1</sub></var>, <var>факт<sub>1</sub></var>, <var>имя<sub>2</sub></var>, <var>факт<sub>2</sub></var>, …)</code>;
      факты задаются с помощью ключевых слов. Сами факты я бы разделил
      на три группы: «технические» факты Maxima, позволяющие
      использовать наделенный ими символ некоторым специальным образом
      при вводе выражений; факты о символах (атомарных выражениях); и
      факты о значениях функций. К первым относятся, к примеру,
      свойства <code>evflag</code> и <code>evfun</code>, о которых шла
      речь в описании функции <code>ev</code>; некоторые штатные
      функции обладают ими по умолчанию, а с помощью
      функции <code>declare</code> мы можем присвоить эти свойства
      любым другим, в том числе и пользовательским, функциям. Вторая
      группа фактов несет информацию о неизвестных; например, мы можем
      указать, что некоторая неизвестная является константой, или что
      ее значение — целое. И третья группа — примерно то же самое, но
      о функциях; примеры: четная функция
      (<var>f</var>(−<var>x</var>) = <var>f</var>(<var>x</var>)),
      аддитивная
      (<var>f</var>(<var>x</var> + <var>y</var>) = <var>f</var>(<var>x</var>) + <var>f</var>(<var>y</var>))
      или целочисленная. Для краткости просто перечислим наиболее
      интересные из возможных фактов, сгруппировав соответственно трем
      упомянутым группам.</p>
      <h3>Технические факты</h3>
      <h4><code>evfun</code></h4>
      <p>Позволяет применять функцию или переменную как опцию, то есть
      «<code><var>выражение</var>, <var>имя-функции</var></code>»
      вместо
      «<code><var>имя-функции</var>(<var>выражение</var>)</code>» или
      «<code><var>выражение</var>, <var>имя-переменной</var></code>»
      вместо
      «<code><var>имя-переменной</var>:true; <var>выражение</var></code>».
      Подробнее см. «<a href="maxima-tarnavsky-2.html">Maxima. Функции и
      операторы</a>».</p>
      <h4><code>bindtest</code></h4>
      <p>Запрещает использовать символ в выражениях до присвоения ему
      значения. При таком использовании Maxima выдаст ошибку. Пример
      см. в документации.</p>
      <h4><code>feature</code></h4>
      <p>Делает заданное имя именем свойства (факта), что дает
      возможность использовать его точно так же, как все перечисленные
      здесь имена.</p>
      <h3>Факты о символах</h3>
      <h4><code>constant</code></h4>
      <p>Имя трактуется как константа.</p>
      <h4><code>scalar</code></h4>
      <p>Имя трактуется как скалярная величина. На это также влияет
      флаг <code>assumescalar</code>: если он равен <code>true</code>,
      то все неопределенные символы воспринимаются как скаляры. Тут
      есть небольшая коллизия: если верить документации, то по
      умолчанию <code>assumescalar</code> равен <code>false</code>,
      реально же в Maxima 5.10.0 он равен <code>true</code>.</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/6/maxima6-12.png" alt="">
      </div>
      <h4><code>nonscalar</code></h4>
      <p>Имя трактуется как не-скалярная величина, то есть матрица или
      вектор.</p>
      <h4><code>integer</code>, <code>noninteger</code></h4>
      <p>Целое и нецелое число.</p>
      <h4><code>even</code>, <code>odd</code></h4>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/6/maxima6-13.png" alt="">
      </div>
      <p>Четное и нечетное целое число.</p>
      <h3>Факты о функциях</h3>
      <h4><code>rassociative</code></h4>
      <p>Объявляет функцию как «ассоциативную» по правому аргументу.</p>
      <h4><code>lassociative</code></h4>
      <p>Аналогично — по левому аргументу.</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/6/maxima6-14.png" alt="">
      </div>
      <h4><code>nary</code></h4>
      <p>Объявляет «<var>n</var>-арную» функцию. Это и два предыдущих
      названия не совсем точны: <var>n</var>-арной правильно называть
      функцию от <var>n</var> аргументов, а лево- и
      правоассоциативной — функции именно с односторонней
      ассоциативностью, то есть, для
      «лево-» <var>f</var>(<var>f</var>(<var>a</var>,<var>b</var>),<var>c</var>) ≠ <var>f</var>(<var>a</var>,<var>b</var>,<var>c</var>) ≠ <var>f</var>(<var>a</var>,<var>f</var>(<var>b</var>,<var>c</var>)). А
      в Maxima все три факта объявляют на самом деле
      полно-ассоциативную функцию от произвольного числа аргументов, а
      различаются только тем, как будут расставлены скобки по
      умолчанию.</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/6/maxima6-15.png" alt="">
      </div>
      <h4><code>symmetric</code>/<code>commutative</code></h4>
      <p>Оба ключевых слова объявляют функцию как симметричную
      (коммутативную).</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/6/maxima6-16.png" alt="">
      </div>
      <h4><code>antisymmetric</code></h4>
      <p>Объявляет функцию как антисимметричную.</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/6/maxima6-17.png" alt="">
      </div>
      <h4><code>outative</code></h4>
      <p>Константа выносится за знак функции.</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/6/maxima6-18.png" alt="">
      </div>
      <p>Многие из фактов, которые можно устанавливать с помощью
      функции <code>declare</code>, сохраняются в «базе данных»
      фактов. Узнать текущее состояние этой базы можно с помощью
      функции <code>facts()</code>. Ее можно вызывать, либо передав в
      качестве единственного аргумента имя, список фактов по которому
      мы хотим получить, либо вообще без аргументов — тогда будут
      выданы все известные факты обо всех пользовательских
      именах. Удалить свойства позволяет
      функция <code>remove()</code>. Она, как и многие другие, имеет
      несколько вариантов вызова. Будучи вызвана
      как <code>remove(<var>имя</var>, <var>свойство</var>)</code>
      или <code>remove(<var>имя<sub>1</sub></var>, <var>свойство<sub>1</sub></var>, <var>имя<sub>2</sub></var>, <var>свойство<sub>2</sub></var>, …)</code>,
      она лишает каждое переданное имя одного соответствующего ему
      свойства. Можно также передавать ей списки имен и свойств:
      <code>remove([<var>имя<sub>1</sub></var>, <var>имя<sub>2</sub></var>, …],
      [<var>свойство<sub>1</sub></var>, <var>свойство<sub>2</sub></var>, …])</code>;
      тогда каждое имя из списка будет лишено всех перечисленных
      свойств. Пар списков тоже может быть более
      одной: <code>remove(<var>список-имен<sub>1</sub></var>, <var>список-свойств<sub>1</sub></var>, <var>список-имен<sub>2</sub></var>, <var>список-свойств<sub>2</sub></var>, …)</code> —
      этот вызов аналогичен последовательным
      <code>remove(<var>список-имен<sub>1</sub></var>, <var>список-свойств<sub>1</sub></var>);
      remove(<var>список-имен<sub>2</sub></var>, <var>список-свойств<sub>2</sub></var>);…</code>
      И последний интересующий нас вариант —
      <code>remove(all, <var>свойство</var>)</code> удаляет «свойство»
      со всех имен, у которых оно есть.</p>
      <p>Вторая «условная» функция — это функция <code>assume()</code>
      (допускать, принимать). Здесь все проще: в качестве аргументов
      ей можно передавать в любом количестве самые обыкновенные
      равенства и неравенства. Напомню только, что задавать их нужно
      не в синтаксической, а в логической форме, то есть не
      «<code>a=b</code>», «<code>a#b</code>», а
      «<code>equal(a,b)</code>», «<code>not equal(a,b)</code>». Из
      логических операторов допускается также
      использование <code>and</code> (по
      сути <code>assume(x&gt;0 and x&lt;1)</code> это то же самое, что
      и <code>assume(x&gt;0, x&lt;1)</code>), но не <code>or</code> —
      база фактов не поддерживает информацию вида «или»; и речь не о
      синтаксисе, а именно о конструкциях, то есть выражения
      типа <code>not(a&gt;b and a&lt;c)</code> тоже
      недопустимы. Факты, добавленные <code>assume()</code>, также
      видны функции <code>facts()</code>:</p>
      <p>Ключевое слово <code>kind</code> используется только для
      отображения тех фактов из базы, которые добавлены с
      помощью <code>declare()</code>.</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/6/maxima6-19.png" alt="">
      </div>
      <p>Если факты, заданные функцией <code>declare()</code>,
      удаляются вызовом <code>remove()</code>, то
      для <code>assume()</code> есть своя «обратная»
      функция — <code>forget()</code>, которая также принимает любое
      количество условий (точно таких же как и <code>assume()</code>),
      либо в качестве отдельных аргументов, либо списком.</p>
      <p>Общая база фактов используется этими двумя не очень похожими
      функциями неспроста: все, кому эти факты могут пригодиться,
      используют обе их разновидности, причем одновременно. Например,
      уже известный нам предикат <code>is</code>:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/6/maxima6-20.png" alt="">
      </div>
      <p>Еще один пример
      использования <code>assume()</code>/<code>declare()</code> —
      возможность избежать неопределенностей. Вы, возможно, помните,
      как в одном из примеров статьи
      «<a href="maxima-tarnavsky-4.html">Maxima. Алгебра и начала
      анализа</a>» в ответ на попытку посчитать некий интеграл Maxima
      задала нам вопрос о знаке входящего в него символа. Вот в таких
      ситуациях тоже может пригодиться <code>assume</code>, дабы
      предвосхитить расспросы:</p>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/6/maxima6-21.png" alt="">
      </div>
      <div class="well" style="background: #fff;">
        <img class="img-responsive left-block"
        src="i/tarnavsky/6/maxima6-22.png" alt="">
      </div>
      <p>Вот мы и подошли к концу «теоретической» части. Надеюсь,
      функционала, рассмотренного на протяжении шести статей, будет
      достаточно для решения многих задач, а также для того, чтобы
      черпать дальнейшие сведения из документации — ведь мы уже
      изучили такие вещи, благодаря которым Maxima становится не
      просто «вычислялкой» отдельных небольших примеров, а настоящей
      «средой программирования с математическим уклоном», позволяющей
      создавать свои собственные математические «типы данных» —
      числовые системы, функционалы и прочая и прочая — и полноценные
      программные модули, которые могут использовать весь встроенный
      (или также собственноручно достроенный) функционал
      Maxima. Рассмотрим, напоследок, более серьезный учебный пример,
      в котором эти возможности можно будет лучше прочувствовать. Одна
      заявленная тема у нас пока осталась нераскрытой — функции для
      работы с функциями и «глубокой» обработки выражений. Но это
      настолько серьезный инструмент, что на маленьких примерах его
      рассматривать было бы бессмысленно, а потому мы поговорим о нем
      в приложении-практикуме. Удачи!</p>
      <p>→ <a href="maxima-tarnavsky-6-diff.html">Пишем свой
      diff()</a></p>
    </div>
    <!-- End content column -->
    <!-- Begin info and menu column -->
    <div class="col-sm-3 col-md-4 hidden-print">
      <!-- Begin menu list -->
      <ul class="nav nav-pills nav-stacked">
        <li><a href="./index.html">главная страница</a></li>
        <li class="dropdown active"><a class="dropdown-toggle"
        data-toggle="dropdown" href="./documentation.html">Документация
        <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li><a href="./documentation.html">Maxima Руководства</a></li>
          <li><a href="../faq.html">часто задаваемые вопросы</a></li>
          <li><a href="../compalg.html">Компьютерная алгебра</a></li>
          <li><a href="../lisp.html">Ссылки по Lisp</a></li>
        </ul>
        </li>
        <li class="dropdown"><a class="dropdown-toggle"
        data-toggle="dropdown" href="../project.html">проект
        <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li><a href="../project.html">проект Maxima</a></li>
          <li><a href="../3rdpartycode.html">Дополнительные пакеты</a></li>
          <li><a href="../relatedprojects.html">Связанные проекты</a></li>
        </ul>
        </li>
        <li><a href="../download.html">Загрузка</a></li>
        <li><a href="../maximalist.html">Списки рассылки</a></li>
      </ul>
      <!-- End menu list -->
    </div>
    <!-- End info and menu column -->
  </div>
  <!-- End content row -->
</div>
<!-- End page -->
<br>
<!-- Begin project info -->
<footer role="contentinfo">
  <div class="container-fluid">
    <div class="row">
      <div class="col-sm-9 col-md-8 text-center">
        <p>Вопросы о Maxima или этого сайта: <a href="../maximalist.html">Списки
        рассылки</a></p>
        <p><a href="http://sourceforge.net/projects/maxima" >организовано
        Sourceforge</a></p>
      </div>
    </div>
  </div>
</footer>
<!-- End project info -->
<!-- Scripts section -->
<script src="../js/jquery.min.js"></script>
<script src="../js/bootstrap.min.js"></script>
</body>
</html>
