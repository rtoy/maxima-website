<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="HandheldFriendly" content="true">
<meta name="copyright" content="© 2002–2014 Maxima CAS development team.">
<meta name="keywords" content="Maxima, CAS, computer algebra, mathematics, Lisp, symbolic computation, MACSYMA, GPL, free, ODE, plotting, система компьютерной алгебры, компьютерная алгебра, математика, символьные вычисления, свободно">
<title>Maxima - Руководства</title>
<!-- This site uses Bootstrap http://getbootstrap.com -->
<link rel="stylesheet" href="../css/bootstrap.min.css">
<link rel="shortcut icon" href="../i/favicon.ico" media="all">
<style type="text/css">
.mx-content {background:#f2f2f2;color:#333;padding: 0 1.5em 1.5em 1.5em;}
</style>
</head>
<body style="padding-top:50px;" id="top">
<a class="sr-only sr-only-focusable" href="#content">Перейти к основному содержанию</a>
<!-- Begin navigation bar -->
<header class="navbar navbar-inverse navbar-fixed-top" role="banner">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>                        
      </button>
      <a href="./index.html" class="navbar-brand" title="Перейти на
      главную страницу" style="padding: 0 0.75rem 0 1.5rem"><img
      src="../i/logo.png" width="56" height="56" alt="Maxima"></a>
    </div>
    <nav class="collapse navbar-collapse" id="myNavbar">
      <ul class="nav navbar-nav">
        <li><a href="../download.html">Загрузка</a></li>
        <li><a href="./documentation.html">Документация</a></li>
        <li><a href="../project.html" >проект</a></li>
        <li><a href="#top" >верх страницы</a></li>
      </ul>
    </nav>
  </div>
</header>
<!-- End navigation bar -->
<!-- Begin page -->
<div class="container-fluid">
  <!-- Begin content row -->
  <div class="row">
    <!-- Begin content column -->
    <div class="col-sm-9 col-md-8 mx-content" id="content">
      <h1>Тихон Тарнавский. Пишем свой diff()</h1>
      <p>Впервые было опубликовано в «<a
      href="http://www.linuxformat.ru/">Linux Format</a>» <a
      href="http://www.linuxformat.ru/download/86.pdf">№12 (86),
      декабрь 2006 г</a>.</p>
      <p>Файл к статье: <a href="deriv.mac" shape="rect">deriv.mac</a>.</p>
      <p>Сначала
      я хотел рассмотреть несколько отдельных практических примеров:
      и маленьких, и чуть побольше. Но потом мне подумалось, что
      один, но более серьезный пример будет значительно лучше: с
      одной стороны, его можно строить понемногу, отрабатывая
      отдельные приемы точно так же, как это было бы сделано и с
      меньшими примерами, а с другой — в результате все эти приемы
      переплетутся между собой во что-то объемное, и на этих
      переплетениях возникнет более цельное ощущение возможностей
      программы, чем на несвязанных маленьких кусочках. К тому же по
      ходу дела мы соорудим несколько небольших вспомогательных
      функций, а заодно, для дополнительной практики, и более
      расширенную версию одной из них, которая, вполне возможно,
      пригодится вам и в дальнейшем.</p>
      <p>А писать мы будем настоящую функцию дифференцирования. Практически
      такую же, как встроенная <code>diff()</code>, только без вычисления
      полного дифференциала — чтобы не слишком сложно было «охватить»
      пониманием сразу весь пример. Ну а если будет интерес, то дописать
      вычисление полного дифференциала к этой же функции вы можете
      попробовать самостоятельно — после освоения возможностей, которые
      сейчас будут продемонстрированы, это будет уже несложно. Примеров
      применения по ходу создания функции я давать не буду. Если вы хотите
      смотреть на практические результаты, по мере добавления кода можно
      сохранять его в файле, скажем, <code>~/.maxima/deriv.mac</code> и
      выполнять в Maxima строку <code>load(deriv)$
      deriv(<var>какое-нибудь-выражение</var>);</code>.</p>
      <p>Я буду писать код постепенно и по ходу написания давать
      комментарии к последнему написанному участку. Комментировать
      буду, просто вставляя куски кода в текст. К слову: Maxima
      поддерживает комментарии в коде «в стиле Си», то есть
      комментарий начинается символами <code>/*</code>, а
      заканчивается <code>*/</code>. Причем, в отличие от Си,
      допускаются вложенные
      комментарии: <code>/* вот /* такие */ */</code>.</p>
      <p>Чтобы не повторять каждый раз весь код от самого начала, я
      буду сокращать его с помощью многоточия. Если вы будете
      проверять код по мере чтения, не забывайте о разделяющих запятых
      после последних строк предыдущих участков.</p>
      <p>Начнем с «подготовительных работ»: проверки определенных
      условий и сохранения нужных значений в локальных переменных.</p>
      <pre xml:space="preserve">deriv([l]):=block([f,len,x],
            len:length(l),
            if len=0 then
            error("deriv can't be used without arguments"),
            f:l[1],
            x:listofvars(f)
)$</pre>
      <p>Итак, по порядку. Символ в квадратных скобках означает, что
      ему будет присвоен список из всех аргументов, с которыми вызвана
      функция. Эта конструкция предназначена для создания функций с
      переменным числом аргументов.</p>
      <p>Функция <code>block()</code> — это расширенный аналог
      составного оператора. Отличается она двумя вещами. Во-первых,
      поддерживается возврат значений через <code>return()</code>, точно
      так же как из цикла, то есть
      по <code>return(<var>выражение</var>)</code> будет осуществлен
      выход из блока и результатом вычисления блока станет
      «выражение». А во-вторых, в блоке можно использовать локальные
      переменные — то есть такие, которые не повлияют на значения
      символов вне блока, даже если будут иметь совпадающие с ними
      имена. Такие локальные символы перечисляются в виде списка в
      самом начале блока.</p>
      <p>Далее мы сохраняем в одной из таких локальных переменных
      длину списка аргументов (функция <code>length</code>) и в случае,
      если она равна нулю (то есть аргументов нет), генерируем ошибку
      функцией <code>error</code>, которая может принимать произвольное
      число аргументов, которые она вычисляет и выводит прежде чем
      создать ошибку.</p>
      <p>Функция <code>listofvars</code> возвращает список переменных
      переданного ей выражения. Этот список понадобится нам для
      небольшого расширения возможностей: так как мы не будем
      вычислять полный дифференциал, то вызов с одним аргументом у нас
      освобождается, и мы будем его использовать аналогично
      функции <code>solve</code>: если переданное выражение включает в
      себя только одну неизвестную, будем дифференцировать его по
      ней. Продолжаем:</p>
      <pre xml:space="preserve">deriv([l]):=block([f,len,x],
...
   x:listofvars(f),
   if len=1 then (
        if length(x)=0 then
             return(0),
        if length(x)&gt;1 then
             error("Expression has more than one unknowns and none was
specified.","Unknowns given:", x),
        x:x[1] )
   else
        x:l[2]
)$</pre>
      <p>Если параметр дифференцирования в списке аргументов не задан,
      то проверяем длину списка неизвестных. Если она равна нулю — то
      это константа и следовательно возвращаем ноль. Если больше
      единицы, то неизвестно, по чему дифференцировать, следовательно,
      снова генерируем ошибку. Ну а в случае единицы, просто
      превращаем список из одного элемента в сам этот элемент. Если же
      список аргументов длиннее, то берем параметр оттуда.</p>
      <pre xml:space="preserve">deriv([l]):=block([f,len,x],
...
   else
        x:l[2]
   if len&gt;=3 then
   error("More than 2 arguments not implemented yet.")
)$</pre>
      <p>Пока ограничимся производной первого порядка по одной
      переменной. Когда этот этап будет пройден, остальное будет уже
      нетрудно написать на основе имеющегося кода. Теперь, когда
      проверки закончены, приступаем непосредственно к
      реализации. Строить эту функцию мы будем поэтапно. Для начала
      научим ее дифференцировать просто переменную и константу:</p>
      <pre xml:space="preserve">deriv([l]):=block([f,len,x],
...
   error("More than 2 arguments not implemented yet.")
   if atom(f) or subvarp(f) then
        if f=x then
             return(1)
        else
             return(0),
   else
         return ('diff(f,x))
)$</pre>
      <p>Предикат <code>atom()</code> проверяет, является ли его
      аргумент атомарным выражением, то есть константой (целой либо с
      плавающей точкой) или одиночным символом. Второй
      предикат — <code>subvarp()</code> — расшифровывается
      как <code>subscripted variable (predicate)</code>, где первые
      два слова означают «индексированная переменная», то есть что-то
      вида <code>a[1]</code>. Добавлен этот предикат в эту же проверку
      в связи с тем, что Maxima такие выражения атомарными не считает,
      а с точки зрения дифференцирования они как раз являются
      атомами. Дальше в этом варианте все просто: если атомарное
      выражение является параметром дифференцирования, то результат
      будет равен единице, иначе — нулю: в полном соответствии с
      правилами дифференцирования.</p>
      <p>В самом конце функции добавляем строку, которая в нештатном
      случае (таком, который мы еще не посчитали) просто вернет
      несовершенную форму производной от оставшегося выражения. Эта
      строка у нас вплоть до самой полной реализации будет оставаться
      последней, а все остальное мы будем вписывать до нее, сокращая
      тем самым этому некрасивому умолчательному случаю шансы на
      выживание. А двигаться дальше мы будем достаточно интересным
      способом, с помощью уже упомянутой в статье рекурсии. Мы будем
      постепенно обучать нашу функцию все новым и новым трюкам
      (точнее, правилам дифференцирования), разбивая неизвестные
      выражения некоторыми способами на более простые, уже
      обработанные варианты; то есть действуя снова по известному
      «принципу чайника». И вы увидите, что математики не зря так
      любят этот принцип: с его помощью такая, на первый взгляд,
      сложная задача будет разбита на множество простых подзадачек и
      таким образом упростится сама. Например, первым пойдет
      вычитание. Точнее, унарный минус или попросту отрицательные
      величины: бинарного минуса в Maxima по сути не существует, а
      любое выражение вида <code>a–b</code> имеет внутреннюю
      форму <code>a+(–b)</code>, то есть сводится по все тому же
      принципу к плюсу. Итак, приступим:</p>
      <pre xml:space="preserve">setup_autoload(stringproc,sequal)$
deriv([l]):=block([f,len,x,o],
...
        else
             return(0),
   o:op(f),
   return (
        if sequal(o,"-") then
             -deriv(-f,x)
        else
              'diff(f,x)
   )
)$</pre>
      <p>Тут мы уже начинаем использовать те самые функции по
      «глубокой» обработке выражений. Функция <code>op()</code>
      возвращает основной оператор заданного выражения. Основным
      считается самый внешний; например <code>op(a+b/c)</code> будет
      равен <code>"+"</code>, <code>op((a+b)*2)</code> — <code>"*"</code>,
      а <code>op(sin(x^2+y^2))</code> — <code>sin</code>. Дальше
      включается «принцип чайника»: для отрицательного выражения мы
      просто выносим минус за скобки, а для остального, теперь уже
      положительного, вызываем саму же функцию <code>deriv</code>.</p>
      <p>Здесь для сверки значения оператора с минусом используется
      не <code>equal()</code>, а ее строковый
      аналог — <code>sequal()</code>, проверяющий на равенство две
      строки. Связано это с тем, что разные операторы Maxima хранит в
      разном виде, и при сверке, скажем, того же минуса, который
      хранится как текстовый знак с синусом, хранящимся как символ
      (идентификатор) Maxima, обычный <code>equal()</code> просто
      выдаст ошибку.</p>
      <p>Функция <code>sequal()</code> — внешняя, она хранится в
      файле <code>stringproc</code> (от фразы «<em>string
      processing</em>» — обработка строк), который и нужно подгрузить
      до использования этой функции. А для того чтобы, файл не
      приходилось загружать вручную, но при этом он и не загружался бы
      при каждом вызове функции (как было бы в случае
      вызова <code>load()</code> внутри функции <code>deriv()</code>),
      есть, с одной стороны, традиционный способ: определить внутри
      файла некую константу или свойство, а перед его загрузкой
      проверять их наличие: если нету — тогда и подгружать. Мы же
      используем не общепринятый, но в чем-то более простой метод:
      рассмотренную в статье
      функцию <code>setup_autoload</code>. Благодаря ей, нам с одной
      стороны, не надо лезть в исходники библиотек (которые, кстати
      говоря, часто бывают не на языке Maxima, а на Lisp) и искать там
      флаги; а с другой — мы все же уверены, что файл будет
      загружаться не больше одного раза: именно это и гарантируется
      функцией <code>setup_autoload</code>.</p>
      <p>И последний момент в этом кусочке: обратите внимание на
      оператор <code>if</code>, сместившийся внутрь
      функции <code>return()</code>. Напомню, что <code>if</code> в
      Maxima является полноценным оператором, то есть всегда
      возвращает последнее вычисленное значение. А раз так, нет
      никакого смысла вызывать <code>return()</code> много раз. По
      большому счету, здесь и один вызов <code>return()</code> не
      нужен: результатом <code>block()</code>, как и примитивного
      составного оператора, будет последнее вычисленное выражение. Так
      что для еще большей краткости напишем даже так:</p>
      <pre xml:space="preserve">...
   o:op(f),
   if sequal(o,"-") then
        -deriv(-f,x)
   else
         'diff(f,x)
)$</pre>
      <p>После минуса логично было бы заняться плюсом; но поскольку
      сумма при дифференцировании переходит в сумму, то проще будет
      реализовать ее сразу для произвольного числа слагаемых, а это
      уже немного сложнее. Потому начнем с более простых в реализации
      арифметических действий: умножения и деления.</p>
      <pre xml:space="preserve">...
    if sequal(o,"-") then
        -deriv(-f,x)
    else if sequal(o,"*") then
        deriv(first(f),x)*rest(f)+first(f)*deriv(rest(f),x)
    else if sequal(o,"//") then
    (deriv(first(f),x)*last(f)-first(f)*deriv(last(f),x))/last(f)^2
    else
         'diff(f,x)
)$</pre>
      <p>Здесь мы сталкиваемся с одним очень интересным и весьма
      полезным свойством: многие из функций работы со списками,
      которых в Maxima немало, воспринимают как списки также и любые
      выражения. Так, «списковая» функция <code>first()</code>,
      возвращающая первый элемент заданного списка, вызванная
      как <code>first(a*b*c)</code>, вернет <code>a</code>; а у
      функции <code>rest()</code> («остаток»), отдающей (в варианте
      вызова с одним аргументом), наоборот, весь список кроме первого
      элемента, на том же выражении результатом
      будет <code>b*c</code>. Этим мы и воспользовались, вызывая при
      этом снова для каждого слагаемого саму
      функцию <code>deriv()</code>. Если сомножителей будет больше чем
      два, то вызов <code>deriv(rest(f),x)</code> пройдет по этой же
      ветке и отсечет еще один.</p>
      <p>Так же мы поступаем и с делением. Здесь, так как аргумента
      всегда два, вместо <code>rest()</code> используется
      функция <code>last()</code> — последний элемент списка
      (<code>rest()</code> в этом же случае вернула бы список из
      одного элемента, а потому <code>last()</code> более
      удобна). Только одно «но»: деление почему-то обозначается во
      внутреннем представлении Maxima не одиночной, а двойной косой
      чертой.</p>
      <p>Точно таким же образом можно обработать последний бинарный
      оператор (кроме оставленного на закуску сложения) — возведение в
      степень. Здесь тоже нет никаких сложностей, и даже нечего
      дополнительно объяснять по сравнению с делением:</p>
      <pre xml:space="preserve">...
    else if sequal(o,"^") then
        first(f)^last(f)*log(first(f))*deriv(last(f),x)+
        first(f)^(last(f)-1)*last(f)*deriv(first(f),x)
    else
         'diff(f,x)
)$</pre>
      <p>Теперь вернемся к сложению. Тут нам уже пригодятся упомянутые
      в статье функции по работе с функциями, а конкретно —
      функция <code>map()</code>. Она принимает в качестве первого
      аргумента имя функции и как бы вкладывает эту функцию внутрь
      выражений — последующих аргументов. Проще всего будет пояснить
      на примере: <code>map(f,[a,b,c])</code> даст
      результат <code>[f(a),f(b),f(c)]</code>. И, что самое
      замечательное, она, точно так же, как и «списковые» функции,
      работает не только со списками, но и с любыми выражениями;
      например, <code>map(f,a+b+c)</code> ↦ <code>f(a)+f(b)+f(c)</code>. Как
      хорошо подходит для нашей задачи, не правда ли? Именно так и
      должна действовать на сумму функция дифференцирования. Все было
      бы совсем хорошо, если бы <code>deriv()</code> принимала, кроме
      выражения, только один аргумент. С двумя
      выражениями <code>map</code> тоже умеет работать, но только если
      у них одинаковый основной оператор; то есть сумму можно
      «отобразить» только на
      сумму: <code>map(f,a+b+c,x+y+z)</code> ↦ <code>f(c,z)+f(b,y)+f(a,x)</code>. Проблема
      здесь в том, что у нас второй аргумент во всех
      вызовах <code>deriv()</code>, которые должны попасть внутрь
      суммы, одинаков, а выражение вида <code>x+x+x</code> передать
      невозможно: оно автоматически упростится в <code>3*x</code>. Но,
      как известно, из любой безвыходной ситуации всегда есть как
      минимум два выхода. И в данном случае один из этих выходов
      достаточно прост: написать небольшую функцию-«обертку» вокруг
      map:</p>
      <pre xml:space="preserve">map1st(f,expr,x):=block([o],
   o:op(expr),
   subst(o,"[",map(f,subst("[",o,expr),makelist(x,i,1,length(expr))))
)$</pre>
      <p>Еще одна новая функция «глубинной» работы с выражениями:
      subst(). Она способна заменять в выражении… да почти что угодно
      и почти на что угодно. Вызывается так: subst(стало, было,
      выражение), заменяя в «выражении» все, что «было», на
      «стало». Опять же, в качестве подвыражений могут использоваться
      операторы, то
      есть <code>subst("*","+",x+y+z)</code> ↦ <code>x*y*z</code>. Мы
      используем ее для временной подмены основного оператора
      выражения оператором списка (который обозначается
      как <code>"["</code>, то есть <code>[a,b,c]</code> — это, по
      сути, <code>"["(a,b,c)</code>). Затем генерируем список такой
      же, как выражение, длины, заполненный заданной переменной, — и
      применяем к двум полученным спискам функцию <code>map()</code>,
      а затем возвращаем назад вместо списка первоначальный базовый
      оператор. То есть теперь, к
      примеру, <code>map1st(f,a+b+c,x)</code> будет равно как
      раз <code>f(c,x)+f(b,x)+f(a,x)</code>. Et voila, как говорят
      французы! И теперь внутри <code>deriv()</code> можно применить к
      сложению именно эту новую функцию. Заодно применим ее и к
      списку — (<code>deriv([f,g],x)</code> будет
      равно <code>[deriv(f,x),deriv(g,x)]</code>) и, чего уж там
      мелочиться, и к множеству:</p>
      <pre xml:space="preserve">...
   o:op(f),
   if sequal(o,"+") or sequal(o,"[") or sequal(o,set) then
       map1st(deriv,f,x)
   else if sequal(o,"-") then
       -deriv(-f,x)
...</pre>
      <p>Множества, к слову, в Maxima реализованы в самом что ни на
      есть математическом смысле: множество может включать в себя
      каждый элемент только один раз; и это учитывается и встроенными
      операциями по работе с множествами: пересечением, объединением
      и т. д. Есть еще некоторые ошибки, но они документированы и
      потому не неожиданны.</p>
      <p>Движемся дальше. У нас уже реализована производная от всех
      бинарных операторов, а дальше мы нарисуем «таблицу производных»
      и будем работать с нею:</p>
      <pre xml:space="preserve">deriv([l]):=block([f,len,o,x,func,fdrv],
...
   o:op(f),
   func:[sqrt, sin, cos, abs, exp, log, tan, cot, sec, csc, asin, acos, atan,
acot, asec, acsc, sinh, cosh, tanh, coth, asinh, acosh, atanh, acoth,
asech, acsch],
   fdrv:[1/2/arg, cos(arg), -sin(arg), arg/abs(arg), exp, 1/arg, sec(arg)^2,
-csc(arg)^2, tan(arg)*sec(arg), -cot(arg)*csc(arg), 1/sqrt(1-arg^2),
-1/sqrt(1-arg^2), 1/(1+arg^2), -1/(1+arg^2), 1/arg^2/sqrt(1-1/arg^2),
-1/arg^2/sqrt(1-1/arg^2), cosh(arg), sinh(arg), sech(arg), -csch(arg),
1/sqrt(arg^2+1), 1/sqrt(arg^2-1), 1/(1-arg^2), 1/(1-arg^2),
-1/arg^2/sqrt(1/arg^2-1), -1/arg^2/sqrt(1/arg^2+1)],
   if sequal(o,"+") or sequal(o,"[") or sequal(o,set) then
...</pre>
      <p>Для упрощения работы с «таблицей» напишем еще две небольших
      вспомогательных функции: одна будет проверять, входит ли
      заданный элемент в заданный список, а вторая — возвращать
      номер, соответствующий заданному элементу в заданном списке,
      при условии что он там есть.</p>
      <pre xml:space="preserve">smember(expr,list):=
   if sequal(true,
       for i in list do
            if sequal(expr,i) then
                return(true) )
   then true$
sindex(expr,list):=block([num],
   num:for i:1 thru length(list) do
             if sequal(expr,list[i]) then
                 return(i),
   if integerp(num) then num
)$</pre>
      <p>Здесь есть только одна тонкость, связанная с небольшой
      проблемой. Заключается эта проблема в том, что для возвращения
      значения из блока и из цикла в Maxima используется одна и та же
      функция <code>return()</code>. Это приводит к тому, что выйти из
      блока, находясь внутри цикла в нем, невозможно — приходится
      выдумывать некоторые несложные ухищрения. Теперь с
      использованием двух новых функций заменяем элементы «таблицы» их
      производными; с помощью уже знакомой нам <code>subst</code>,
      которая подставит нужное выражение внутрь табличной функции
      вместо ключевого слова <code>arg</code>.</p>
      <pre xml:space="preserve">...
   else if smember(o,func) then
   deriv(first(f),x)*subst(first(f),arg,fdrv[sindex(o,func)])
   else
        'diff(f,x)
)$</pre>
      <p>Вот так, начиная с самых простых элементов, а затем, подобно
      Мюнхгаузену, вытаскивая самих себя сантиметр за сантиметром, мы
      и получили полноценную функцию дифференцирования. Правда, пока
      только первого порядка и только по одному аргументу. Но имея то,
      что имеем, двигаться дальше, следуя известному принципу, уже
      совсем не сложно: просто заменим строку
      «<code>if len&gt;=3 then error…</code>» следующим куском:</p>
      <pre xml:space="preserve">...
   if len=3 then (
        integerp(l[3]) or
             return('diff(x,l[3])),
        if l[3]=0 then
             return(f),
        if l[3]&lt;0 then
             error("Improper count to deriv:",l[3]),
        if l[3]&gt;1 then
             return(deriv(deriv(f,x,l[3]-1),x))
   ),
   if len&gt;3 then (
        if(evenp(len)) then
             l:endcons(1,l),
        return(deriv(apply(deriv,rest(l,-2)),l[len],l[len+1]))
   ),
...</pre>
      <p>Пройдемся по нескольким неосвещенным моментам. В силу
      способов вычисления в Maxima (которые сродны таковым во многих
      языках программирования) конструкция вида
      «<code><var>условие</var> or <var>выражение</var></code>»
      равносильно
      «<code>if not <var>условие</var> then <var>выражение</var></code>» —
      и использована здесь исключительно для разнообразия, в учебных
      целях. Здесь мы в случае нецелого порядка дифференцирования
      просто возвращаем несовершенную форму — точно так же, как это
      делает и штатная функция <code>diff()</code>.</p>
      <p>Производная нулевого порядка от любой функции — это сама
      функция. А производные отрицательных порядков некорректны, о
      чем мы и генерируем сообщение. Для порядков, больших единицы,
      понижаем порядок как и раньше — за счет самовызова.</p>
      <p>Далее я немного усовершенствовал поведение функции по
      сравнению со встроенной: если та не умеет принимать четное
      количество аргументов больше двух (то есть с неуказанным
      порядком дифференцирования по последней неизвестной когда
      неизвестных больше одной), то у нас в данном случае, так же как
      и для одной неизвестной, будет подразумеваться единица. Здесь
      предикат <code>evenp()</code> проверяет число на четность
      (even — четный), а функция <code>endcons()</code> добавляет
      заданный элемент в конец заданного списка. Ее имя носит
      исторический характер: парная к ней
      функция <code>cons()</code>, добавляющая элемент в начало
      списка, свое имя позаимствовала из Lisp, а слово end здесь
      добавлено «по смыслу».</p>
      <p>Далее мы, снова самовызовом, укорачиваем список параметров
      дифференцирования. При этом используется еще одна функция,
      работающая с функциями, — <code>apply()</code>
      (<em>применять</em>). Она принимает два аргумента, первый из
      которых — имя функции, а второй — список, и применяет заданную
      функцию к списку как к списку аргументов. Также здесь
      использован более широкий вариант вызова <code>rest()</code>:
      он может принимать второй аргумент — целое число, не равное
      нулю. Если число положительно, то такое количество элементов
      выбрасывается из начала списка, а если отрицательно — то с
      конца; в данном случае мы теряем последние два элемента.</p>
       <p>Вот и все. Мы уже имеем полную функцию дифференцирования,
      берущую производные с произвольным количеством параметров и
      любых порядков. Полный текст всех созданных функций вы можете
      найти в файле <code>deriv.mac</code> на прилагаемом к журналу
      диске.</p>
      <p>Дополнительно хочется остановиться на одной незамысловатой
      функции, которая, тем не менее, может неплохо помочь в отладке
      собственных модулей. Это функция <code>display()</code>,
      которая принимает имена и отображает их значения в виде
      «<code><var>имя</var>=<var>значение</var></code>». В качестве
      эксперимента можете добавить ее где-нибудь внутри
      функции <code>deriv()</code> и отследить процесс самовызова (в
      файле на диске вызов <code>display()</code> достаточно
      раскомментировать).</p>
      <p>И в качестве финального аккорда сделаем еще и более
      универсальную версию вспомагательной
      функции <code>map1st()</code> — возможно, тогда она вам
      пригодится и еще где-нибудь.</p>
      <pre xml:space="preserve">mapany(f,[lst]):=block([o,l],l:lst,
   if length(setify(map(length,l)))&gt;1 then
   error("Arguments to mapany are not of the same length"),
   o:op(l[1]),
   for i:1 thru length(l) do
        l[i]:subst("[",op(l[i]),l[i]),
   subst(o,"[",apply(map,cons(f,l)))
)$</pre>
      <p>Здесь я уже воздержусь от столь подробных комментариев, так
      как практически все, что используется в этой функции, уже было в
      той или иной степени разъяснено в процессе
      описания <code>deriv()</code>. Остановлюсь только на одной
      строчке:</p>
      <pre xml:space="preserve">if length(setify(map(length,l)))&gt;1 then</pre>
      <p>Здесь используется не совсем простой прием для проверки длин
      списков на одинаковость. Так как <code>l</code> — это список из
      списков, то сначала получаем список длин «вкручиванием» внутрь
      внешнего списка функции <code>length()</code>. Дальше —
      интереснее. Функция <code>setify</code> (дословно — что-то вроде
      «множествицировать») превращает список в множество. Так как
      множество не может содержать несколько равных между собой
      элементов, то такие элементы при этом «склеиваются»: из них
      остается один. Таким образом если «длина» (количество элементов)
      множества больше единицы, то как минимум два элемента в
      первоначальном списке были неравны между собой.</p>
      <p>И вернувшись к рассмотренной функции дифференцирования,
      хочется еще раз обратить ваше внимание на использованный прием:
      конструировать большие и сложные функции из более маленьких и
      простых кусочков с помощью рекурсии. Этот метод очень часто и
      продуктивно используется в функциональном программировании, к
      которому Maxima, в силу своих Lisp-овских корней, очень
      близка.</p>
    </div>
    <!-- End content column -->
    <!-- Begin info and menu column -->
    <div class="col-sm-3 col-md-4 hidden-print">
      <!-- Begin menu list -->
      <ul class="nav nav-pills nav-stacked">
        <li><a href="./index.html">главная страница</a></li>
        <li class="dropdown active"><a class="dropdown-toggle"
        data-toggle="dropdown" href="./documentation.html">Документация
        <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li><a href="./documentation.html">Maxima Руководства</a></li>
          <li><a href="../faq.html">часто задаваемые вопросы</a></li>
          <li><a href="../compalg.html">Компьютерная алгебра</a></li>
          <li><a href="../lisp.html">Ссылки по Lisp</a></li>
        </ul>
        </li>
        <li class="dropdown"><a class="dropdown-toggle"
        data-toggle="dropdown" href="../project.html">проект
        <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li><a href="../project.html">проект Maxima</a></li>
          <li><a href="../3rdpartycode.html">Дополнительные пакеты</a></li>
          <li><a href="../relatedprojects.html">Связанные проекты</a></li>
        </ul>
        </li>
        <li><a href="../download.html">Загрузка</a></li>
        <li><a href="../maximalist.html">Списки рассылки</a></li>
      </ul>
      <!-- End menu list -->
    </div>
    <!-- End info and menu column -->
  </div>
  <!-- End content row -->
</div>
<!-- End page -->
<br>
<!-- Begin project info -->
<footer role="contentinfo">
  <div class="container-fluid">
    <div class="row">
      <div class="col-sm-9 col-md-8 text-center">
        <p>Вопросы о Maxima или этого сайта: <a href="../maximalist.html">Списки
        рассылки</a></p>
        <p><a href="http://sourceforge.net/projects/maxima" >организовано
        Sourceforge</a></p>
      </div>
    </div>
  </div>
</footer>
<!-- End project info -->
<!-- Scripts section -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<script src="../js/bootstrap.min.js"></script>
</body>
</html>
