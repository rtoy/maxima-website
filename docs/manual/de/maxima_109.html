<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Funktionen und Variablen der linearen Algebra (Maxima Manual)</title>

<meta name="description" content="Funktionen und Variablen der linearen Algebra (Maxima Manual)">
<meta name="keywords" content="Funktionen und Variablen der linearen Algebra (Maxima Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="maxima_toc.html" rel="start" title="Top">
<link href="maxima_334.html" rel="index" title="Index der Variablen und Funktionen">
<link href="maxima_toc.html#SEC_Contents" rel="contents" title="Inhaltsverzeichnis">
<link href="maxima_104.html" rel="up" title="Lineare Algebra">
<link href="maxima_105.html" rel="prev" title="Einf&uuml;hrung in die lineare Algebra">
<style type="text/css">
<!--
a.copiable-anchor {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
span:hover a.copiable-anchor {visibility: visible}
ul.no-bullet {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 1em; padding-bottom: 1em;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%; display: block; margin-left: auto; margin-right: auto}

-->
</style>

<link rel="icon" href="figures/favicon.ico">
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6>"></script>

</head>

<body lang="de">
<div class="section" id="Funktionen-und-Variablen-der-linearen-Algebra">
<div class="header">
<p>
Vorige: <a href="maxima_105.html" accesskey="p" rel="prev">Einf&uuml;hrung in die lineare Algebra</a>, Nach oben: <a href="maxima_104.html" accesskey="u" rel="up">Lineare Algebra</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Inhaltsverzeichnis" rel="contents">Inhalt</a>][<a href="maxima_334.html" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Funktionen-und-Variablen-der-linearen-Algebra-1"></span><h3 class="section">19.2 Funktionen und Variablen der linearen Algebra</h3>

<span id="addcol"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002faddcol"></span><dl class="def">
<dt id="index-addcol"><span class="category">Funktion: </span><span><strong>addcol</strong> <em>(<var>M</var>, <var>list_1</var>, &hellip;, <var>list_n</var>)</em><a href='#index-addcol' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>H&auml;ngt eine oder mehrere Spalten, die als Listen <var>list_1</var>, &hellip;, 
<var>list_n</var> &uuml;bergeben werden, an die Matrix <var>M</var> an.
</p>
<p>Beispiel:
</p>
<div class="example">
<pre class="example">(%i1) M:matrix([a,b],[c,d]);
                            [ a  b ]
(%o1)                       [      ]
                            [ c  d ]
(%i2) addcol(M,[1,2],[x,y]);
                         [ a  b  1  x ]
(%o2)                    [            ]
                         [ c  d  2  y ]
</pre></div>
</dd></dl>

<span id="addrow"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002faddrow"></span><dl class="def">
<dt id="index-addrow"><span class="category">Funktion: </span><span><strong>addrow</strong> <em>(<var>M</var>, <var>list_1</var>, &hellip;, <var>list_n</var>)</em><a href='#index-addrow' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>H&auml;ngt eine oder mehrere Zeilen, die als Listen <var>list_1</var>, &hellip;,
<var>list_n</var> &uuml;bergeben werden, an die Matrix <var>M</var> an.
</p>
<p>Beispiel:
</p>
<div class="example">
<pre class="example">(%i1) M:matrix([a,b],[c,d]);
                            [ a  b ]
(%o1)                       [      ]
                            [ c  d ]
(%i2) addrow(M,[1,2],[x,y]);
                            [ a  b ]
                            [      ]
                            [ c  d ]
(%o2)                       [      ]
                            [ 1  2 ]
                            [      ]
                            [ x  y ]
</pre></div>
</dd></dl>

<span id="adjoint"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fadjoint"></span><dl class="def">
<dt id="index-adjoint"><span class="category">Funktion: </span><span><strong>adjoint</strong> <em>(<var>M</var>)</em><a href='#index-adjoint' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Gibt die adjungierte der Matrix <var>M</var> zur&uuml;ck.
</p></dd></dl>

<span id="augcoefmatrix"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002faugcoefmatrix"></span><dl class="def">
<dt id="index-augcoefmatrix"><span class="category">Funktion: </span><span><strong>augcoefmatrix</strong> <em>([<var>eqn_1</var>, &hellip;, <var>eqn_m</var>], [<var>x_1</var>, &hellip;, <var>x_n</var>])</em><a href='#index-augcoefmatrix' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Gibt die erweiterte Koeffizientenmatrix f&uuml;r die Variablen <var>x_1</var>, &hellip;, 
<var>x_n</var> und dem linearen Gleichungssystem <var>eqn_1</var>, &hellip;, <var>eqn_m</var>.
Die erweiterte Koeffizientenmatrix entsteht, wenn an die Koeffizientenmatrix 
des Gleichungssystems die Spalte mit der rechten Seite des Gleichungssystems
angef&uuml;gt wird.
</p>
<p>Beispiel:
</p>
<div class="example">
<pre class="example">(%i1) m: [2*x - (a - 1)*y = 5*b, c + b*y + a*x = 0]$
(%i2) augcoefmatrix (m, [x, y]);
                       [ 2  1 - a  - 5 b ]
(%o2)                  [                 ]
                       [ a    b      c   ]
</pre></div>
</dd></dl>

<span id="charpoly"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fcharpoly"></span><dl class="def">
<dt id="index-charpoly"><span class="category">Funktion: </span><span><strong>charpoly</strong> <em>(<var>M</var>, <var>x</var>)</em><a href='#index-charpoly' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Gibt das charakteristische Polynom der Matrix <var>M</var> f&uuml;r die Variable <var>x</var>
zur&uuml;ck.  Das charakterische Polynom wird als
<code>determinant(<var>M</var> - diagmatrix(length (<var>M</var>), <var>x</var>))</code> berechnet.
</p>
<p>Beispiel:
</p>
<div class="example">
<pre class="example">(%i1) a: matrix ([3, 1], [2, 4]);
                            [ 3  1 ]
(%o1)                       [      ]
                            [ 2  4 ]
(%i2) expand (charpoly (a, lambda));
                           2
(%o2)                lambda  - 7 lambda + 10
(%i3) (programmode: true, solve (%));
(%o3)               [lambda = 5, lambda = 2]
(%i4) matrix ([x1], [x2]);
                             [ x1 ]
(%o4)                        [    ]
                             [ x2 ]
(%i5) ev (a . % - lambda*%, %th(2)[1]);
                          [ x2 - 2 x1 ]
(%o5)                     [           ]
                          [ 2 x1 - x2 ]
(%i6) %[1, 1] = 0;
(%o6)                     x2 - 2 x1 = 0
(%i7) x2^2 + x1^2 = 1;
                            2     2
(%o7)                     x2  + x1  = 1
(%i8) solve ([%th(2), %], [x1, x2]);
                  1               2
(%o8) [[x1 = - -------, x2 = - -------], 
               sqrt(5)         sqrt(5)

                                             1             2
                                    [x1 = -------, x2 = -------]]
                                          sqrt(5)       sqrt(5)
</pre></div>
</dd></dl>

<span id="coefmatrix"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fcoefmatrix"></span><dl class="def">
<dt id="index-coefmatrix"><span class="category">Funktion: </span><span><strong>coefmatrix</strong> <em>([<var>eqn_1</var>, &hellip;, <var>eqn_m</var>], [<var>x_1</var>, &hellip;, <var>x_n</var>])</em><a href='#index-coefmatrix' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Gibt die Koeffizientenmatrix f&uuml;r die Variablen <var>x_1</var>, &hellip;, <var>x_n</var>
des linearen Gleichungssystem <var>eqn_1</var>, &hellip;, <var>eqn_m</var> zur&uuml;ck.
</p>
<p>Beispiel:
</p>
<div class="example">
<pre class="example">(%i1) coefmatrix([2*x-(a-1)*y+5*b = 0, b*y+a*x = 3], [x,y]);
</pre><pre class="example">                                 [ 2  1 - a ]
(%o1)                            [          ]
                                 [ a    b   ]
</pre></div>
</dd></dl>

<span id="col"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fcol"></span><dl class="def">
<dt id="index-col"><span class="category">Funktion: </span><span><strong>col</strong> <em>(<var>M</var>, <var>i</var>)</em><a href='#index-col' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Gibt die <var>i</var>-te Spalte der Matrix <var>M</var> zur&uuml;ck.  Das Ergebnis ist eine
Matrix.
</p>
<p>Beispiel:
</p>
<div class="example">
<pre class="example">(%i1) M:matrix([1,2,3],[a,b,c]);
                           [ 1  2  3 ]
(%o1)                      [         ]
                           [ a  b  c ]
(%i2) col(M,2);
                              [ 2 ]
(%o2)                         [   ]
                              [ b ]
</pre></div>
</dd></dl>

<span id="columnvector"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fcolumnvector"></span><dl class="def">
<dt id="index-columnvector"><span class="category">Funktion: </span><span><strong>columnvector</strong> <em>(<var>L</var>)</em><a href='#index-columnvector' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="Item_003a-Matrices_002ede_002fdeffn_002fcovect"></span></dd><dt id="index-covect"><span class="category">Funktion: </span><span><strong>covect</strong> <em>(<var>L</var>)</em><a href='#index-covect' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Gibt eine Matrix mit einer Spalte zur&uuml;ck, die die Elemente der Liste <var>L</var>
enth&auml;lt.
</p>

<p><code>covect</code> ist ein Alias-Name f&uuml;r die Funktion <code>columnvector</code>.  Das 
Kommando <code>load(&quot;eigen&quot;)</code> l&auml;dt die Funktion.
</p>

<p>Beispiel:
</p>

<div class="example">
<pre class="example">(%i1) load(&quot;eigen&quot;)$

(%i2) columnvector ([aa, bb, cc]);
                             [ aa ]
                             [    ]
(%o2)                        [ bb ]
                             [    ]
                             [ cc ]
</pre></div>
</dd></dl>

<span id="copymatrix"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fcopymatrix"></span><dl class="def">
<dt id="index-copymatrix"><span class="category">Funktion: </span><span><strong>copymatrix</strong> <em>(<var>M</var>)</em><a href='#index-copymatrix' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Gibt eine Kopie der Matrix <var>M</var> zur&uuml;ck.
</p>

<p>Die Zuweisung wie zum Beispiel <code>m2: m1</code> kopiert die Matrix <code>m1</code> nicht.
Wird nach dieser Zuweisung die Matrix <code>m2</code> ge&auml;ndert, wird auch die Matrix
<code>m1</code> ge&auml;ndert.  Um eine Kopie zu erhalten, muss <code>m2: copymatrix(m1)</code>
ausgef&uuml;hrt werden.
</p></dd></dl>

<span id="determinat"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fdeterminant"></span><dl class="def">
<dt id="index-determinant"><span class="category">Funktion: </span><span><strong>determinant</strong> <em>(<var>M</var>)</em><a href='#index-determinant' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Berechnet die Determinate der Matrix <var>M</var>.  Die angewendete Methode ist
vergleichbar mit dem Gau&szlig;-Verfahren.
</p>


<p><code>determinat</code> wird von den Schaltern <code>ratmx</code> und <code>sparse</code>
kontrolliert.  Haben beide Schalter den Wert <code>true</code>, wird ein spezieller
Algorithmus f&uuml;r schwachbesetzte Matrizen aufgerufen.
</p></dd></dl>

<span id="detout"></span><span id="Item_003a-Matrices_002ede_002fdefvr_002fdetout"></span><dl class="def">
<dt id="index-detout"><span class="category">Optionsvariable: </span><span><strong>detout</strong><a href='#index-detout' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p>Hat <code>detout</code> den Wert <code>true</code>, wird die Determinate einer Matrix, f&uuml;r
die die inverse Matrix berechnet wird, aus der Matrix herausmultipliziert.
</p>

<p>Damit dieser Schalter einen Effekt hat, m&uuml;ssen die Optionsvariablen 
<code>doallmxops</code> und <code>doscmxops</code> den Wert <code>false</code> haben.
</p>
<p>Beispiele:
</p>
<div class="example">
<pre class="example">(%i1) m: matrix ([a, b], [c, d]);
                            [ a  b ]
(%o1)                       [      ]
                            [ c  d ]
(%i2) detout: true$
(%i3) doallmxops: false$
(%i4) doscmxops: false$
(%i5) invert (m);
                          [  d   - b ]
                          [          ]
                          [ - c   a  ]
(%o5)                     ------------
                           a d - b c
</pre></div>

</dd></dl>

<span id="diagmatrix"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fdiagmatrix"></span><dl class="def">
<dt id="index-diagmatrix"><span class="category">Funktion: </span><span><strong>diagmatrix</strong> <em>(<var>n</var>, <var>x</var>)</em><a href='#index-diagmatrix' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Gibt eine <var>n</var>-dimensionale Diagonalmatrix zur&uuml;ck, deren Diagonalelemente
alle den Wert <var>x</var> haben.
</p>

<p><var>n</var> muss zu einer ganzen Zahl auswerten.  Ansonsten meldet Maxima einen
Fehler.
</p>

<p><var>x</var> kann ein beliebiger Ausdruck einschlie&szlig;lich einer Matrix sein.  Ist
<var>x</var> eine Matrix, dann wird diese nicht kopiert.
</p></dd></dl>

<span id="doallmxops"></span><span id="Item_003a-Matrices_002ede_002fdefvr_002fdoallmxops"></span><dl class="def">
<dt id="index-doallmxops"><span class="category">Optionsvariable: </span><span><strong>doallmxops</strong><a href='#index-doallmxops' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>doallmxops</code> den Wert <code>true</code>, werden Matrixoperationen 
ausgef&uuml;hrt.  Ist der Wert <code>false</code>, werden nur die Matrixoperationen 
ausgef&uuml;hrt, die mit den einzelnen <code>dot</code>-Schaltern eingeschaltet sind.
</p></dd></dl>

<span id="domexpt"></span><span id="Item_003a-Matrices_002ede_002fdefvr_002fdomxexpt"></span><dl class="def">
<dt id="index-domxexpt"><span class="category">Optionsvariable: </span><span><strong>domxexpt</strong><a href='#index-domxexpt' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>domxexpt</code> den Wert <code>true</code>, wird die Exponentiation
<code>exp(<var>M</var>)</code>, wobei <var>M</var> eine Matrix ist, elementweise f&uuml;r jedes
einzelne Matrixelement ausgef&uuml;hrt, so dass f&uuml;r jedes Element der Matrix 
gilt <code>exp (m[i,j])</code>.  Ansonsten wird die Exponentiation als
<code>exp (<var>ev(M)</var></code> ausgewertet.
</p>

<p><code>domxexpt</code> beeinflu&szlig;t alle Ausdr&uuml;cke der Form <code><var>a</var>^<var>b</var></code>,
wobei <var>a</var> eine Konstante oder ein skalarer Ausdruck und <var>b</var> eine
Liste oder Matrix ist.
</p>
<p>Beispiele:
</p>
<div class="example">
<pre class="example">(%i1) m: matrix ([1, %i], [a+b, %pi]);
                         [   1    %i  ]
(%o1)                    [            ]
                         [ b + a  %pi ]
(%i2) domxexpt: false$
(%i3) (1 - c)^m;
                             [   1    %i  ]
                             [            ]
                             [ b + a  %pi ]
(%o3)                 (1 - c)
(%i4) domxexpt: true$
(%i5) (1 - c)^m;
                  [                      %i  ]
                  [    1 - c      (1 - c)    ]
(%o5)             [                          ]
                  [        b + a         %pi ]
                  [ (1 - c)       (1 - c)    ]
</pre></div>
</dd></dl>

<span id="domxmxops"></span><span id="Item_003a-Matrices_002ede_002fdefvr_002fdomxmxops"></span><dl class="def">
<dt id="index-domxmxops"><span class="category">Optionsvariable: </span><span><strong>domxmxops</strong><a href='#index-domxmxops' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>domxmxops</code> den Wert <code>true</code>, werden allen Matrix-Matrix und 
Matrix-Listen-Operationen ausgef&uuml;hrt.
</p>
</dd></dl>

<span id="domxnctimes"></span><span id="Item_003a-Matrices_002ede_002fdefvr_002fdomxnctimes"></span><dl class="def">
<dt id="index-domxnctimes"><span class="category">Optionsvariable: </span><span><strong>domxnctimes</strong><a href='#index-domxnctimes' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p>Hat <code>domxnctimes</code> den Wert <code>true</code>, werden nichtkommutative Produkte
von Matrizen ausgef&uuml;hrt.
</p>
</dd></dl>

<span id="doscmxops"></span><span id="Item_003a-Matrices_002ede_002fdefvr_002fdoscmxops"></span><dl class="def">
<dt id="index-doscmxops"><span class="category">Optionsvariable: </span><span><strong>doscmxops</strong><a href='#index-doscmxops' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p>Hat <code>doscmxops</code> den Wert <code>true</code>, werden Skalar-Matrix-Operationen
ausgef&uuml;hrt.
</p>
</dd></dl>

<span id="doscmxplus"></span><span id="Item_003a-Matrices_002ede_002fdefvr_002fdoscmxplus"></span><dl class="def">
<dt id="index-doscmxplus"><span class="category">Optionsvariable: </span><span><strong>doscmxplus</strong><a href='#index-doscmxplus' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p>Hat <code>doscmxplus</code> den Wert <code>true</code>, haben Skalar-Matrix-Operationen
eine Matrix als Ergebnis.  Dieser Schalter ist nicht unter <code>doallmxops</code>
subsumiert.
</p>
</dd></dl>

<span id="dot0nscsimp"></span><span id="Item_003a-Matrices_002ede_002fdefvr_002fdot0nscsimp"></span><dl class="def">
<dt id="index-dot0nscsimp"><span class="category">Optionsvariable: </span><span><strong>dot0nscsimp</strong><a href='#index-dot0nscsimp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>dot0nscsimp</code> den Wert <code>true</code>, werden nichtkommutative Produkte
mit einer Null und einem nichtskalaren Term zu einem kommutativen Produkt
vereinfacht.
</p>
</dd></dl>

<span id="dot0simp"></span><span id="Item_003a-Matrices_002ede_002fdefvr_002fdot0simp"></span><dl class="def">
<dt id="index-dot0simp"><span class="category">Optionsvariable: </span><span><strong>dot0simp</strong><a href='#index-dot0simp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>dot0simp</code> den Wert <code>true</code>, werden nichtkommutative Produkte mit
einer Null und einem skalaren Term zu einem kommutatitiven Produkt vereinfacht.
</p>
</dd></dl>

<span id="dot1simp"></span><span id="Item_003a-Matrices_002ede_002fdefvr_002fdot1simp"></span><dl class="def">
<dt id="index-dot1simp"><span class="category">Optionsvariable: </span><span><strong>dot1simp</strong><a href='#index-dot1simp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>dot1simp</code> den Wert <code>true</code>, werden nichtkommutative Produkte mit
einer Eins und einem anderen Term zu einem kommutativen Produkt vereinfacht.
</p>
</dd></dl>

<span id="dotassoc"></span><span id="Item_003a-Matrices_002ede_002fdefvr_002fdotassoc"></span><dl class="def">
<dt id="index-dotassoc"><span class="category">Optionsvariable: </span><span><strong>dotassoc</strong><a href='#index-dotassoc' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>dotassoc</code> den Wert <code>true</code>, vereinfacht Maxima ein Ausdruck
<code>(A.B).C</code> zu <code>A.(B.C)</code>.
</p>
</dd></dl>

<span id="dotconstrules"></span><span id="Item_003a-Matrices_002ede_002fdefvr_002fdotconstrules"></span><dl class="def">
<dt id="index-dotconstrules"><span class="category">Optionsvariable: </span><span><strong>dotconstrules</strong><a href='#index-dotconstrules' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>dotconstrules</code> den Wert <code>true</code>, werden nichtkommutative Produkte
einer Konstanten und eines Termes zu einem kommutativen Produkt vereinfacht.
Die folgenden Optionsvariablen <code>dot0simp</code>, <code>dot0nscsimp</code> und 
<code>dot1simp</code> erhalten den Wert <code>true</code>, wenn <code>construles</code> 
eingeschaltet wird.
</p>
</dd></dl>

<span id="dotdistrib"></span><span id="Item_003a-Matrices_002ede_002fdefvr_002fdotdistrib"></span><dl class="def">
<dt id="index-dotdistrib"><span class="category">Optionsvariable: </span><span><strong>dotdistrib</strong><a href='#index-dotdistrib' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p>Hat <code>dotdistrib</code> den Wert <code>true</code>, vereinfacht Maxima einen Ausdruck
<code>A.(B + C)</code> zu <code>A.B + A.C</code>.
</p>
</dd></dl>

<span id="dotexptsimp"></span><span id="Item_003a-Matrices_002ede_002fdefvr_002fdotexptsimp"></span><dl class="def">
<dt id="index-dotexptsimp"><span class="category">Optionsvariable: </span><span><strong>dotexptsimp</strong><a href='#index-dotexptsimp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>dotexptsimp</code> den Wert <code>true</code>, vereinfacht Maxima einen Ausdruck 
<code>A.A</code> zu <code>A^^2</code>.
</p>
</dd></dl>

<span id="dotident"></span><span id="Item_003a-Matrices_002ede_002fdefvr_002fdotident"></span><dl class="def">
<dt id="index-dotident"><span class="category">Optionsvariable: </span><span><strong>dotident</strong><a href='#index-dotident' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Standardwert: 1
</p>

<p><code>dotident</code> ist der Wert der f&uuml;r den Ausdruck <code>X^^0</code> zur&uuml;ckgegeben 
wird.
</p>
</dd></dl>

<span id="dotscrules"></span><span id="Item_003a-Matrices_002ede_002fdefvr_002fdotscrules"></span><dl class="def">
<dt id="index-dotscrules"><span class="category">Optionsvariable: </span><span><strong>dotscrules</strong><a href='#index-dotscrules' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p>Hat <code>dotscrules</code> den Wert <code>true</code>, vereinfacht Maxima Ausdr&uuml;cke 
<code>A.SC</code> oder <code>SC.A</code> zu <code>SC*A</code> und <code>A.(SC*B)</code> zu 
<code>SC*(A.B)</code>.
</p>
</dd></dl>

<span id="echelon"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fechelon"></span><dl class="def">
<dt id="index-echelon"><span class="category">Funktion: </span><span><strong>echelon</strong> <em>(<var>M</var>)</em><a href='#index-echelon' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Gibt die Matrix <var>m</var> in ihrer Stufenform zur&uuml;ck, wie sie im Gau&szlig;schen
Eliminationsverfahren auftritt.
</p>

<p>Im Unterschied zur Funktion <code>triangularize</code> wird die Matrix so normiert,
dass die Hauptdiagonalelemente den Wert 1 haben.
</p>

<p><code>lu_factor</code> und <code>cholesky</code> sind weitere Funktionen, um 
Dreiecksmatrizen zu erhalten.
</p>
<p>Beispiel:
</p>
<div class="example">
<pre class="example">(%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                       [  3   7  aa  bb ]
                       [                ]
(%o1)                  [ - 1  8  5   2  ]
                       [                ]
                       [  9   2  11  4  ]
(%i2) echelon (M);
</pre><pre class="example">                  [ 1  - 8  - 5      - 2     ]
                  [                          ]
                  [         28       11      ]
                  [ 0   1   --       --      ]
(%o2)             [         37       37      ]
                  [                          ]
                  [              37 bb - 119 ]
                  [ 0   0    1   ----------- ]
                  [              37 aa - 313 ]
</pre></div>
</dd></dl>

<span id="eigenvalues"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002feigenvalues"></span><dl class="def">
<dt id="index-eigenvalues"><span class="category">Funktion: </span><span><strong>eigenvalues</strong> <em>(<var>M</var>)</em><a href='#index-eigenvalues' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="Item_003a-Matrices_002ede_002fdeffn_002feivals"></span></dd><dt id="index-eivals"><span class="category">Funktion: </span><span><strong>eivals</strong> <em>(<var>M</var>)</em><a href='#index-eivals' class='copiable-anchor'> &para;</a></span></dt>
<dd>


<p>Gibt eine Liste mit den Eigenwerten der Matrix <var>M</var> und deren
Multiplizit&auml;ten zur&uuml;ck.  Die erste Teilliste enth&auml;lt die Eigenwerte, die
zweite deren Multiplizit&auml;ten.
</p>

<p><code>eivals</code> ist ein Alias-Name der Funktion <code>eigenvalues</code>.
</p>

<p><code>eigenvalues</code> ruft die Funktion <code>solve</code> auf, um die Nullstellen des
charakeristischen Polynoms der Matrix zu finden.  Wenn <code>solve</code> keine
Nullstellen finden kann, funktionieren einige Funktionen des Pakets nicht.
Dies trifft nicht auf die Funktionen <code>innerproduct</code>, <code>unitvector</code>, 
<code>columnvector</code> und <code>gramschmidt</code> zu.
</p>

<p>Die Eigenwerte, die <code>solve</code> findet, k&ouml;nnen sehr komplizierte Ausdr&uuml;cke 
sein.  Es kann m&ouml;glich sein, solche Ausdr&uuml;cke weiter zu vereinfachen.
</p>

<p>Das Paket <code>eigen</code> wird automatisch geladen, wenn eine der Funktionen
<code>eigenvalues</code> oder <code>eigenvectors</code> aufgerufen wird.
</p>
</dd></dl>

<span id="eigenvectors"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002feigenvectors"></span><dl class="def">
<dt id="index-eigenvectors"><span class="category">Funktion: </span><span><strong>eigenvectors</strong> <em>(<var>M</var>)</em><a href='#index-eigenvectors' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="Item_003a-Matrices_002ede_002fdeffn_002feivects"></span></dd><dt id="index-eivects"><span class="category">Funktion: </span><span><strong>eivects</strong> <em>(<var>M</var>)</em><a href='#index-eivects' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Berechnet die Eigenvektoren der Matrix <var>M</var>.  Die R&uuml;ckgabe ist eine Liste, 
die zwei weitere Listen enth&auml;lt.  Die erste Liste enth&auml;lt die Eigenwerte der
Matrix <var>m</var> und deren Multiplizit&auml;ten.  Die zweite Liste enth&auml;lt die
Eigenvektoren.
</p>

<p><code>eivects</code> ist ein Alias-Name der Funktion <code>eigenvectors</code>.
</p>

<p>Das Paket <code>eigen</code> wird automatisch geladen, wenn die Funktionen
<code>eigenvalues</code> oder <code>eigenvectors</code> aufgerufen werden.
</p>

<p>Folgende Schalter kontrollieren <code>eigenvectors</code>:
</p>
<dl compact="compact">
<dt><span><code>nondiagonalizable</code></span></dt>
<dd><p><code>nondiagonalizabel</code> hat den Wert <code>true</code> oder <code>false</code> nach
R&uuml;ckkehr der Funktion <code>eigenvectros</code> abh&auml;ngig davon, ob die Matrix 
diagonalisierbar ist oder nicht.
</p>

</dd>
<dt><span><code>hermitianmatrix</code></span></dt>
<dd><p>Hat <code>hermitianmatrix</code> den Wert <code>true</code>, werden die entarteten
Eigenvektoren einer Hermitischen Matrix mit dem Gram-Schmidt-Verfahren 
orthogonalisiert.
</p>

</dd>
<dt><span><code>knowneigvals</code></span></dt>
<dd><p>Hat <code>knowneigvals</code> den Wert <code>true</code>, werden die Eigenwerte der Matrix 
von den Funktionen des Paketes <code>eigen</code> als bekannt angenommen.  Die
Eigenwerte sind in diesem Fall in der Liste <code>listeigvals</code> abgespeichert.
Die Liste <code>listeigvals</code> muss dieselbe Form haben, wie die R&uuml;ckgabe der
Funktion <code>eigenvalues</code>.
</p>
</dd>
</dl>


<p>Die Eigenvektoren werden von der Funktion <code>algsys</code> berechnet.  Es ist 
m&ouml;glich, dass <code>algsys</code> die Eigenvektoren nicht findet.  In diesem Fall 
k&ouml;nnen m&ouml;glicherweise zun&auml;chst die Eigenwerte bestimmt und weiter 
vereinfacht werden.  Dannach kann die Funktion <code>eigenvectors</code> mit dem 
Schalter <code>knowneigvals</code> aufgerufen werden.
</p>

<p>Siehe auch <code><a href="#eigenvalues">eigenvalues</a></code>.
</p>
<p>Beispiele:
</p>

<p>Eine Matrix, die einen Eigenvektor zu jedem Eigenwert hat.
</p>
<div class="example">
<pre class="example">(%i1) M1 : matrix ([11, -1], [1, 7]);
                           [ 11  - 1 ]
(%o1)                      [         ]
                           [ 1    7  ]
(%i2) [vals, vecs] : eigenvectors (M1);
(%o2) [[[9 - sqrt(3), sqrt(3) + 9], [1, 1]], 
                        [[[1, sqrt(3) + 2]], [[1, 2 - sqrt(3)]]]]
(%i3) for i thru length (vals[1]) do disp (val[i] = vals[1][i],
  mult[i] = vals[2][i], vec[i] = vecs[i]);
                       val  = 9 - sqrt(3)
                          1

                            mult  = 1
                                1

                    vec  = [[1, sqrt(3) + 2]]
                       1

                       val  = sqrt(3) + 9
                          2

                            mult  = 1
                                2

                    vec  = [[1, 2 - sqrt(3)]]
                       2

(%o3)                         done
</pre></div>


<p>Eine Matrix, die zwei Eigenvektoren zu jedem Eigenwert hat.
</p>
<div class="example">
<pre class="example">(%i1) M1 : matrix([0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 2, 0], 
                  [0, 0, 0, 2]);
</pre><pre class="example">                         [ 0  1  0  0 ]
                         [            ]
                         [ 0  0  0  0 ]
(%o1)                    [            ]
                         [ 0  0  2  0 ]
                         [            ]
                         [ 0  0  0  2 ]
</pre><pre class="example">(%i2) [vals, vecs] : eigenvectors (M1);
(%o2) [[[0, 2], [2, 2]], [[[1, 0, 0, 0]],
                                   [[0, 0, 1, 0], [0, 0, 0, 1]]]]
(%i3) for i thru length (vals[1]) do disp (val[i] = vals[1][i],
  mult[i] = vals[2][i], vec[i] = vecs[i]);
                            val  = 0
                               1

                            mult  = 2
                                1

                      vec  = [[1, 0, 0, 0]]
                         1

                            val  = 2
                               2

                            mult  = 2
                                2

               vec  = [[0, 0, 1, 0], [0, 0, 0, 1]]
                  2

(%o3)                         done
</pre></div>
</dd></dl>

<span id="ematrix"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fematrix"></span><dl class="def">
<dt id="index-ematrix"><span class="category">Funktion: </span><span><strong>ematrix</strong> <em>(<var>m</var>, <var>n</var>, <var>x</var>, <var>i</var>, <var>j</var>)</em><a href='#index-ematrix' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Gibt eine <var>m</var> <code>x</code> <var>n</var>-Matrix zur&uuml;ck, deren Elemente den Wert 0 
haben, bis auf das Element <code>[<var>i</var>, <var>j</var>]</code>, das den Wert <var>x</var> hat.
</p></dd></dl>

<span id="entermatrix"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fentermatrix"></span><dl class="def">
<dt id="index-entermatrix"><span class="category">Funktion: </span><span><strong>entermatrix</strong> <em>(<var>m</var>, <var>n</var>)</em><a href='#index-entermatrix' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Gibt eine <var>m</var> <code>x</code> <var>n</var>-Matrix zur&uuml;ck, die von der Konsole 
eingelesen wird.
</p>

<p>Ist <var>n</var> gleich <var>m</var>, fragt Maxima nach dem Typ der Matrix.  Folgende
Typen k&ouml;nnen angegeben werden: diagonal, symmetric, antisymmetric oder 
allgemein.  Dannach werden die einzelnen Elemente der Matrix abgefragt.
</p>

<p>Sind <var>n</var> und <var>m</var> voneinander verschieden, fragt Maxima nach jedem 
Element der Matrix.
</p>

<p>Die Elemente k&ouml;nnen beliebige Ausdr&uuml;cke sein, die ausgewertet werden.
<code>entermatrix</code> wertet die Argumente aus.
</p>
<p>Beispiel:
</p>
<div class="example">
<pre class="example">(%i1) n: 3$
(%i2) m: entermatrix (n, n)$

Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric 
4. General
Answer 1, 2, 3 or 4 : 
1$
Row 1 Column 1: 
(a+b)^n$
Row 2 Column 2: 
(a+b)^(n+1)$
Row 3 Column 3: 
(a+b)^(n+2)$

Matrix entered.
(%i3) m;
                [        3                     ]
                [ (b + a)      0         0     ]
                [                              ]
(%o3)           [                  4           ]
                [    0      (b + a)      0     ]
                [                              ]
                [                            5 ]
                [    0         0      (b + a)  ]
</pre></div>
</dd></dl>

<span id="express"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fexpress"></span><dl class="def">
<dt id="index-express"><span class="category">Funktion: </span><span><strong>express</strong> <em>(<var>expr</var>)</em><a href='#index-express' class='copiable-anchor'> &para;</a></span></dt>
<dd>


<p>Expandiert Differentialoperatoren in einem Ausdruck in partielle Ableitungen.
<code>express</code> erkennt die Operatoren <code>grad</code>, <code>div</code>, <code>curl</code>, 
<code>laplacian</code> und das Kreuzprodukt <code>~</code>.
</p>

<p>Enth&auml;lt die R&uuml;ckgabe Substantivformen von Ableitungen, k&ouml;nnen diese mit 
der Funktion <code>ev</code> und den Auswertungsschaltern <code>nouns</code> oder 
<code>diff</code> ausgewertet werden.
</p>

<p>Mit dem Kommando <code>load(&quot;vect&quot;)</code> wird die Funktion geladen.
</p>
<p>Beispiele:
</p>
<div class="example">
<pre class="example">(%i1) load (&quot;vect&quot;)$
(%i2) grad (x^2 + y^2 + z^2);
                              2    2    2
(%o2)                  grad (z  + y  + x )
(%i3) express (%);
       d    2    2    2   d    2    2    2   d    2    2    2
(%o3) [-- (z  + y  + x ), -- (z  + y  + x ), -- (z  + y  + x )]
       dx                 dy                 dz
(%i4) ev (%, diff);
(%o4)                    [2 x, 2 y, 2 z]
(%i5) div ([x^2, y^2, z^2]);
                              2   2   2
(%o5)                   div [x , y , z ]
(%i6) express (%);
                   d    2    d    2    d    2
(%o6)              -- (z ) + -- (y ) + -- (x )
                   dz        dy        dx
(%i7) ev (%, diff);
(%o7)                    2 z + 2 y + 2 x
(%i8) curl ([x^2, y^2, z^2]);
                               2   2   2
(%o8)                   curl [x , y , z ]
(%i9) express (%);
       d    2    d    2   d    2    d    2   d    2    d    2
(%o9) [-- (z ) - -- (y ), -- (x ) - -- (z ), -- (y ) - -- (x )]
       dy        dz       dz        dx       dx        dy
(%i10) ev (%, diff);
(%o10)                      [0, 0, 0]
(%i11) laplacian (x^2 * y^2 * z^2);
                                  2  2  2
(%o11)                laplacian (x  y  z )
(%i12) express (%);
         2                2                2
        d     2  2  2    d     2  2  2    d     2  2  2
(%o12)  --- (x  y  z ) + --- (x  y  z ) + --- (x  y  z )
          2                2                2
        dz               dy               dx
(%i13) ev (%, diff);
                      2  2      2  2      2  2
(%o13)             2 y  z  + 2 x  z  + 2 x  y
(%i14) [a, b, c] ~ [x, y, z];
(%o14)                [a, b, c] ~ [x, y, z]
(%i15) express (%);
(%o15)          [b z - c y, c x - a z, a y - b x]
</pre></div>
</dd></dl>

<span id="genmatrix"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fgenmatrix"></span><dl class="def">
<dt id="index-genmatrix"><span class="category">Funktion: </span><span><strong>genmatrix</strong> <em>(<var>a</var>, <var>i_2</var>, <var>j_2</var>, <var>i_1</var>, <var>j_1</var>)</em><a href='#index-genmatrix' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-genmatrix-1"><span class="category">Funktion: </span><span><strong>genmatrix</strong> <em>(<var>a</var>, <var>i_2</var>, <var>j_2</var>, <var>i_1</var>)</em><a href='#index-genmatrix-1' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-genmatrix-2"><span class="category">Funktion: </span><span><strong>genmatrix</strong> <em>(<var>a</var>, <var>i_2</var>, <var>j_2</var>)</em><a href='#index-genmatrix-2' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Generiert eine Matrix aus einem Array <var>a</var>.  Das erste Element der Matrix
ist der Wert <code><var>a</var>[<var>i_1</var>,<var>j_1</var>]</code> und das letzte Element der
Matrix ist <code><var>a</var>[<var>i_2</var>,<var>j_2</var>]</code>.  <var>a</var> muss ein deklariertes
Array sein, dass mit der Funktion <code>array</code> definiert wurde.  Weiterhin kann
<var>a</var> ein undeklariertes Array, eine Array-Funktion oder ein lambda-Ausdruck
mit zwei Argumenten sein.
</p>

<p>Wird <var>j_1</var> nicht angegeben, nimmt Maxima an, das der Wert gleich <var>i_1</var> 
ist.  Werden beide Argumente <var>j_1</var> und <var>i_1</var> nicht angegeben, werden
die Werte zu 1 angenommen.
</p>

<p>Ist eines der Elemente <code>[i,j]</code> des Arrays nicht definiert, enth&auml;lt die
Matrix den symbolischen Wert <code><var>a</var>[i,j]</code>.
</p>
<p>Beispiele:
</p>
<div class="example">
<pre class="example">(%i1) h [i, j] := 1 / (i + j - 1);
</pre><pre class="example">                                    1
(%o1)                  h     := ---------
                        i, j    i + j - 1
</pre><pre class="example">(%i2) genmatrix (h, 3, 3);
                           [    1  1 ]
                           [ 1  -  - ]
                           [    2  3 ]
                           [         ]
                           [ 1  1  1 ]
(%o2)                      [ -  -  - ]
                           [ 2  3  4 ]
                           [         ]
                           [ 1  1  1 ]
                           [ -  -  - ]
                           [ 3  4  5 ]
(%i3) array (a, fixnum, 2, 2);
(%o3)                           a
(%i4) a [1, 1] : %e;
(%o4)                          %e
(%i5) a [2, 2] : %pi;
(%o5)                          %pi
(%i6) genmatrix (a, 2, 2);
                           [ %e   0  ]
(%o6)                      [         ]
                           [ 0   %pi ]
(%i7) genmatrix (lambda ([i, j], j - i), 3, 3);
                         [  0    1   2 ]
                         [             ]
(%o7)                    [ - 1   0   1 ]
                         [             ]
                         [ - 2  - 1  0 ]
(%i8) genmatrix (B, 2, 2);
                        [ B      B     ]
                        [  1, 1   1, 2 ]
(%o8)                   [              ]
                        [ B      B     ]
                        [  2, 1   2, 2 ]
</pre></div>
</dd></dl>

<span id="gramschmidt"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fgramschmidt"></span><dl class="def">
<dt id="index-gramschmidt"><span class="category">Funktion: </span><span><strong>gramschmidt</strong> <em>(<var>x</var>)</em><a href='#index-gramschmidt' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-gramschmidt-1"><span class="category">Funktion: </span><span><strong>gramschmidt</strong> <em>(<var>x</var>, <var>F</var>)</em><a href='#index-gramschmidt-1' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Wendet das Gram-Schmidtsche Orthogonalisierungsverfahren auf das Argument
<var>x</var> an.  <var>x</var> ist eine Matrix oder eine Liste mit Listen f&uuml;r die 
Spalten.  Das Argument <var>x</var> wird von <code>gramschmidt</code> nicht ver&auml;ndert.
<var>F</var> bezeichnet eine Funktion, die als Skalarprodukt f&uuml;r das Verfahren 
verwendet wird.  Wird <var>F</var> nicht angegeben, wird die Funktion 
<code>innerproduct</code> f&uuml;r das Skalarprodukt angewendet.
</p>

<p>Ist <var>x</var> eine Matrix, wird der Algorithmus auf die Zeilen der Matrix
angewendet.  Ist <var>x</var> eine Liste mit Listen, wird der Algorithmus auf die
Teillisten angewendet, die jeweils die gleiche Anzahl an Elementen haben
m&uuml;ssen.
</p>

<p>Jede Stufe des Verfahrens ruft die Funktion <code>factor</code> auf, um die 
Zwischenergebnisse zu vereinfachen.  Dadurch kann das Ergebnis faktorisierte
ganze Zahlen enthalten.
</p>

<p>Das Kommando <code>load(&quot;eigen&quot;)</code> l&auml;dt die Funktion.
</p>
<p>Beispiele:
</p>

<p>Das Gram-Schmidtsche Orthogonalisierungsverfahren mit <code>innerproduct</code> 
als Skalarprodukt.
</p>
<div class="example">
<pre class="example">(%i1) load (&quot;eigen&quot;)$
(%i2) x: matrix ([1, 2, 3], [9, 18, 30], [12, 48, 60]);
                         [ 1   2   3  ]
                         [            ]
(%o2)                    [ 9   18  30 ]
                         [            ]
                         [ 12  48  60 ]
(%i3) y: gramschmidt (x);
                       2      2            4     3
                      3      3   3 5      2  3  2  3
(%o3)  [[1, 2, 3], [- ---, - --, ---], [- ----, ----, 0]]
                      2 7    7   2 7       5     5
(%i4) map (innerproduct, [y[1], y[2], y[3]], [y[2], y[3], y[1]]);
(%o4)                       [0, 0, 0]
</pre></div>


<p>Das Gram-Schmidtsche Orthogonalisierungsverfahren mit einer selbstdefinierten
Funktion f&uuml;r das Skalarprodukt.
</p>
<div class="example">
<pre class="example">(%i1) load (&quot;eigen&quot;)$
(%i2) ip (f, g) := integrate (f * g, u, a, b);
(%o2)          ip(f, g) := integrate(f g, u, a, b)
(%i3) y : gramschmidt([1, sin(u), cos(u)], ip), a=-%pi/2, b=%pi/2;
                               %pi cos(u) - 2
(%o3)              [1, sin(u), --------------]
                                    %pi
(%i4) map(ip,[y[1],y[2],y[3]],[y[2],y[3],y[1]]), a=-%pi/2, b=%pi/2;
(%o4)                       [0, 0, 0]
</pre></div>
</dd></dl>

<span id="ident"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fident"></span><dl class="def">
<dt id="index-ident"><span class="category">Funktion: </span><span><strong>ident</strong> <em>(<var>n</var>)</em><a href='#index-ident' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Gibt eine <var>n</var> <code>x</code> <var>n</var>-Einheitsmatrix zur&uuml;ck.
</p></dd></dl>

<span id="innerproduct"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002finnerproduct"></span><dl class="def">
<dt id="index-innerproduct"><span class="category">Funktion: </span><span><strong>innerproduct</strong> <em>(<var>x</var>, <var>y</var>)</em><a href='#index-innerproduct' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="Item_003a-Matrices_002ede_002fdeffn_002finprod"></span></dd><dt id="index-inprod"><span class="category">Funktion: </span><span><strong>inprod</strong> <em>(<var>x</var>, <var>y</var>)</em><a href='#index-inprod' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Gibt das Skalarprodukt der Argumente <var>x</var> und <var>y</var> zur&uuml;ck.  Die Argument
k&ouml;nnen Listen oder 1-spaltige oder 1-reihige Matrizen sein.  Das Skalarprodukt
wird als <code>conjugate(x) . y</code> berechnet, wobei <code>.</code> der Operator der
nicht-kommutativen Multiplikation ist.
</p>

<p>Das Kommando <code>load(&quot;eigen&quot;)</code> l&auml;dt die Funktion.
</p>

<p><code>inprod</code> ist ein Alias-Name der Funktion <code>innerproduct</code>.
</p>
</dd></dl>


<span id="invert"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002finvert"></span><dl class="def">
<dt id="index-invert"><span class="category">Funktion: </span><span><strong>invert</strong> <em>(<var>M</var>)</em><a href='#index-invert' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Gibt die inverse Matrix der Matrix <var>M</var> zur&uuml;ck.  Die inverse Matrix wird
mittels der Adjunkten Matrix berechnet.
</p>

<p>Mit dieser Methode kann die inverse Matrix auch f&uuml;r gro&szlig;e Gleitkommazahlen
sowie Polynomme als Matrixelemente berechnet werden.
</p>

<p>Die Kofaktoren werden mit der Funktion <code>determinant</code> berechnet.  Hat die
Optionsvariable <code>ratmx</code> den Wert <code>true</code>, wird die inverse Matrix
daher ohne einen Wechsel der Darstellung berechnet.
</p>

<p>Die implementierte Methode ist jedoch ineffizient f&uuml;r gro&szlig;e Matrizen.
</p>

<p>Hat die Optionsvariable <code>detout</code> den Wert <code>true</code>, wird die 
Determinante als Faktor aus der Matrix herausgezogen.
</p>

<p>Die Elemente der inversen Matrix werden nicht automatisch expandiert.  Hat
<var>M</var> Polynome als Elemente, hat das Ergebnis m&ouml;glicherweise mit dem
Kommando <code>expand(invert(m)), detout</code> eine einfachere Form.  Mit der Funktion
<code>multthru</code> die Determinate in die Matrix hereinmultipliziert werden.  Die
inverse Matrix kann auch folgenderma&szlig;en berechnet werden:
</p>
<div class="example">
<pre class="example">expand (adjoint (m)) / expand (determinant (m))
invert (m) := adjoint (m) / determinant (m)
</pre></div>


<p>Siehe auch den Operator <code>^^</code> der nicht-kommutativen Exponentiation f&uuml;r 
eine andere Methode zur Berechnung der inversen Matrix.
</p>
</dd></dl>

<span id="Item_003a-Matrices_002ede_002fdefvr_002flmxchar"></span><dl class="def">
<dt id="index-lmxchar"><span class="category">Optionsvariable: </span><span><strong>lmxchar</strong><a href='#index-lmxchar' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Standardwert: <code>[</code>
</p>

<p><code>lmxchar</code> ist das Zeichen, das f&uuml;r die linke Seite einer Matrix 
ausgegeben wird.  Siehe auch <code>rmxchar</code>.
</p>
<p>Beispiel:
</p>
<div class="example">
<pre class="example">(%i1) lmxchar: &quot;|&quot;$
(%i2) matrix ([a, b, c], [d, e, f], [g, h, i]);
                           | a  b  c ]
                           |         ]
(%o2)                      | d  e  f ]
                           |         ]
                           | g  h  i ]
</pre></div>
</dd></dl>

<span id="matrix"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fmatrix"></span><dl class="def">
<dt id="index-matrix"><span class="category">Funktion: </span><span><strong>matrix</strong> <em>(<var>row_1</var>, &hellip;, <var>row_n</var>)</em><a href='#index-matrix' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Gibt eine Matrix mit den Spalten <var>row_1</var>, &hellip;, <var>row_n</var> zur&uuml;ck.
Jede Spalte ist eine Liste mit Asudr&uuml;cken.  Alle Spalten m&uuml;ssen die gleiche
L&auml;nge haben.
</p>

<p>Die Addition <code>+</code>, Subtraktion <code>-</code>, Multiplikation <code>*</code> und 
Division <code>/</code> werden elementweise ausgef&uuml;hrt, wenn die Argumente zwei 
Matrizen, ein Skalar und eine Matrix oder eine Matrix und ein Skalar sind.
Die Exponentiation <code>^</code> wird elementweise ausgef&uuml;hrt, wenn die Argumente
ein Skalar und eine Matrix oder umgekehrt sind.
</p>

<p>Die nichtkommutatie Multiplikation von Matrizen wird mit dem Operator <code>.</code>
ausgef&uuml;hrt.  Der entsprechende Operator f&uuml;r die nichtkommutative 
Exponentiation ist <code>^^</code>. F&uuml;r eine Matrix <code><var>A</var></code> ist 
<code><var>A</var> . <var>A</var> = <var>A</var>^^2</code>. <code><var>A</var>^^-1</code> ist die inverse 
Matrix, falls diese existiert.
</p>

<p>Folgende Schalter kontrollieren die Vereinfachung von Ausdr&uuml;cken, welche die
nichtkommutative Multiplikation und Matrizen enthalten:
</p>
<p><code>doallmxops</code>,
<code>domxexpt</code>,
<code>domxmxops</code>, 
<code>doscmxops</code> und 
<code>doscmxplus</code>.
</p>

<p>Weitere Optionsvariablen f&uuml;r Matrizen sind:
</p>
<p><code>lmxchar</code>, 
<code>rmxchar</code>, 
<code>ratmx</code>, 
<code>listarith</code>, 
<code>detout</code>,
<code>scalarmatrix</code> und
<code>sparse</code>.
</p>

<p>Folgende Funktionen akzeptieren Matrizen als ein Argument oder haben eine 
Matrix als R&uuml;ckgabewert: 
</p>
<p><code>eigenvalues</code>, 
<code>eigenvectors</code>,
<code>determinant</code>,
<code>charpoly</code>, 
<code>genmatrix</code>, 
<code>addcol</code>, 
<code>addrow</code>, 
<code>copymatrix</code>, 
<code>transpose</code>, 
<code>echelon</code> and
<code>rank</code>.
</p>
<p>Beispiele:
</p>

<p>Konstruiere eine Matrix mit Listen.
</p>
<div class="example">
<pre class="example">(%i1) x: matrix ([17, 3], [-8, 11]);
                           [ 17   3  ]
(%o1)                      [         ]
                           [ - 8  11 ]
(%i2) y: matrix ([%pi, %e], [a, b]);
                           [ %pi  %e ]
(%o2)                      [         ]
                           [  a   b  ]
</pre></div>


<p>Elementweise Addition zweier Matrizen.
</p>
<div class="example">
<pre class="example">(%i3) x + y;
                      [ %pi + 17  %e + 3 ]
(%o3)                 [                  ]
                      [  a - 8    b + 11 ]
</pre></div>


<p>Elementweise Subtraktion zweier Matrizen.
</p>
<div class="example">
<pre class="example">(%i4) x - y;
                      [ 17 - %pi  3 - %e ]
(%o4)                 [                  ]
                      [ - a - 8   11 - b ]
</pre></div>


<p>Elementweise Multiplikation zweier Matrizen.
</p>
<div class="example">
<pre class="example">(%i5) x * y;
                        [ 17 %pi  3 %e ]
(%o5)                   [              ]
                        [ - 8 a   11 b ]
</pre></div>


<p>Elementweise Division zweier Matrizen.
</p>
<div class="example">
<pre class="example">(%i6) x / y;
                        [ 17       - 1 ]
                        [ ---  3 %e    ]
                        [ %pi          ]
(%o6)                   [              ]
                        [   8    11    ]
                        [ - -    --    ]
                        [   a    b     ]
</pre></div>


<p>Elementweise Exponentiation einer Matrix mit einem Skalar.
</p>
<div class="example">
<pre class="example">(%i7) x ^ 3;
                         [ 4913    27  ]
(%o7)                    [             ]
                         [ - 512  1331 ]
</pre></div>


<p>Elementweise Exponentiation eines Skalars mit einer Matrix.
</p>
<div class="example">
<pre class="example">(%i8) exp(y); 
                         [   %pi    %e ]
                         [ %e     %e   ]
(%o8)                    [             ]
                         [    a     b  ]
                         [  %e    %e   ]
</pre></div>


<p>Die Exponentiation zweier Matrizen wird nicht elementweise ausgef&uuml;hrt.
</p>
<div class="example">
<pre class="example">(%i9) x ^ y;
                                [ %pi  %e ]
                                [         ]
                                [  a   b  ]
                     [ 17   3  ]
(%o9)                [         ]
                     [ - 8  11 ]
</pre></div>


<p>Nichtkommutative Multiplikation zweier Matrizen.
</p>
<div class="example">
<pre class="example">(%i10) x . y;
                  [ 3 a + 17 %pi  3 b + 17 %e ]
(%o10)            [                           ]
                  [ 11 a - 8 %pi  11 b - 8 %e ]
(%i11) y . x;
                [ 17 %pi - 8 %e  3 %pi + 11 %e ]
(%o11)          [                              ]
                [  17 a - 8 b     11 b + 3 a   ]
</pre></div>


<p>Nichtkommutative Exponentiation einer Matrix.  Ist die Basis ein Skalar wird die
Exponentiation elementweise ausgef&uuml;hrt.  Daher haben die Operationen <code>^^</code>
und <code>^</code> f&uuml;r diesen Fall dasselbe Ergebnis.
</p>
<div class="example">
<pre class="example">(%i12) x ^^ 3;
                        [  3833   1719 ]
(%o12)                  [              ]
                        [ - 4584  395  ]
(%i13) %e ^^ y;
                         [   %pi    %e ]
                         [ %e     %e   ]
(%o13)                   [             ]
                         [    a     b  ]
                         [  %e    %e   ]
</pre></div>


<p>Berechnung der inversen Matrix mit <code>x^^-1</code>.
</p>
<div class="example">
<pre class="example">(%i14) x ^^ -1;
</pre><pre class="example">                         [ 11      3  ]
                         [ ---  - --- ]
                         [ 211    211 ]
(%o14)                   [            ]
                         [  8    17   ]
                         [ ---   ---  ]
                         [ 211   211  ]
</pre><pre class="example">(%i15) x . (x ^^ -1);
                            [ 1  0 ]
(%o15)                      [      ]
                            [ 0  1 ]
</pre></div>
</dd></dl>

<span id="matrixmap"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fmatrixmap"></span><dl class="def">
<dt id="index-matrixmap"><span class="category">Funktion: </span><span><strong>matrixmap</strong> <em>(<var>f</var>, <var>M</var>)</em><a href='#index-matrixmap' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Gibt eine Matrix mit den Elementen <code>[i,j]</code> zur&uuml;ck, die mit
<code><var>f</var>(<var>M</var>[i,j])</code> berechnet werden.
</p>

<p>Siehe auch <code>map</code>, <code>fullmap</code>, <code>fullmapl</code>, and <code>apply</code>.
</p>
</dd></dl>

<span id="matrixp"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fmatrixp"></span><dl class="def">
<dt id="index-matrixp"><span class="category">Funktion: </span><span><strong>matrixp</strong> <em>(<var>expr</var>)</em><a href='#index-matrixp' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Gibt <code>true</code> zur&uuml;ck, wenn <var>expr</var> eine Matrix ist.  Ansonsten wird
<code>false</code> zur&uuml;ckgegeben.
</p></dd></dl>

<span id="matrix_005felement_005fadd"></span><span id="Item_003a-Matrices_002ede_002fdefvr_002fmatrix_005felement_005fadd"></span><dl class="def">
<dt id="index-matrix_005felement_005fadd"><span class="category">Optionsvariable: </span><span><strong>matrix_element_add</strong><a href='#index-matrix_005felement_005fadd' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Standardwert: <code>+</code>
</p>

<p><code>matrix_element_add</code> enth&auml;lt die Operation f&uuml;r die Ausf&uuml;hrung der
Addition von Matrizen.  Der Optionsvariablen <code>matrix_element_add</code> kann
ein N-Ary-Operator zugewiesen werden.  Der zugewiesene Wert kann der Name
eines Operators, einer Funktion oder ein Lambda-Ausdruck sein.
</p>

<p>Siehe auch <code>matrix_element_mult</code> und <code>matrix_element_transpose</code>.
</p>
<p>Beispiele:
</p>
<div class="example">
<pre class="example">(%i1) matrix_element_add: &quot;*&quot;$
(%i2) matrix_element_mult: &quot;^&quot;$
(%i3) aa: matrix ([a, b, c], [d, e, f]);
                           [ a  b  c ]
(%o3)                      [         ]
                           [ d  e  f ]
(%i4) bb: matrix ([u, v, w], [x, y, z]);
                           [ u  v  w ]
(%o4)                      [         ]
                           [ x  y  z ]
(%i5) aa . transpose (bb);
                     [  u  v  w   x  y  z ]
                     [ a  b  c   a  b  c  ]
(%o5)                [                    ]
                     [  u  v  w   x  y  z ]
                     [ d  e  f   d  e  f  ]
</pre></div>
</dd></dl>

<span id="matrix_005felement_005fmult"></span><span id="Item_003a-Matrices_002ede_002fdefvr_002fmatrix_005felement_005fmult"></span><dl class="def">
<dt id="index-matrix_005felement_005fmult"><span class="category">Optionsvariable: </span><span><strong>matrix_element_mult</strong><a href='#index-matrix_005felement_005fmult' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Standardwert: <code>*</code>
</p>

<p><code>matrix_element_mult</code> enth&auml;lt die Operation f&uuml;r die Ausf&uuml;hrung der
Multiplikation von Matrizen.  Der Optionsvariablen <code>matrix_element_mult</code> 
kann ein bin&auml;rer Operator zugewiesen werden.  Der zugewiesene Wert kann der 
Name eines Operators, einer Funktion oder ein Lambda-Ausdruck sein.
</p>

<p>Der nichtkommutative Operator <code>.</code> kann eine sinnvolle Alternative sein.
</p>

<p>Siehe auch <code>matrix_element_add</code> und <code>matrix_element_transpose</code>.
</p>
<p>Beispiele:
</p>
<div class="example">
<pre class="example">(%i1) matrix_element_add: lambda ([[x]], sqrt (apply (&quot;+&quot;, x)))$
(%i2) matrix_element_mult: lambda ([x, y], (x - y)^2)$
(%i3) [a, b, c] . [x, y, z];
                          2          2          2
(%o3)         sqrt((c - z)  + (b - y)  + (a - x) )
(%i4) aa: matrix ([a, b, c], [d, e, f]);
                           [ a  b  c ]
(%o4)                      [         ]
                           [ d  e  f ]
(%i5) bb: matrix ([u, v, w], [x, y, z]);
                           [ u  v  w ]
(%o5)                      [         ]
                           [ x  y  z ]
(%i6) aa . transpose (bb);
               [             2          2          2  ]
               [ sqrt((c - w)  + (b - v)  + (a - u) ) ]
(%o6)  Col 1 = [                                      ]
               [             2          2          2  ]
               [ sqrt((f - w)  + (e - v)  + (d - u) ) ]

                         [             2          2          2  ]
                         [ sqrt((c - z)  + (b - y)  + (a - x) ) ]
                 Col 2 = [                                      ]
                         [             2          2          2  ]
                         [ sqrt((f - z)  + (e - y)  + (d - x) ) ]
</pre></div>
</dd></dl>

<span id="matrix_005felement_005ftranspose"></span><span id="Item_003a-Matrices_002ede_002fdefvr_002fmatrix_005felement_005ftranspose"></span><dl class="def">
<dt id="index-matrix_005felement_005ftranspose"><span class="category">Optionsvariable: </span><span><strong>matrix_element_transpose</strong><a href='#index-matrix_005felement_005ftranspose' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p><code>matrix_element_transpose</code> enth&auml;lt die Operation f&uuml;r die Ausf&uuml;hrung 
der Transponierung einer Matrix.  Der Optionsvariablen
<code>matrix_element_mult</code> kann ein un&auml;rer Operator zugewiesen werden.  Der 
zugewiesene Wert kann der Name eines Operators, einer Funktion oder ein
Lambda-Ausdruck sein.
</p>

<p>Hat <code>matrix_element_transpose</code> den Wert <code>transpose</code>, wird die 
Funktion <code>transpose</code> auf jedes Element der Matrix angewendet.  Hat
<code>matrix_element_transpose</code> den Wert <code>nonscalars</code>, wird die Funktion
<code>transpose</code> auf nichtskalare Elemente der Matrix angewendet.  Ist eines
der Elemente ein Atom, muss in diesem Fall das Atom als <code>nonscalar</code>
deklariert sein.
</p>

<p>Mit dem Standardwert <code>false</code> wird keine Operation angewendet.
</p>

<p>Siehe auch <code>matrix_element_add</code> und <code>matrix_element_mult</code>.
</p>
<p>Beispiele:
</p>
<div class="example">
<pre class="example">(%i1) declare (a, nonscalar)$
(%i2) transpose ([a, b]);
                        [ transpose(a) ]
(%o2)                   [              ]
                        [      b       ]
(%i3) matrix_element_transpose: nonscalars$
(%i4) transpose ([a, b]);
                        [ transpose(a) ]
(%o4)                   [              ]
                        [      b       ]
(%i5) matrix_element_transpose: transpose$
(%i6) transpose ([a, b]);
                        [ transpose(a) ]
(%o6)                   [              ]
                        [ transpose(b) ]
(%i7) matrix_element_transpose: lambda ([x], realpart(x)
      - %i*imagpart(x))$
(%i8) m: matrix ([1 + 5*%i, 3 - 2*%i], [7*%i, 11]);
                     [ 5 %i + 1  3 - 2 %i ]
(%o8)                [                    ]
                     [   7 %i       11    ]
(%i9) transpose (m);
                      [ 1 - 5 %i  - 7 %i ]
(%o9)                 [                  ]
                      [ 2 %i + 3    11   ]
</pre></div>
</dd></dl>


<span id="mattrace"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fmattrace"></span><dl class="def">
<dt id="index-mattrace"><span class="category">Funktion: </span><span><strong>mattrace</strong> <em>(<var>M</var>)</em><a href='#index-mattrace' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Gibt die Spur einer quadratischen Matrix <var>M</var> zur&uuml;ck.
</p>
</dd></dl>

<span id="minor"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fminor"></span><dl class="def">
<dt id="index-minor"><span class="category">Funktion: </span><span><strong>minor</strong> <em>(<var>M</var>, <var>i</var>, <var>j</var>)</em><a href='#index-minor' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Gibt den Minor zu <var>i</var>, <var>j</var> der Matrix <var>M</var> zur&uuml;ck.  Die Matrix
entsteht durch Streichen der <var>i</var>-ten Spalte und <var>j</var>-ten Zeile.
</p></dd></dl>

<span id="ncharpoly"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fncharpoly"></span><dl class="def">
<dt id="index-ncharpoly"><span class="category">Funktion: </span><span><strong>ncharpoly</strong> <em>(<var>M</var>, <var>x</var>)</em><a href='#index-ncharpoly' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Gibt das charakteristische Polynom der Matrix <var>M</var> f&uuml;r die Variable <var>x</var>
zur&uuml;ck.  Diese Funktion ist eine Alternative zur Funktion <code>charpoly</code>.
</p>

<p>Der Algorithmus von <code>ncharpoly</code> ist vorteilhaft gegen&uuml;ber 
<code>charpoly</code>, wenn gro&szlig;e und d&uuml;nn besetzte Matrizen vorliegen.  Das 
Kommando <code>load(&quot;nchrpl&quot;)</code> l&auml;dt die Funktion.
</p></dd></dl>

<span id="newdet"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fnewdet"></span><dl class="def">
<dt id="index-newdet"><span class="category">Funktion: </span><span><strong>newdet</strong> <em>(<var>M</var>, <var>n</var>)</em><a href='#index-newdet' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Berechnet die Determinate der Matrix oder eines Arrays <var>M</var> mit dem
Johnson-Gentleman-Algorithmus.  Das Argument <var>n</var> ist die Ordnung.  F&uuml;r
eine Matrix ist <var>n</var> ein optionales Argument.
</p></dd></dl>

<span id="permanent"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fpermanent"></span><dl class="def">
<dt id="index-permanent"><span class="category">Funktion: </span><span><strong>permanent</strong> <em>(<var>M</var>, <var>n</var>)</em><a href='#index-permanent' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Berechnet die Permanente der Matrix <var>M</var>.  Die Permanente ist &auml;hnlich der
Determinate, aber es fehlen die Vorzeichenwechsel.
</p></dd></dl>

<span id="rank"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002frank"></span><dl class="def">
<dt id="index-rank"><span class="category">Funktion: </span><span><strong>rank</strong> <em>(<var>M</var>)</em><a href='#index-rank' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Berechnet den Rang der Matrix <var>M</var>.
</p>

<p><var>rank</var> kann ein falsches Ergebnis geben, wenn ein Element &auml;quivalent
zu Null ist, dies aber nicht von Maxima festgestellt werden kann.
</p></dd></dl>

<span id="potenial"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fpotential"></span><dl class="def">
<dt id="index-potential"><span class="category">Funktion: </span><span><strong>potential</strong> <em>(<var>givengradient</var>)</em><a href='#index-potential' class='copiable-anchor'> &para;</a></span></dt>
<dd>
<p>The calculation makes use of the global variable <code>potentialzeroloc[0]</code>
which must be <code>nonlist</code> or of the form
</p>
<div class="example">
<pre class="example">[indeterminatej=expressionj, indeterminatek=expressionk, ...]
</pre></div>

<p>the former being equivalent to the nonlist expression for all right-hand 
sides in the latter.  The indicated right-hand sides are used as the lower 
limit of integration.  The success of the integrations may depend upon their 
values and order.  <code>potentialzeroloc</code> is initially set to 0.
</p></dd></dl>

<span id="ratmx"></span><span id="Item_003a-Matrices_002ede_002fdefvr_002fratmx"></span><dl class="def">
<dt id="index-ratmx"><span class="category">Optionsvariable: </span><span><strong>ratmx</strong><a href='#index-ratmx' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p>Hat <code>ratmx</code> den Wert <code>false</code>, werden die Berechnung einer Determinante
sowie die Operationen der Addition, Subtraktion und Multiplikation in der
allgemeinen Darstellung ausgef&uuml;hrt.  Das Ergebnis ist wieder eine allgemeine
Darstellung.
</p>

<p>Hat <code>ratmx</code> den Wert <code>true</code>, werden die oben genannten Operationen
in einer CRE-Darstellung ausgef&uuml;hrt un das Ergebnis ist in einer 
CRE-Darstellung.
</p></dd></dl>

<span id="rmxchar"></span><span id="Item_003a-Matrices_002ede_002fdefvr_002frmxchar"></span><dl class="def">
<dt id="index-rmxchar"><span class="category">Optionsvariable: </span><span><strong>rmxchar</strong><a href='#index-rmxchar' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Standardwert: <code>]</code>
</p>

<p><code>rmxchar</code> ist das Zeichen, das f&uuml;r die rechte Seite einer Matrix 
ausgegeben wird.  Siehe auch <code>lmxchar</code>.
</p></dd></dl>

<span id="row"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002frow"></span><dl class="def">
<dt id="index-row"><span class="category">Funktion: </span><span><strong>row</strong> <em>(<var>M</var>, <var>i</var>)</em><a href='#index-row' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Gibt die <var>i</var>-te Spalte der Matrix <var>M</var> zur&uuml;ck.  Der R&uuml;ckgabewert ist 
eine Matrix.
</p></dd></dl>

<span id="scalarmatrixp"></span><span id="Item_003a-Matrices_002ede_002fdefvr_002fscalarmatrixp"></span><dl class="def">
<dt id="index-scalarmatrixp"><span class="category">Optionsvariable: </span><span><strong>scalarmatrixp</strong><a href='#index-scalarmatrixp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>scalarmatrixp</code> den Wert <code>true</code>, dann werden 1 x 1-Matrizen, die
als Ergebnis einer nicht-kommutativen Multiplikation auftreten, zu einem
Skalar vereinfacht.
</p>

<p>Hat <code>scalarmatrixp</code> den Wert <code>all</code>, dann werden alle 1 x 1-Matrizen
zu einem Skalar vereinfacht.
</p>

<p>Hat <code>scalarmatrixp</code> den Wert <code>false</code>, werden 1 x 1-Matrizen nicht zu
einem Skalar vereinfacht.
</p></dd></dl>


<span id="Item_003a-Matrices_002ede_002fdeffn_002fscalefactors"></span><dl class="def">
<dt id="index-scalefactors"><span class="category">Funktion: </span><span><strong>scalefactors</strong> <em>(<var>coordinatetransform</var>)</em><a href='#index-scalefactors' class='copiable-anchor'> &para;</a></span></dt>
<dd>
<p>Here coordinatetransform evaluates to the form [[expression1, expression2,
&hellip;], indeterminate1, indeterminat2, &hellip;], where indeterminate1, 
indeterminate2, etc. are the curvilinear coordinate variables and where a set of
rectangular Cartesian components is given in terms of the curvilinear
coordinates by [expression1, expression2, &hellip;].  <code>coordinates</code> is set
to the vector [indeterminate1, indeterminate2, &hellip;], and <code>dimension</code> is 
set to the length of this vector.  SF[1], SF[2], &hellip;, SF[DIMENSION] are set
to the coordinate scale factors, and <code>sfprod</code> is set to the product of
these scale factors.  Initially, <code>coordinates</code> is [X, Y, Z],
<code>dimension</code> is 3, and SF[1]=SF[2]=SF[3]=SFPROD=1, corresponding to 
3-dimensional rectangular Cartesian coordinates.  To expand an expression into 
physical components in the current coordinate system, there is a function with 
usage of the form
</p></dd></dl>

<span id="setelmx"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fsetelmx"></span><dl class="def">
<dt id="index-setelmx"><span class="category">Funktion: </span><span><strong>setelmx</strong> <em>(<var>x</var>, <var>i</var>, <var>j</var>, <var>M</var>)</em><a href='#index-setelmx' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Weist <var>x</var> dem Matrixelement <code>[<var>i</var>,<var>j</var>]</code> zu und gibt die
modifizierte Matrix zur&uuml;ck.
</p>

<p><code><var>M</var>[<var>i</var>, <var>j</var>]: <var>x</var></code> hat denselben Effekt.  In diesem Fall
wird jedoch der Wert <var>x</var> zur&uuml;ckgeben und nicht die Matrix.
</p></dd></dl>

<span id="similaritytransform"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fsimilaritytransform"></span><dl class="def">
<dt id="index-similaritytransform"><span class="category">Funktion: </span><span><strong>similaritytransform</strong> <em>(<var>M</var>)</em><a href='#index-similaritytransform' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="Item_003a-Matrices_002ede_002fdeffn_002fsimtran"></span></dd><dt id="index-simtran"><span class="category">Funktion: </span><span><strong>simtran</strong> <em>(<var>M</var>)</em><a href='#index-simtran' class='copiable-anchor'> &para;</a></span></dt>
<dd>
<p><code>similaritytransform</code> computes a similarity transform of the matrix 
<code>M</code>.  It returns a list which is the output of the <code>uniteigenvectors</code>
command.  In addition if the flag <code>nondiagonalizable</code> is <code>false</code> two 
global matrices <code>leftmatrix</code> and <code>rightmatrix</code> are computed.  These 
matrices have the property that <code>leftmatrix . <var>M</var> . rightmatrix</code> is a 
diagonal matrix with the eigenvalues of <var>M</var> on the diagonal.  If 
<code>nondiagonalizable</code> is <code>true</code> the left and right matrices are not 
computed.
</p>
<p>If the flag <code>hermitianmatrix</code> is <code>true</code> then <code>leftmatrix</code> is the 
complex conjugate of the transpose of <code>rightmatrix</code>.  Otherwise 
<code>leftmatrix</code> is the inverse of <code>rightmatrix</code>.
</p>
<p><code>rightmatrix</code> is the matrix the columns of which are the unit eigenvectors 
of <var>M</var>.  The other flags (see <code>eigenvalues</code> and <code>eigenvectors</code>) 
have the same effects since <code>similaritytransform</code> calls the other functions
in the package in order to be able to form <code>rightmatrix</code>.
</p>
<p><code>load (&quot;eigen&quot;)</code> loads this function.
</p>
<p><code>simtran</code> is a synonym for <code>similaritytransform</code>.
</p></dd></dl>

<span id="sparse"></span><span id="Item_003a-Matrices_002ede_002fdefvr_002fsparse"></span><dl class="def">
<dt id="index-sparse"><span class="category">Optionsvariable: </span><span><strong>sparse</strong><a href='#index-sparse' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p>Haben <code>sparse</code> und <code>ratmx</code> den Wert <code>true</code>, verwendet die 
Funktion <code>determinant</code> einen speziellen Algorithmus f&uuml;r d&uuml;nn besetzte
Matrizen, um die Determinante einer Matrix zu berechnen.
</p></dd></dl>

<span id="submatrix"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fsubmatrix"></span><dl class="def">
<dt id="index-submatrix"><span class="category">Funktion: </span><span><strong>submatrix</strong> <em>(<var>i_1</var>, &hellip;, <var>i_m</var>, <var>M</var>, <var>j_1</var>, &hellip;, <var>j_n</var>)</em><a href='#index-submatrix' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-submatrix-1"><span class="category">Funktion: </span><span><strong>submatrix</strong> <em>(<var>i_1</var>, &hellip;, <var>i_m</var>, <var>M</var>)</em><a href='#index-submatrix-1' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-submatrix-2"><span class="category">Funktion: </span><span><strong>submatrix</strong> <em>(<var>M</var>, <var>j_1</var>, &hellip;, <var>j_n</var>)</em><a href='#index-submatrix-2' class='copiable-anchor'> &para;</a></span></dt>
<dd>
<p>Gibt eine Kopie der Matrix <var>M</var> zur&uuml;ck, in der die Zeilen 
<var>i_1</var>, &hellip;, <var>i_m</var> und Spalten <var>j_1</var>, &hellip;, <var>j_n</var> 
nicht enthalten sind.
</p></dd></dl>

<span id="transpose"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002ftranspose"></span><dl class="def">
<dt id="index-transpose"><span class="category">Funktion: </span><span><strong>transpose</strong> <em>(<var>M</var>)</em><a href='#index-transpose' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Gibt die Transponierte der Matrix <var>M</var> zur&uuml;ck.
</p>

<p>Ist <var>M</var> eine Matrix, ist das Ergebnis eine Matrix <var>N</var> mit den 
Elementen <code>N[i,j] = M[j,i]</code>.
</p>

<p>Ist <var>M</var> eine Liste, ist die R&uuml;ckgabe eine Matrix <var>N</var> mit
<code>length(M)</code> Spalten und einer Zeile.  Die Elemente sind 
<code>N[i,1] = M[i]</code>.
</p>

<p>Ansonsten wird eine Substantivform <code>'transpose(<var>M</var>)</code> zur&uuml;ckgegeben.
</p></dd></dl>

<span id="triangularize"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002ftriangularize"></span><dl class="def">
<dt id="index-triangularize"><span class="category">Funktion: </span><span><strong>triangularize</strong> <em>(<var>M</var>)</em><a href='#index-triangularize' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Gibt die obere Dreiecksmatrix f&uuml;r die Matrix <code>M</code> zur&uuml;ck, wie sie mit 
dem Gau&szlig;schen Eliminationsverfahren berechnet wird.  Die Dreiecksmatrix 
entspricht der R&uuml;ckgabe der Funktion <code>echelon</code> mit dem Unterschied, dass 
die Elemente auf der Diagonalen nicht zu 1 normalisiert sind.
</p>

<p>Mit den Funktionen <code>lu_factor</code> und <code>cholesky</code> kann ebenfalls eine
Matrix in die Dreiecksform transformiert werden.
</p>
<p>Beispiel:
</p>
<div class="example">
<pre class="example">(%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                       [  3   7  aa  bb ]
                       [                ]
(%o1)                  [ - 1  8  5   2  ]
                       [                ]
                       [  9   2  11  4  ]
(%i2) triangularize (M);
             [ - 1   8         5            2      ]
             [                                     ]
(%o2)        [  0   - 74     - 56         - 22     ]
             [                                     ]
             [  0    0    626 - 74 aa  238 - 74 bb ]
</pre></div>
</dd></dl>

<span id="uniteigenvectors"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002funiteigenvectors"></span><dl class="def">
<dt id="index-uniteigenvectors"><span class="category">Funktion: </span><span><strong>uniteigenvectors</strong> <em>(<var>M</var>)</em><a href='#index-uniteigenvectors' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="Item_003a-Matrices_002ede_002fdeffn_002fueivects"></span></dd><dt id="index-ueivects"><span class="category">Funktion: </span><span><strong>ueivects</strong> <em>(<var>M</var>)</em><a href='#index-ueivects' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Berechnet die Einheitsvektoren der Matrix <var>M</var>.  Die R&uuml;ckgabe ist eine 
Liste, die zwei weitere Listen enth&auml;lt.  Die erste Liste enth&auml;lt die 
Eigenwerte der Matrix <var>M</var> und deren Multiplizit&auml;ten.  Die zweite Liste 
enth&auml;lt die Einheitsvektoren.
</p>
<p>Ansonsten entspricht <code>uniteigenvectors</code> der Funktion <code>eigenvectors</code>.
</p>




<p>Das Kommando <code>load(&quot;eigen&quot;)</code> l&auml;dt die Funktion.
</p>

<p><code>ueivects</code> ist ein Alias-Name der Funkion <code>uniteigenvectors</code>.
</p></dd></dl>

<span id="unitvector"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002funitvector"></span><dl class="def">
<dt id="index-unitvector"><span class="category">Funktion: </span><span><strong>unitvector</strong> <em>(<var>x</var>)</em><a href='#index-unitvector' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="Item_003a-Matrices_002ede_002fdeffn_002fuvect"></span></dd><dt id="index-uvect"><span class="category">Funktion: </span><span><strong>uvect</strong> <em>(<var>x</var>)</em><a href='#index-uvect' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Gibt den Einheitsvektor <em class='math'><var>x</var>/norm(<var>x</var>)</em> zur&uuml;ck.
</p>

<p>Das Kommando <code>load(&quot;eigen&quot;)</code> l&auml;dt die Funktion.
</p>

<p><code>uvect</code> ist ein Alias-Name der Funktion <code>unitvector</code>.
</p></dd></dl>

<span id="vectorpotential"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fvectorpotential"></span><dl class="def">
<dt id="index-vectorpotential"><span class="category">Funktion: </span><span><strong>vectorpotential</strong> <em>(<var>givencurl</var>)</em><a href='#index-vectorpotential' class='copiable-anchor'> &para;</a></span></dt>
<dd>
<p>Returns the vector potential of a given curl vector, in the current 
coordinate system.  <code>potentialzeroloc</code> has a similar role as for 
<code>potential</code>, but the order of the left-hand sides of the equations must 
be a cyclic permutation of the coordinate variables.
</p></dd></dl>


<span id="vectorsimp"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fvectorsimp"></span><dl class="def">
<dt id="index-vectorsimp"><span class="category">Funktion: </span><span><strong>vectorsimp</strong> <em>(<var>expr</var>)</em><a href='#index-vectorsimp' class='copiable-anchor'> &para;</a></span></dt>
<dd>
<p>Applies simplifications and expansions according to the following global flags:
</p>
<pre class="verbatim">expandall         expanddot             expanddotplus
expandcross       expandcrossplus       expandcrosscross
expandgrad        expandgradplus        expandgradprod
expanddiv         expanddivplus         expanddivprod
expandcurl        expandcurlplus        expandcurlcurl 
expandlaplacian   expandlaplacianplus   expandlaplacianprod
</pre>
<p>All these flags have default value <code>false</code>.  The <code>plus</code> suffix refers
to employing additivity or distributivity.  The <code>prod</code> suffix refers to 
the expansion for an operand that is any kind of product.
</p>
<dl compact="compact">
<dt><span><code>expandcrosscross</code></span></dt>
<dd><p>Simplifies <code>p ~ (q ~ r)</code> to <code>(p . r)*q - (p . q)*r</code>.
</p>
</dd>
<dt><span><code>expandcurlcurl</code></span></dt>
<dd><p>Simplifies <code>curl curl p</code> to <code>grad div p + div grad p</code>.
</p>
</dd>
<dt><span><code>expandlaplaciantodivgrad</code></span></dt>
<dd><p>Simplifies <code>laplacian p</code> to <code>div grad p</code>.
</p>
</dd>
<dt><span><code>expandcross</code></span></dt>
<dd><p>Enables <code>expandcrossplus</code> and <code>expandcrosscross</code>.
</p>
</dd>
<dt><span><code>expandplus</code></span></dt>
<dd><p align="left">Enables <code>expanddotplus</code>, <code>expandcrossplus</code>, <code>expandgradplus</code>,
<code>expanddivplus</code>, <code>expandcurlplus</code>, and <code>expandlaplacianplus</code>.
</p>
</dd>
<dt><span><code>expandprod</code></span></dt>
<dd><p>Enables <code>expandgradprod</code>, <code>expanddivprod</code>, and 
<code>expandlaplacianprod</code>.
</p></dd>
</dl>

<p>These flags have all been declared <code>evflag</code>.
</p>
</dd></dl>

<span id="vect_005fcross"></span><span id="Item_003a-Matrices_002ede_002fdefvr_002fvect_005fcross"></span><dl class="def">
<dt id="index-vect_005fcross"><span class="category">Optionsvariable: </span><span><strong>vect_cross</strong><a href='#index-vect_005fcross' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p>Hat <code>vect_cross</code> den Wert <code>true</code>, werden Ausdr&uuml;cke, die die 
Ableitung eines Kreuzproduktes enthalten, vereinfacht.
</p>
<p>Beispiel:
</p>
<div class="example">
<pre class="example">(%i1) load(&quot;vect&quot;)$

(%i2) vect_cross:false;
(%o2)                         false
(%i3) diff(f(x)~g(x),x);
                        d
(%o3)                   -- (f(x) ~ g(x))
                        dx
(%i4) vect_cross:true;
(%o4)                         true
(%i5) diff(f(x)~g(x),x);
                     d                    d
(%o5)        f(x) ~ (-- (g(x))) - g(x) ~ (-- (f(x)))
                     dx                   dx
</pre></div>
</dd></dl>

<span id="zeromatrix"></span><span id="Item_003a-Matrices_002ede_002fdeffn_002fzeromatrix"></span><dl class="def">
<dt id="index-zeromatrix"><span class="category">Funktion: </span><span><strong>zeromatrix</strong> <em>(<var>m</var>, <var>n</var>)</em><a href='#index-zeromatrix' class='copiable-anchor'> &para;</a></span></dt>
<dd>

<p>Gibt eine <var>m</var> x <var>n</var>-Matrix zur&uuml;ck, deren Elemente alle Null sind.
</p></dd></dl>



</div>
<hr>
<div class="header">
<p>
Vorige: <a href="maxima_105.html" accesskey="p" rel="prev">Einf&uuml;hrung in die lineare Algebra</a>, Nach oben: <a href="maxima_104.html" accesskey="u" rel="up">Lineare Algebra</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Inhaltsverzeichnis" rel="contents">Inhalt</a>][<a href="maxima_334.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
