<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Funções e Variáveis Definidas para Simplificação (Manual do Maxima)</title>

<meta name="description" content="Funções e Variáveis Definidas para Simplificação (Manual do Maxima)">
<meta name="keywords" content="Funções e Variáveis Definidas para Simplificação (Manual do Maxima)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="maxima_toc.html" rel="start" title="Top">
<link href="maxima_231.html" rel="index" title="Índice de Funções e Variáveis">
<link href="maxima_toc.html#SEC_Contents" rel="contents" title="Sum&aacute;rio">
<link href="maxima_28.html" rel="up" title="Simplificação">
<link href="maxima_28.html" rel="prev" title="Simplificação">
<style type="text/css">
<!--
a.copiable-anchor {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
span:hover a.copiable-anchor {visibility: visible}
ul.no-bullet {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 1em; padding-bottom: 1em;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%; display: block; margin-left: auto; margin-right: auto}

-->
</style>

<link rel="icon" href="figures/favicon.ico">
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6>"></script>

</head>

<body lang="pt">
<div class="section" id="Fun_00e7_00f5es-e-Vari_00e1veis-Definidas-para-Simplifica_00e7_00e3o">
<div class="header">
<p>
Anterior: <a href="maxima_28.html" accesskey="p" rel="prev">Simplificação</a>, Acima: <a href="maxima_28.html" accesskey="u" rel="up">Simplificação</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Sum&aacute;rio" rel="contents">Conte&uacute;do</a>][<a href="maxima_231.html" title="&Iacute;ndice" rel="index">&Iacute;ndice</a>]</p>
</div>
<span id="Funcoes-e-Variaveis-Definidas-para-Simplificacao"></span><h3 class="section">7.1, Funções e Variáveis Definidas para Simplificação</h3>

<span id="Item_003a-Simplification_002fdefvr_002faskexp"></span><dl class="def">
<dt id="index-askexp"><span class="category">Variável de sistema: </span><span><strong>askexp</strong><a href='#index-askexp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Quando <code>asksign</code> é chamada,
<code>askexp</code> é a expressão que <code>asksign</code> está testando.
</p>
<p>Antigamente, era possível para um usuário inspecionar <code>askexp</code>
entrando em uma parada do Maxima com control-A.
</p></dd></dl>

<span id="Item_003a-Simplification_002fdeffn_002faskinteger"></span><dl class="def">
<dt id="index-askinteger"><span class="category">Função: </span><span><strong>askinteger</strong> <em>(<var>expr</var>, integer)</em><a href='#index-askinteger' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-askinteger-1"><span class="category">Função: </span><span><strong>askinteger</strong> <em>(<var>expr</var>)</em><a href='#index-askinteger-1' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-askinteger-2"><span class="category">Função: </span><span><strong>askinteger</strong> <em>(<var>expr</var>, even)</em><a href='#index-askinteger-2' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-askinteger-3"><span class="category">Função: </span><span><strong>askinteger</strong> <em>(<var>expr</var>, odd)</em><a href='#index-askinteger-3' class='copiable-anchor'> &para;</a></span></dt>
<dd>
<p><code>askinteger (<var>expr</var>, integer)</code> tenta determinar a partir da base de dados do <code>assume</code>
se <var>expr</var> é um inteiro.
<code>askinteger</code> pergunta ao usuário pela linha de comando se isso não puder ser feito de outra forma,
e tenta instalar a informação na base de dados do <code>assume</code> se for possível.
<code>askinteger (<var>expr</var>)</code> é equivalente a <code>askinteger (<var>expr</var>, integer)</code>.
</p>
<p><code>askinteger (<var>expr</var>, even)</code> e <code>askinteger (<var>expr</var>, odd)</code>
da mesma forma tentam determinar se <var>expr</var> é um inteiro par ou inteiro ímpar, respectivamente.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdeffn_002fasksign"></span><dl class="def">
<dt id="index-asksign"><span class="category">Função: </span><span><strong>asksign</strong> <em>(<var>expr</var>)</em><a href='#index-asksign' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Primeiro tenta determinar se a expressão
especificada é positiva, negativa, ou zero.  Se isso não for possível, <code>asksign</code> pergunta ao
usuário pelas questões necessárias para completar a sua dedução.  As respostas
do usuário são guardadas na base de dados pelo tempo que durar a computação
corrente. O valor de retorno de <code>asksign</code> é um entre <code>pos</code>, <code>neg</code>,
ou <code>zero</code>.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdeffn_002fdemoivre"></span><dl class="def">
<dt id="index-demoivre"><span class="category">Função: </span><span><strong>demoivre</strong> <em>(<var>expr</var>)</em><a href='#index-demoivre' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-demoivre-1"><span class="category">Variável de opção: </span><span><strong>demoivre</strong><a href='#index-demoivre-1' class='copiable-anchor'> &para;</a></span></dt>
<dd>
<p>A função <code>demoivre (expr)</code> converte uma expressão
sem escolher a variável global <code>demoivre</code>.
</p>
<p>Quando a variável <code>demoivre</code> for <code>true</code>,
exponenciais complexas são convertidas em expressões equivalentes em termos de funções circulares:
<code>exp (a + b*%i)</code> simplifica para <code>%e^a * (cos(b) + %i*sin(b))</code>
se <code>b</code> for livre de <code>%i</code>.
<code>a</code> e <code>b</code> não são expandidos.
</p>
<p>O valor padrão de <code>demoivre</code> é <code>false</code>.
</p>
<p><code>exponentialize</code> converte funções circulares e hiperbólicas para a forma exponencial.
<code>demoivre</code> e <code>exponentialize</code> não podem
ambas serem <code>true</code> ao mesmo tempo.
</p>
</dd></dl>


<span id="Item_003a-Simplification_002fdefvr_002fdomain"></span><dl class="def">
<dt id="index-domain"><span class="category">Variável de opção: </span><span><strong>domain</strong><a href='#index-domain' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Valor padrão: <code>real</code>
</p>
<p>Quando <code>domain</code> for escolhida para <code>complex</code>, <code>sqrt (x^2)</code> permanecerá
<code>sqrt (x^2)</code> em lugar de retornar <code>abs(x)</code>.
</p>

</dd></dl>

<span id="Item_003a-Simplification_002fdeffn_002fexpand"></span><dl class="def">
<dt id="index-expand"><span class="category">Função: </span><span><strong>expand</strong> <em>(<var>expr</var>)</em><a href='#index-expand' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-expand-1"><span class="category">Função: </span><span><strong>expand</strong> <em>(<var>expr</var>, <var>p</var>, <var>n</var>)</em><a href='#index-expand-1' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Expande a expressão <var>expr</var>.
Produtos de somas e somas exponenciadas são
multiplicadas para fora, numeradores de expressões racionais que são adições são
quebradas em suas respectivas parcelas, e multiplicação (comutativa
e não comutativa) é distribuída sobre a adição em todos os níveis de
<var>expr</var>.
</p>
<p>Para polinômios se pode usar freq&uuml;êntemente <code>ratexpand</code> que possui um
algorítmo mais eficiente.
</p>
<p><code>maxnegex</code> e <code>maxposex</code> controlam o máximo expoente negativo e
o máximo expoente positivo, respectivamente, que irão expandir.
</p>
<p><code>expand (<var>expr</var>, <var>p</var>, <var>n</var>)</code> expande <var>expr</var>, 
usando <var>p</var> para <code>maxposex</code> e <var>n</var> para <code>maxnegex</code>.
Isso é útil com o objetivo de expandir partes mas não tudo em uma expressão.
</p>
<p><code>expon</code> - o expoente da maior potência negativa que é
automaticamente expandida (independente de chamadas a <code>expand</code>).  Por Exemplo
se <code>expon</code> for 4 então <code>(x+1)^(-5)</code> não será automaticamente expandido.
</p>
<p><code>expop</code> - o maior expoente positivo que é automaticamente
expandido.  Dessa forma <code>(x+1)^3</code>, quando digitado, será automaticamente expandido
somente se <code>expop</code> for maior que ou igual a 3.  Se for desejado ter
<code>(x+1)^n</code> expandido onde <code>n</code> é maior que <code>expop</code> então executando
<code>expand ((x+1)^n)</code> trabalhará somente se <code>maxposex</code> não for menor que <code>n</code>.
</p>
<p>O sinalizador <code>expand</code> usado com <code>ev</code> causa expansão.
</p>
<p>O arquivo <samp>simplification/facexp.mac</samp>
contém muitas funções relacionadas (em particular <code>facsum</code>, <code>factorfacsum</code>
e <code>collectterms</code>, que são chamadas automaticamente) e variáveis (<code>nextlayerfactor</code>
e <code>facsum_combine</code>) que fornecem ao usuário com a habilidade para estruturar
expressões por expansão controlada.
Descrições breves de função estão disponível em <samp>simplification/facexp.usg</samp>.
Um arquivo demonstrativo está disponível fazendo <code>demo(&quot;facexp&quot;)</code>.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdeffn_002fexpandwrt"></span><dl class="def">
<dt id="index-expandwrt"><span class="category">Função: </span><span><strong>expandwrt</strong> <em>(<var>expr</var>, <var>x_1</var>, ..., <var>x_n</var>)</em><a href='#index-expandwrt' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Expande a expressão <code>expr</code> com relação às 
variáveis <var>x_1</var>, ..., <var>x_n</var>.
Todos os produtos envolvendo as variáveis aparecem explicitamente.  A forma retornada
será livre de produtos de somas de expressões que não estão livres das
variáveis.   <var>x_1</var>, ..., <var>x_n</var>
podem ser variáveis, operadores, ou expressões.
</p>
<p>Por padrão, denominadores não são expandidos, mas isso pode ser controlado
através do comutador <code>expandwrt_denom</code>.
</p>
<p>Essa função, <code>expandwrt</code>, não é automaticamente chamada a partir de
<samp>simplification/stopex.mac</samp>.
</p>
</dd></dl>


<span id="Item_003a-Simplification_002fdefvr_002fexpandwrt_005fdenom"></span><dl class="def">
<dt id="index-expandwrt_005fdenom"><span class="category">Variável de opção: </span><span><strong>expandwrt_denom</strong><a href='#index-expandwrt_005fdenom' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Valor padrão: <code>false</code>
</p>
<p><code>expandwrt_denom</code> controla o tratamento de expressões
racionais por <code>expandwrt</code>.  Se <code>true</code>, então ambos o numerador e
o denominador da expressão serão expandidos conforme os
argumentos de <code>expandwrt</code>, mas se <code>expandwrt_denom</code> for <code>false</code>, então somente
o numerador será expandido por aquele caminho.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdeffn_002fexpandwrt_005ffactored"></span><dl class="def">
<dt id="index-expandwrt_005ffactored"><span class="category">Função: </span><span><strong>expandwrt_factored</strong> <em>(<var>expr</var>, <var>x_1</var>, ..., <var>x_n</var>)</em><a href='#index-expandwrt_005ffactored' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>é similar a <code>expandwrt</code>, mas trata expressões que são produtos um tanto quanto diferentemente.
<code>expandwrt_factored</code> expande somente sobre esses fatores de <code>expr</code>
que contiverem as variáveis <var>x_1</var>, ..., <var>x_n</var>.
</p>
<p>Essa função é automaticamente chamada a aprtir de <samp>simplification/stopex.mac</samp>.
</p>
</dd></dl>


<span id="Item_003a-Simplification_002fdefvr_002fexpon"></span><dl class="def">
<dt id="index-expon"><span class="category">Variável de opção: </span><span><strong>expon</strong><a href='#index-expon' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Valor padrão: 0
</p>
<p><code>expon</code> é o expoente da maior potência negativa que
é automaticamente expandido (independente de chamadas a <code>expand</code>).  Por
exemplo, se <code>expon</code> for 4 então <code>(x+1)^(-5)</code> não será automaticamente
expandido.
</p>
</dd></dl>


<span id="Item_003a-Simplification_002fdeffn_002fexponentialize"></span><dl class="def">
<dt id="index-exponentialize"><span class="category">Função: </span><span><strong>exponentialize</strong> <em>(<var>expr</var>)</em><a href='#index-exponentialize' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-exponentialize-1"><span class="category">Variável de opção: </span><span><strong>exponentialize</strong><a href='#index-exponentialize-1' class='copiable-anchor'> &para;</a></span></dt>
<dd>
<p>A função <code>exponentialize (expr)</code> converte 
funções circulares e hiperbólicas em <var>expr</var> para exponenciais,
sem escolher a variável global <code>exponentialize</code>.
</p>
<p>Quando a variável <code>exponentialize</code> for <code>true</code>,
todas as funções circulares e hiperbólicas  são convertidas para a forma exponencial.
O valor padrão é <code>false</code>.
</p>
<p><code>demoivre</code> converte exponenciais complexas em funções circulares.
<code>exponentialize</code> e <code>demoivre</code> não podem
ambas serem <code>true</code> ao mesmo tempo.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdefvr_002fexpop"></span><dl class="def">
<dt id="index-expop"><span class="category">Variável de opção: </span><span><strong>expop</strong><a href='#index-expop' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Valor padrão: 0
</p>
<p><code>expop</code> - o maior expoente positivo que é 
automaticamente expandido.  Dessa forma <code>(x+1)^3</code>, quando digitado, será
automaticamente expandido somente se <code>expop</code> for maior que ou igual a 3.  
Se for desejado ter <code>(x+1)^n</code> expandido onde <code>n</code> é maior que 
<code>expop</code> então executando <code>expand ((x+1)^n)</code> trabalhará somente se <code>maxposex</code> não for 
menor que <code>n</code>.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdefvr_002ffactlim"></span><dl class="def">
<dt id="index-factlim"><span class="category">Variável de opção: </span><span><strong>factlim</strong><a href='#index-factlim' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Valor padrão: -1
</p>
<p><code>factlim</code> especifica o maior fatorial que é
automaticamente expandido.  Se for -1 então todos os inteiros são expandidos.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdeffn_002fintosum"></span><dl class="def">
<dt id="index-intosum"><span class="category">Função: </span><span><strong>intosum</strong> <em>(<var>expr</var>)</em><a href='#index-intosum' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Move fatores multiplicativos fora de um somatório para dentro.
Se o índice for usado na
expressão de fora, então a função tentará achar um índice
razoável, o mesmo que é feito para <code>sumcontract</code>.  Isso é essencialmente a
idéia inversa da propriedade <code>outative</code> de somatórios, mas note que isso
não remove essa propriedade, somente pula sua verificação.
</p>
<p>Em alguns casos,
um <code>scanmap (multthru, <var>expr</var>)</code> pode ser necessário antes de <code>intosum</code>.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdefvr_002flassociative"></span><dl class="def">
<dt id="index-lassociative"><span class="category">Declaração: </span><span><strong>lassociative</strong><a href='#index-lassociative' class='copiable-anchor'> &para;</a></span></dt>
<dd><p><code>declare (g, lassociative)</code> diz ao
simplificador do Maxima que <code>g</code> é associativa à esquerda.  E.g., <code>g (g (a, b), g (c, d))</code> irá
simplificar para <code>g (g (g (a, b), c), d)</code>.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdefvr_002flinear"></span><dl class="def">
<dt id="index-linear-1"><span class="category">Declaração: </span><span><strong>linear</strong><a href='#index-linear-1' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Uma das propriedades operativas do Maxima.  Para funções de uma única variável <code>f</code> então
declarada, a &quot;expansão&quot; <code>f(x + y)</code> retorna <code>f(x) + f(y)</code>,
<code>f(a*x)</code> retorna <code>a*f(x)</code> tomando
lugar onde <code>a</code> for uma &quot;constante&quot;.  para funções de dois ou mais argumentos,
&quot;linearidade&quot; é definida para ser como no caso de <code>sum</code> ou <code>integrate</code>,
i.e., <code>f (a*x + b, x)</code> retorna <code>a*f(x,x) + b*f(1,x)</code>
para <code>a</code> e <code>b</code> livres de <code>x</code>.
</p>
<p><code>linear</code> é equivalente a <code>additive</code> e <code>outative</code>.
Veja também <code>opproperties</code>.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdefvr_002fmainvar"></span><dl class="def">
<dt id="index-mainvar"><span class="category">Declaração: </span><span><strong>mainvar</strong><a href='#index-mainvar' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Você pode declarar variáveis para serem <code>mainvar</code> (variável principal).  A escala de
ordenação para átomos é essencialmente: números &lt; constantes (e.g., <code>%e</code>, <code>%pi</code>) &lt;
escalares &lt; outras variáveis &lt; mainvars.  E.g., compare <code>expand ((X+Y)^4)</code>
com <code>(declare (x, mainvar), expand ((x+y)^4))</code>.  (Nota: Cuidado deve ser
tomado se você eleger o uso desse recurso acima.  E.g., se você subtrair uma
expressão na qual <code>x</code> for uma <code>mainvar</code> de uma na qual <code>x</code> não seja uma
<code>mainvar</code>, resimplificação e.g. com <code>ev (expr, simp)</code> pode ser
necessária se for para ocorrer um cancelamento.  Também, se você grava uma
expressão na qual <code>x</code> é uma <code>mainvar</code>, você provavelmente pode também gravar <code>x</code>.)
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdefvr_002fmaxapplydepth"></span><dl class="def">
<dt id="index-maxapplydepth"><span class="category">Variável de opção: </span><span><strong>maxapplydepth</strong><a href='#index-maxapplydepth' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Valor padrão: 10000
</p>
<p><code>maxapplydepth</code> é a máxima definição para a qual <code>apply1</code>
e <code>apply2</code> irão pesquisar.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdefvr_002fmaxapplyheight"></span><dl class="def">
<dt id="index-maxapplyheight"><span class="category">Variável de opção: </span><span><strong>maxapplyheight</strong><a href='#index-maxapplyheight' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Valor padrão: 10000
</p>
<p><code>maxapplyheight</code> é a elevação máxima a qual <code>applyb1</code>
irá alcançar antes de abandonar.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdefvr_002fmaxnegex"></span><dl class="def">
<dt id="index-maxnegex"><span class="category">Variável de opção: </span><span><strong>maxnegex</strong><a href='#index-maxnegex' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Valor padrão: 1000
</p>
<p><code>maxnegex</code> é o maior expoente negativo que será
expandido pelo comando <code>expand</code> (veja também <code>maxposex</code>).
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdefvr_002fmaxposex"></span><dl class="def">
<dt id="index-maxposex"><span class="category">Variável de opção: </span><span><strong>maxposex</strong><a href='#index-maxposex' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Valor padrão: 1000
</p>
<p><code>maxposex</code> é o maior expoente que será
expandido com o comando <code>expand</code> (veja também <code>maxnegex</code>).
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdefvr_002fmultiplicative"></span><dl class="def">
<dt id="index-multiplicative"><span class="category">Declaração: </span><span><strong>multiplicative</strong><a href='#index-multiplicative' class='copiable-anchor'> &para;</a></span></dt>
<dd><p><code>declare (f, multiplicative)</code> diz ao simplificador do Maxima que <code>f</code> é multiplicativa.
</p>
<ol>
<li> Se <code>f</code> for uma função de uma única variável, sempre que o simplificador encontrar <code>f</code> aplicada
a um produto, <code>f</code> distribue sobre aquele produto.  E.g., <code>f(x*y)</code>
simplifica para <code>f(x)*f(y)</code>.
</li><li> Se <code>f</code> é uma função de 2 ou mais argumentos, multiplicatividade é
definida como multiplicatividade no primeiro argumento para <code>f</code>, e.g.,
<code>f (g(x) * h(x), x)</code> simplifica para <code>f (g(x) ,x) * f (h(x), x)</code>.
</li></ol>

<p>Essa simplificação não ocorre quando <code>f</code> é aplicada a expressões da
forma <code>product (x[i], i, m, n)</code>.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdefvr_002fnegdistrib"></span><dl class="def">
<dt id="index-negdistrib"><span class="category">Variável de opção: </span><span><strong>negdistrib</strong><a href='#index-negdistrib' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Valor padrão: <code>true</code>
</p>
<p>Quando <code>negdistrib</code> for <code>true</code>, -1 distribue
sobre uma expressão.  E.g., <code>-(x + y)</code> transforma-se em <code>- y - x</code>.  Mudando o valor de <code>negdistrib</code> para <code>false</code>
permitirá que <code>- (x + y)</code> seja mostrado como foi escrito.  Isso algumas vezes é útil
mas seja muito cuidadoso: como o sinalizador <code>simp</code>, isso é um sinalizador que você pode não
querer escolher para <code>false</code> como algo natural ou necessário com excessão
de usar localmente no seu Maxima.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdefvr_002fnegsumdispflag"></span><dl class="def">
<dt id="index-negsumdispflag"><span class="category">Variável de opção: </span><span><strong>negsumdispflag</strong><a href='#index-negsumdispflag' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Valor padrão: <code>true</code>
</p>
<p>Quando <code>negsumdispflag</code> for <code>true</code>, <code>x - y</code> é mostrado como <code>x - y</code>
em lugar de como <code>- y + x</code>.  Escolhendo isso para <code>false</code> faz com que a verificação especial em
visualização para a diferença das duas expressões não seja concluída.  Uma
aplicação é que dessa forma <code>a + %i*b</code> e <code>a - %i*b</code> podem ambos serem mostrados pelo
mesmo caminho.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdefvr_002fnoeval"></span><dl class="def">
<dt id="index-noeval"><span class="category">Símbolo especial: </span><span><strong>noeval</strong><a href='#index-noeval' class='copiable-anchor'> &para;</a></span></dt>
<dd><p><code>noeval</code> suprime a fase de avaliação de <code>ev</code>.  Isso é útil em
conjunção com outros comutadores e para fazer com que expressões      
sejam resimplificadas sem serem reavaliadas.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdefvr_002fnoun"></span><dl class="def">
<dt id="index-noun"><span class="category">Declaração: </span><span><strong>noun</strong><a href='#index-noun' class='copiable-anchor'> &para;</a></span></dt>
<dd><p><code>noun</code> é uma das opções do comando <code>declare</code>.  Essa opção faz com que um
função seja declarada como &quot;noun&quot; (substantivo), significando que ela não deve ser avaliada
automaticamente.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdefvr_002fnoundisp"></span><dl class="def">
<dt id="index-noundisp"><span class="category">Variável de opção: </span><span><strong>noundisp</strong><a href='#index-noundisp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Valor padrão: <code>false</code>
</p>
<p>Quando <code>noundisp</code> for <code>true</code>, substantivos (nouns) são mostrados com
um apóstrofo.  Esse comutador é sempre <code>true</code> quando mostrando definições de
função.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdefvr_002fnouns"></span><dl class="def">
<dt id="index-nouns"><span class="category">Símbolo especial: </span><span><strong>nouns</strong><a href='#index-nouns' class='copiable-anchor'> &para;</a></span></dt>
<dd><p><code>nouns</code> é um <code>evflag</code> (sinalizador de avaliação). Quando usado como uma opção para o comando <code>ev</code>,
<code>nouns</code> converte todas as
formas substantivas (&quot;noun&quot;) que ocorrem na expressão que está sendo avaliada para verbos (&quot;verbs&quot;), i.e.,
avalia essas expressões.  Veja também <code>noun</code>, <code>nounify</code>, <code>verb</code>, e <code>verbify</code>.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdefvr_002fnumer"></span><dl class="def">
<dt id="index-numer"><span class="category">Símbolo especial: </span><span><strong>numer</strong><a href='#index-numer' class='copiable-anchor'> &para;</a></span></dt>
<dd><p><code>numer</code> faz com que algumas funções matemáticas (incluindo exponenciação)
com argumentos numéricos sejam avaliados em ponto flutuante. Isso faz com que
variáveis em <code>expr</code> às quais tenham sido dados valores numéricos a elas sejam substituídas pelos
seus valores correspondentes.  <code>numer</code> também escolhe o sinalizador <code>float</code> para <code>on</code>.
</p>
</dd></dl>


<span id="Item_003a-Simplification_002fdeffn_002fnumerval"></span><dl class="def">
<dt id="index-numerval"><span class="category">Função: </span><span><strong>numerval</strong> <em>(<var>x_1</var>, <var>expr_1</var>, ..., <var>var_n</var>, <var>expr_n</var>)</em><a href='#index-numerval' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Declara as variáveis <code>x_1</code>, ..., <var>x_n</var> para terem
valores numéricos iguais a <code>expr_1</code>, ..., <code>expr_n</code>.
O valor numérico é avaliado e substituido para a variável
em quaisquer expressões na qual a variável ocorra se o sinalizador <code>numer</code> for
<code>true</code>. Veja também <code>ev</code>.
</p>
<p>As expressões <code>expr_1</code>, ..., <code>expr_n</code> podem ser quaisquer expressões,
não necessariamente numéricas.
</p></dd></dl>


<span id="Item_003a-Simplification_002fdefvr_002fopproperties"></span><dl class="def">
<dt id="index-opproperties"><span class="category">Variável de sistema: </span><span><strong>opproperties</strong><a href='#index-opproperties' class='copiable-anchor'> &para;</a></span></dt>
<dd>
<p><code>opproperties</code> é a lista de propriedades de operadores especiais reconhecidas pelo
simplificador do Maxima:
<code>linear</code>, <code>additive</code>, <code>multiplicative</code>, <code>outative</code> (veja logo abaixo), <code>evenfun</code>,
<code>oddfun</code>, <code>commutative</code>, <code>symmetric</code>, <code>antisymmetric</code>, <code>nary</code>, 
<code>lassociative</code>, <code>rassociative</code>.
</p>
</dd></dl>


<span id="Item_003a-Simplification_002fdefvr_002fopsubst"></span><dl class="def">
<dt id="index-opsubst-3"><span class="category">Variável de opção: </span><span><strong>opsubst</strong><a href='#index-opsubst-3' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Valor padrão: <code>true</code>
</p>
<p>Quando <code>opsubst</code> for <code>false</code>, <code>subst</code> não tenta
substituir dentro de um operador de uma expressão.  E.g., 
<code>(opsubst: false, subst (x^2, r, r+r[0]))</code> irá trabalhar.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdefvr_002foutative"></span><dl class="def">
<dt id="index-outative"><span class="category">Declaração: </span><span><strong>outative</strong><a href='#index-outative' class='copiable-anchor'> &para;</a></span></dt>
<dd><p><code>declare (f, outative)</code> diz ao simplificador do Maxima que fatores constantes
no argumento de <code>f</code> podem ser puxados para fora.
</p>
<ol>
<li> Se <code>f</code> for uma função de uma única variável, sempre que o simplificador encontrar <code>f</code> aplicada
a um produto, aquele produto será particionado em fatores que são
constantes e fatores que não são e os fatores constantes serão
puxados para fora.  E.g., <code>f(a*x)</code> simplificará para <code>a*f(x)</code> onde <code>a</code> é uma
constante.  Fatores de constantes não atômicas não serão puxados para fora.
</li><li> Se <code>f</code> for uma função de 2 ou mais argumentos, a colocação para fora é definida
como no caso de <code>sum</code> ou <code>integrate</code>, i.e., <code>f (a*g(x), x)</code> irá simplificar
para <code>a * f(g(x), x)</code> sendo <code>a</code> livre de <code>x</code>.
</li></ol>

<p><code>sum</code>, <code>integrate</code>, e <code>limit</code> são todas <code>outative</code>.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdefvr_002fposfun"></span><dl class="def">
<dt id="index-posfun"><span class="category">Declaração: </span><span><strong>posfun</strong><a href='#index-posfun' class='copiable-anchor'> &para;</a></span></dt>
<dd><p><code>declare (f, posfun)</code> declara <code>f</code> para ser uma função positiva.
<code>is (f(x) &gt; 0)</code> retorna <code>true</code>.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdeffn_002fradcan"></span><dl class="def">
<dt id="index-radcan"><span class="category">Função: </span><span><strong>radcan</strong> <em>(<var>expr</var>)</em><a href='#index-radcan' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Simplifica <var>expr</var>, que pode conter logarítmos, exponenciais, e
radicais, convertendo essa expressão em uma forma que é canônica sobre uma ampla
classe de expressões e uma dada ordenação de variáveis; isto é, todas
formas funcionalmente equivalentes são mapeadas em uma única forma.  Para uma
classe um tanto quanto ampla de expressões, <code>radcan</code> produz uma forma regular.
Duas expressões equivalentes nessa classe não possuem necessáriamente a
mesma aparência, mas suas diferenças podem ser simplificadas por <code>radcan</code> para
zero.
</p>
<p>Para algumas expressões <code>radcan</code> é que consome inteiramente o tempo.  Esse
é o custo de explorar certos relacionamentos entre os componentes da
expressão para simplificações baseadas sobre fatoração e
expansões de fração-parcial de expoentes.  
</p>
<p>Quando <code>%e_to_numlog</code> for <code>true</code>, 
<code>%e^(r*log(expr))</code> simplifica para <code>expr^r</code> se <code>r</code> for um número racional.
</p>
<p>Quando <code>radexpand</code> for <code>false</code>, certas transformações são inibidas.
<code>radcan (sqrt (1-x))</code> permanece <code>sqrt (1-x)</code>
e não é simplificada para <code>%i sqrt (x-1)</code>. 
<code>radcan (sqrt (x^2 - 2*x + 11))</code> permanece <code>sqrt (x^2 - 2*x + 1)</code>
e não é simplificada para <code>x - 1</code>.
</p>
<p><code>example (radcan)</code> mostra alguns exemplos.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdefvr_002fradexpand"></span><dl class="def">
<dt id="index-radexpand"><span class="category">Variável de opção: </span><span><strong>radexpand</strong><a href='#index-radexpand' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Valor padrão: <code>true</code>
</p>
<p><code>radexpand</code> controla algumas simplificações de radicais.
</p>
<p>Quando <code>radexpand</code> for <code>all</code>, faz com que n-ésimas raízes de
fatores de um produto que são potências de n sejam puxados para fora do
radical.  E.g. Se <code>radexpand</code> for <code>all</code>, <code>sqrt (16*x^2)</code> simplifica para <code>4*x</code>.
</p>
<p>Mais particularmente, considere <code>sqrt (x^2)</code>.
</p><ul>
<li> Se <code>radexpand</code> for <code>all</code> or <code>assume (x &gt; 0)</code> tiver sido executado, 
<code>sqrt(x^2)</code> simplifica para <code>x</code>.
</li><li> Se <code>radexpand</code> for <code>true</code> e <code>domain</code> for <code>real</code> (isso é o padrão), 
<code>sqrt(x^2)</code> simplifica para <code>abs(x)</code>.
</li><li> Se <code>radexpand</code> for <code>false</code>, ou <code>radexpand</code> for <code>true</code> e <code>domain</code> for <code>complex</code>, 
<code>sqrt(x^2)</code> não é simplificado.
</li></ul>

<p>Note que <code>domain</code> somente interessa quando <code>radexpand</code> for <code>true</code>.
</p>
</dd></dl>


<span id="Item_003a-Simplification_002fdefvr_002fradsubstflag"></span><dl class="def">
<dt id="index-radsubstflag"><span class="category">Variável de opção: </span><span><strong>radsubstflag</strong><a href='#index-radsubstflag' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Valor padrão: <code>false</code>
</p>
<p><code>radsubstflag</code>, se <code>true</code>, permite a <code>ratsubst</code> fazer
substituições tais como <code>u</code> por <code>sqrt (x)</code> em <code>x</code>.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdefvr_002frassociative"></span><dl class="def">
<dt id="index-rassociative"><span class="category">Declaração: </span><span><strong>rassociative</strong><a href='#index-rassociative' class='copiable-anchor'> &para;</a></span></dt>
<dd><p><code>declare (g, rassociative)</code> diz ao simplificador do
Maxima que <code>g</code> é associativa à direita.  E.g.,
<code>g(g(a, b), g(c, d))</code> simplifica para <code>g(a, g(b, g(c, d)))</code>.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdeffn_002fscsimp"></span><dl class="def">
<dt id="index-scsimp"><span class="category">Função: </span><span><strong>scsimp</strong> <em>(<var>expr</var>, <var>rule_1</var>, ..., <var>rule_n</var>)</em><a href='#index-scsimp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Simplificação Seq&uuml;êncial Comparativa (método devido a Stoute).
<code>scsimp</code> tenta simplificar <var>expr</var>
conforme as regras <var>rule_1</var>, ..., <var>rule_n</var>.
Se uma expressão pequena for obtida, o processo
repete-se.  De outra forma após todas as simplificações serem tentadas, <code>scsimp</code> retorna
a resposta original.
</p>
<p><code>example (scsimp)</code> mostra alguns exemplos.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdefvr_002fsimpsum"></span><dl class="def">
<dt id="index-simpsum"><span class="category">Variável de opção: </span><span><strong>simpsum</strong><a href='#index-simpsum' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Valor padrão: <code>false</code>
</p>
<p>Quando <code>simpsum</code> for <code>true</code>, o resultado de uma <code>sum</code> é
simplificado.  Essa simplificação pode algumas vezes estar apta a produzir uma
forma fechada.  Se <code>simpsum</code> for <code>false</code> ou se a forma com apóstrofo <code>'sum</code> for usada, o valor é uma
forma substantiva aditiva que é uma representação da notação sigma usada em
matemática.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdeffn_002fsumcontract"></span><dl class="def">
<dt id="index-sumcontract"><span class="category">Função: </span><span><strong>sumcontract</strong> <em>(<var>expr</var>)</em><a href='#index-sumcontract' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Combina todas as parcelas de um somatório que possuem
limites superiores e inferiores que diferem por constantes. O resultado é uma
expressão contendo um somatório para cada escolha de cada tais somatórios
adicionados a todos os termos extras apropriados que tiveram de ser extraídos para a forma
dessa adição.  <code>sumcontract</code> combina todas as somas compatíveis e usa os
indices de uma as somas se puder, e então tenta formar um
índice razoável se não for usar qualquer dos fornecidos.
</p>
<p>Isso pode ser necessário fazer um <code>intosum (<var>expr</var>)</code> antes de <code>sumcontract</code>.
</p>
</dd></dl>


<span id="Item_003a-Simplification_002fdefvr_002fsumexpand"></span><dl class="def">
<dt id="index-sumexpand"><span class="category">Variável de opção: </span><span><strong>sumexpand</strong><a href='#index-sumexpand' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Valor padrão: <code>false</code>
</p>
<p>Quando <code>sumexpand</code> for <code>true</code>, produtos de somas e
somas exponeciadas simplificam para somas aninhadas.
</p>
<p>Veja também <code>cauchysum</code>.
</p>
<p>Exemplos:
</p>
<div class="example">
<pre class="example">(%i1) sumexpand: true$
(%i2) sum (f (i), i, 0, m) * sum (g (j), j, 0, n);
                     m      n
                    ====   ====
                    \      \
(%o2)                &gt;      &gt;     f(i1) g(i2)
                    /      /
                    ====   ====
                    i1 = 0 i2 = 0
(%i3) sum (f (i), i, 0, m)^2;
                     m      m
                    ====   ====
                    \      \
(%o3)                &gt;      &gt;     f(i3) f(i4)
                    /      /
                    ====   ====
                    i3 = 0 i4 = 0
</pre></div>

</dd></dl>

<span id="Item_003a-Simplification_002fdefvr_002fsumsplitfact"></span><dl class="def">
<dt id="index-sumsplitfact"><span class="category">Variável de opção: </span><span><strong>sumsplitfact</strong><a href='#index-sumsplitfact' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Valor padrão: <code>true</code>
</p>
<p>Quando <code>sumsplitfact</code> for <code>false</code>,
<code>minfactorial</code> é aplicado após um <code>factcomb</code>.
</p>
</dd></dl>

<span id="Item_003a-Simplification_002fdefvr_002fsymmetric"></span><dl class="def">
<dt id="index-symmetric"><span class="category">Declaração: </span><span><strong>symmetric</strong><a href='#index-symmetric' class='copiable-anchor'> &para;</a></span></dt>
<dd><p><code>declare (h, symmetric)</code> diz ao simplificador
do Maxima que <code>h</code> é uma função simétrica.  E.g., <code>h (x, z, y)</code> 
simplifica para <code>h (x, y, z)</code>.
</p>
<p><code>commutative</code> é sinônimo de <code>symmetric</code>.
</p>
</dd></dl>


<span id="Item_003a-Simplification_002fdeffn_002funknown"></span><dl class="def">
<dt id="index-unknown"><span class="category">Função: </span><span><strong>unknown</strong> <em>(<var>expr</var>)</em><a href='#index-unknown' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Retorna <code>true</code> se e somente se <var>expr</var> contém um operador ou função
não reconhecida pelo simplificador do Maxima.
</p>
</dd></dl>


</div>
<hr>
<div class="header">
<p>
Anterior: <a href="maxima_28.html" accesskey="p" rel="prev">Simplificação</a>, Acima: <a href="maxima_28.html" accesskey="u" rel="up">Simplificação</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Sum&aacute;rio" rel="contents">Conte&uacute;do</a>][<a href="maxima_231.html" title="&Iacute;ndice" rel="index">&Iacute;ndice</a>]</p>
</div>



</body>
</html>
