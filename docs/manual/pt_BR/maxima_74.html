<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Manual do Maxima: Funções e Variáveis Definidas para Numérico</title>

<meta name="description" content="Manual do Maxima: Funções e Variáveis Definidas para Numérico">
<meta name="keywords" content="Manual do Maxima: Funções e Variáveis Definidas para Numérico">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="maxima_toc.html#Top" rel="start" title="Top">
<link href="maxima_231.html#g_t_00cdndice-de-Fun_00e7_00f5es-e-Vari_00e1veis" rel="index" title="Índice de Funções e Variáveis">
<link href="maxima_toc.html#SEC_Contents" rel="contents" title="Sum&aacute;rio">
<link href="maxima_71.html#Num_00e9rico" rel="up" title="Numérico">
<link href="maxima_75.html#Fun_00e7_00f5es-e-Vari_00e1veis-Definidas-para-S_00e9ries-de-Fourier" rel="next" title="Funções e Variáveis Definidas para Séries de Fourier">
<link href="maxima_73.html#Pacotes-de-Fourier" rel="previous" title="Pacotes de Fourier">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 1em; padding-bottom: 1em;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%; display: block; margin-left: auto; margin-right: auto}

-->
</style>

<link rel="icon" href="../figures/favicon.ico">

</head>

<body lang="pt" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="Fun_00e7_00f5es-e-Vari_00e1veis-Definidas-para-Num_00e9rico"></a>
<div class="header">
<p>
Pr&oacute;ximo: <a href="maxima_75.html#Fun_00e7_00f5es-e-Vari_00e1veis-Definidas-para-S_00e9ries-de-Fourier" accesskey="n" rel="next">Funções e Variáveis Definidas para Séries de Fourier</a>, Previous: <a href="maxima_73.html#Pacotes-de-Fourier" accesskey="p" rel="previous">Pacotes de Fourier</a>, Acima: <a href="maxima_71.html#Num_00e9rico" accesskey="u" rel="up">Numérico</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Sum&aacute;rio" rel="contents">Conte&uacute;do</a>][<a href="maxima_231.html#g_t_00cdndice-de-Fun_00e7_00f5es-e-Vari_00e1veis" title="&Iacute;ndice" rel="index">&Iacute;ndice</a>]</p>
</div>
<a name="Funcoes-e-Variaveis-Definidas-para-Numerico"></a>
<h3 class="section">23.3 Funções e Variáveis Definidas para Numérico</h3>

<a name="Item_003a-Numerical_002fdeffn_002fpolartorect"></a><dl>
<dt><a name="index-polartorect"></a>Função: <strong>polartorect</strong> <em>(<var>magnitude_array</var>, <var>phase_array</var>)</em></dt>
<dd>
<p>Traduz valores complexos da forma <code>r %e^(%i t)</code> para a forma <code>a + b %i</code>.
<code>load (&quot;fft&quot;)</code> chama essa função dentro do Maxima. Veja também <code>fft</code>.
</p>
<p>O módulo e a fase, <code>r</code> e <code>t</code>, São tomados de <var>magnitude_array</var> e
<var>phase_array</var>, respectivamente. Os valores originais de arrays de entrada são
substituídos pelas partes real e emaginária, <code>a</code> e <code>b</code>, no retorno. As saídas são
calculadas como
</p>
<div class="example">
<pre class="example">a: r cos (t)
b: r sin (t)
</pre></div>

<p>Os arrays de entrada devem ter o mesmo tamanho  e ser unidimensionais.
O tamanho do array não deve ser uma potência de 2.
</p>
<p><code>polartorect</code> é a função inversa de <code>recttopolar</code>.
</p>
</dd></dl>

<a name="Item_003a-Numerical_002fdeffn_002frecttopolar"></a><dl>
<dt><a name="index-recttopolar"></a>Função: <strong>recttopolar</strong> <em>(<var>real_array</var>, <var>imaginary_array</var>)</em></dt>
<dd>
<p>Traduz valores complexos da forma <code>a + b %i</code> para a forma <code>r %e^(%i t)</code>.
<code>load (&quot;fft&quot;)</code> chama essa função dentro do Maxima. Veja também <code>fft</code>.
</p>
<p>As partes real e imaginária, <code>a</code> e <code>b</code>, são tomadas de <var>real_array</var> e
<var>imaginary_array</var>, respectivamente. Os valores originais dos arrays de entrada
são substituídos pelo módulo e pelo ângulo, <code>r</code> e <code>t</code>, no retorno. As saídas são
calculadas como
</p>
<div class="example">
<pre class="example">r: sqrt (a^2 + b^2)
t: atan2 (b, a)
</pre></div>

<p>O ângulo calculado encontra-se no intervalo de <code>-%pi</code> a <code>%pi</code>. 
</p>
<p>Os arrays de entrada devem ter o mesmo tamanho e ser unidimensionais.
O tamanho do array não deve ser uma potência de 2.
</p>
<p><code>recttopolar</code> é a função inversa de <code>polartorect</code>.
</p>
</dd></dl>

<a name="Item_003a-Numerical_002fdeffn_002fift"></a><dl>
<dt><a name="index-ift"></a>Função: <strong>ift</strong> <em>(<var>real_array</var>, <var>imaginary_array</var>)</em></dt>
<dd>
<p>Transformação rápida inversa discreta de Fourier . <code>load (&quot;fft&quot;)</code> chama essa função
dentro do Maxima.
</p>
<p><code>ift</code> realiza a transformação rápida complexa de Fourier sobre
arrays em ponto flutuante unidimensionais. A transformação inversa é definida como
</p>
<div class="example">
<pre class="example">x[j]: sum (y[j] exp (+2 %i %pi j k / n), k, 0, n-1)
</pre></div>

<p>Veja <code>fft</code> para maiores detalhes.
</p>
</dd></dl>

<a name="Item_003a-Numerical_002fdeffn_002ffft"></a><dl>
<dt><a name="index-fft"></a>Função: <strong>fft</strong> <em>(<var>real_array</var>, <var>imaginary_array</var>)</em></dt>
<dt><a name="index-ift-1"></a>Função: <strong>ift</strong> <em>(<var>real_array</var>, <var>imaginary_array</var>)</em></dt>
<dt><a name="index-recttopolar-1"></a>Função: <strong>recttopolar</strong> <em>(<var>real_array</var>, <var>imaginary_array</var>)</em></dt>
<dt><a name="index-polartorect-1"></a>Função: <strong>polartorect</strong> <em>(<var>magnitude_array</var>, <var>phase_array</var>)</em></dt>
<dd>
<p>Transformação rápidada de Fourier e funções relacionadas. <code>load (&quot;fft&quot;)</code>
chama essas funções dentro do Maxima.
</p>
<p><code>fft</code> e <code>ift</code> realiza transformação rápida complexa de Fourier e
a transformação inversa, respectivamente, sobre arrays em ponto flutuante
unidimensionais. O tamanho de <var>imaginary_array</var> deve ser igual ao tamanho de <var>real_array</var>.
</p>
<p><code>fft</code> e <code>ift</code> operam in-loco. Isto é, sobre o retorno de <code>fft</code> ou de <code>ift</code>,
O conteúdo original dos arrays de entrada é substituído pela saída.
A função <code>fillarray</code> pode fazer uma cópia de um array, isso pode
ser necessário.
</p>
<p>A transformação discreta de Fourier e sua transformação inversa são definidas
como segue. Tome <code>x</code> sendo os dados originais, com
</p>
<div class="example">
<pre class="example">x[i]: real_array[i] + %i imaginary_array[i]
</pre></div>
  
<p>Tome <code>y</code> sendo os dados transformados. A transformação normal e sua transformação inversa são
</p>
<div class="example">
<pre class="example">y[k]: (1/n) sum (x[j] exp (-2 %i %pi j k / n), j, 0, n-1)

x[j]:       sum (y[j] exp (+2 %i %pi j k / n), k, 0, n-1)
</pre></div>

<p>Arrays adequadas podem ser alocadas pela função <code>array</code>. Por exemplo:
</p>
<div class="example">
<pre class="example">array (my_array, float, n-1)$
</pre></div>

<p>declara um array unidimensional com n elementos, indexado de 0 a
n-1 inclusive. O número de elementos n deve ser igual a 2^m para algum m.
</p>
<p><code>fft</code> pode ser aplicada a dados reais (todos os arrays imaginários são iguais a zero) para obter
coeficientes seno e cosseno.  Após chamar <code>fft</code>, os coeficientes
seno e cosseno, digamos <code>a</code> e <code>b</code>, podem ser calculados como
</p>
<div class="example">
<pre class="example">a[0]: real_array[0]
b[0]: 0
</pre></div>

<p>e
</p>
<div class="example">
<pre class="example">a[j]: real_array[j] + real_array[n-j]
b[j]: imaginary_array[j] - imaginary_array[n-j]
</pre></div>

<p>para j variando de 1 a n/2-1, e
</p>
<div class="example">
<pre class="example">a[n/2]: real_array[n/2]
b[n/2]: 0
</pre></div>

<p><code>recttopolar</code> traduz valores complexos da forma <code>a + b %i</code> para
a forma <code>r %e^(%i t)</code>. Veja <code>recttopolar</code>.
</p>
<p><code>polartorect</code> traduz valores complexos da forma <code>r %e^(%i t)</code>
para a forma <code>a + b %i</code>. Veja <code>polartorect</code>.
</p>
<p><code>demo (&quot;fft&quot;)</code> exibe uma demonstração do pacote <code>fft</code>.
</p>
</dd></dl>

<a name="Item_003a-Numerical_002fdefvr_002ffortindent"></a><dl>
<dt><a name="index-fortindent"></a>Variável de opção: <strong>fortindent</strong></dt>
<dd><p>Valor padrão: 0
</p>
<p><code>fortindent</code> controla a margem esquerda de indentação de
expressões mostradas pelo comando <code>fortran</code>.  0 fornece indentação
normal (i.e., 6 espaços), e valores positivos farão com que
expressões sejam mostrados mais além para a direita.
</p>
</dd></dl>

<a name="Item_003a-Numerical_002fdeffn_002ffortran"></a><dl>
<dt><a name="index-fortran"></a>Função: <strong>fortran</strong> <em>(<var>expr</var>)</em></dt>
<dd><p>Mostra <var>expr</var> como uma declaração Fortran.
A linha de saída é indentada com espaços.
Se a linha for muito longa, <code>fortran</code> imprime linhas de continuação.
<code>fortran</code> mostra o operador de exponenciação <code>^</code> como <code>**</code>,
e mostra um número complexo <code>a + b %i</code> na forma <code>(a,b)</code>.
</p>
<p><var>expr</var> pode ser uma equação. Nesse caso, <code>fortran</code> mostra uma declaração de
atribuição, atribuindo o primeiro membro (esquerda) da equação ao segundo membro (direita).
Em particular, se o primeiro membro <var>expr</var> é um nome de uma matriz,
então <code>fortran</code> mostra uma declaração de atribuição para cada elemento da matriz.
</p>
<p>Se <var>expr</var> não for alguma coisa reconhecida por <code>fortran</code>,
a expressão é mostrada no formato <code>grind</code> sem reclamação.
<code>fortran</code> não conhece listas, arrays ou funções.
</p>
<p><code>fortindent</code> controla o margem esquerda das linhas mostradas.
0 é a margem normal (i.e., indentada 6 espaços). Incrementando <code>fortindent</code>
faz com que expressões sejam mostradas adiante para a direita.
</p>
<p>quando <code>fortspaces</code> for <code>true</code>, <code>fortran</code> preenche
cada linha mostrada com espaços em branco até completar 80 columas.
</p>
<p><code>fortran</code> avalia seus argumentos;
colocando um apóstrofo em um argumento evita avaliação.
<code>fortran</code> sempre retorna <code>done</code>.
</p>
<p>Exemplos:
</p>
<div class="example">
<pre class="example">(%i1) expr: (a + b)^12$
(%i2) fortran (expr);
      (b+a)**12                                                                 
(%o2)                         done
(%i3) fortran ('x=expr);
      x = (b+a)**12                                                             
(%o3)                         done
(%i4) fortran ('x=expand (expr));
      x = b**12+12*a*b**11+66*a**2*b**10+220*a**3*b**9+495*a**4*b**8+792        
     1   *a**5*b**7+924*a**6*b**6+792*a**7*b**5+495*a**8*b**4+220*a**9*b        
     2   **3+66*a**10*b**2+12*a**11*b+a**12                                     
(%o4)                         done
(%i5) fortran ('x=7+5*%i);
      x = (7,5)                                                                 
(%o5)                         done
(%i6) fortran ('x=[1,2,3,4]);
      x = [1,2,3,4]                                                             
(%o6)                         done
(%i7) f(x) := x^2$
(%i8) fortran (f);
      f                                                                         
(%o8)                         done
</pre></div>

</dd></dl>

<a name="Item_003a-Numerical_002fdefvr_002ffortspaces"></a><dl>
<dt><a name="index-fortspaces"></a>Variável de opção: <strong>fortspaces</strong></dt>
<dd><p>Valor padrão: <code>false</code>
</p>
<p>Quando <code>fortspaces</code> for <code>true</code>, <code>fortran</code> preenche
cada linha mostrada com espaços em branco até completar 80 columas.
</p>
</dd></dl>

<a name="Item_003a-Numerical_002fdeffn_002fhorner"></a><dl>
<dt><a name="index-horner"></a>Função: <strong>horner</strong> <em>(<var>expr</var>, <var>x</var>)</em></dt>
<dt><a name="index-horner-1"></a>Função: <strong>horner</strong> <em>(<var>expr</var>)</em></dt>
<dd><p>Retorna uma representação rearranjada de <var>expr</var> como
na regra de Horner, usando <var>x</var> como variável principal se isso for especificado.
<code>x</code> pode ser omitido e nesse caso a variável principal da forma de expressão racional
canônica de <var>expr</var> é usada.
</p>
<p><code>horner</code> algumas vezes melhora a estabilidade se <code>expr</code> for
ser numericamente avaliada.  Isso também é útil se Maxima é usado para
gerar programas para rodar em Fortran. Veja também <code>stringout</code>.
</p>
<div class="example">
<pre class="example">(%i1) expr: 1e-155*x^2 - 5.5*x + 5.2e155;
                           2
(%o1)            1.0E-155 x  - 5.5 x + 5.2E+155
(%i2) expr2: horner (%, x), keepfloat: true;
(%o2)            (1.0E-155 x - 5.5) x + 5.2E+155
(%i3) ev (expr, x=1e155);
Maxima encountered a Lisp error:

 floating point overflow

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
(%i4) ev (expr2, x=1e155);
(%o4)                       7.0E+154
</pre></div>

</dd></dl>

<a name="Item_003a-Numerical_002fdeffn_002ffind_005froot"></a><dl>
<dt><a name="index-find_005froot"></a>Função: <strong>find_root</strong> <em>(<var>f</var>(<var>x</var>), <var>x</var>, <var>a</var>, <var>b</var>)</em></dt>
<dt><a name="index-find_005froot-1"></a>Função: <strong>find_root</strong> <em>(<var>f</var>, <var>a</var>, <var>b</var>)</em></dt>
<dd><p>Encontra a raíz da função <var>f</var> com a variável <var>x</var> percorrendo o intervalo <code>[<var>a</var>, <var>b</var>]</code>.
A função deve ter um
sinal diferente em cada ponto final.  Se essa condição não for alcançada, a
action of the function is governed by <code>find_root_error</code>.  If
<code>find_root_error</code> is <code>true</code> then an error occurs, otherwise the value of
<code>find_root_error</code> is returned (thus for plotting <code>find_root_error</code> might be set to
0.0).  De outra forma (dado que Maxima pode avaliar o primeiro argumento
no intervalo especificado, e que o intervalo é contínuo) <code>find_root</code> é
garantido vir para cima com a raíz (ou um deles se existir mais
que uma raíz).  A precisão de <code>find_root</code> é governada por
<code>intpolabs</code> e <code>intpolrel</code> os quais devem ser números em ponto flutuante
não negativos.  <code>find_root</code> encerrará quando o primeiro argumento avaliar para
alguma coisa menor que ou igual a <code>intpolabs</code> ou se sucessivas
aproximações da raíz diferirem por não mais que <code>intpolrel * &lt;um dos aproximandos&gt;</code>.
O valor padrão de <code>intpolabs</code> e <code>intpolrel</code> são
0.0 de forma que <code>find_root</code> pega como boa uma resposta como for possível com a
precisão aritmética simples que tivermos.  O primeiro argumento pode ser uma
equação.  A ordem dos dois últimos argumentos é irrelevante.  Dessa forma
</p>
<div class="example">
<pre class="example">find_root (sin(x) = x/2, x, %pi, 0.1);
</pre></div>

<p>é equivalente a
</p>
<div class="example">
<pre class="example">find_root (sin(x) = x/2, x, 0.1, %pi);
</pre></div>

<p>O método usado é uma busca binária no intervalo especificado pelos últimos
dois argumentos.  Quando o resultado da busca for encontrado a função é fechada o suficiente para ser
linear, isso inicia usando interpolação linear.
</p>
<p>Examples:
</p><div class="example">
<pre class="example">(%i1) f(x) := sin(x) - x/2;
                                        x
(%o1)                  f(x) := sin(x) - -
                                        2
(%i2) find_root (sin(x) - x/2, x, 0.1, %pi);
(%o2)                   1.895494267033981
(%i3) find_root (sin(x) = x/2, x, 0.1, %pi);
(%o3)                   1.895494267033981
(%i4) find_root (f(x), x, 0.1, %pi);
(%o4)                   1.895494267033981
(%i5) find_root (f, 0.1, %pi);
(%o5)                   1.895494267033981
</pre></div>

</dd></dl>

<a name="Item_003a-Numerical_002fdefvr_002ffind_005froot_005fabs"></a><dl>
<dt><a name="index-find_005froot_005fabs"></a>Variável de opção: <strong>find_root_abs</strong></dt>
<dd><p>Valor padrão: 0.0
</p>
<p><code>find_root_abs</code> é a precisão do comando <code>find_root</code>. A precisão é
governada por <code>find_root_abs</code> e <code>find_root_rel</code> que devem ser
números não negativos em ponto flutuante.  <code>find_root</code> terminará quando o
primeiro argumento avaliar para alguma coisa menor que ou igual a <code>find_root_abs</code> ou se
sucessivos aproximandos para a raíz diferirem por não mais que <code>find_root_rel * &lt;um dos aproximandos&gt;</code>.
Os valores padrão de <code>find_root_abs</code> e
<code>find_root_rel</code> são 0.0 de forma que <code>find_root</code> tome como boa uma resposta que for possível
com a precisão aritmética simples que tivermos.
</p>
</dd></dl>

<a name="Item_003a-Numerical_002fdefvr_002ffind_005froot_005ferror"></a><dl>
<dt><a name="index-find_005froot_005ferror"></a>Variável de opção: <strong>find_root_error</strong></dt>
<dd><p>Valor padrão: <code>true</code>
</p>
<p><code>find_root_error</code> governa o comportamento de <code>find_root</code>.
Quando <code>find_root</code> for chamada, ela determina se a função
a ser resolvida satisfaz ou não a condição que os valores da
função nos pontos finais do intervalo de interpolação são opostos
em sinal.  Se eles forem de sinais opostos, a interpolação prossegue.
Se eles forem de mesmo sinal, e <code>find_root_error</code> for <code>true</code>, então um erro é
sinalizado.  Se eles forem de mesmo sinal e <code>find_root_error</code> não for <code>true</code>, o
valor de <code>find_root_error</code> é retornado.  Dessa forma para montagem de gráfico, <code>find_root_error</code>
pode ser escolhida para 0.0.
</p>
</dd></dl>

<a name="Item_003a-Numerical_002fdefvr_002ffind_005froot_005frel"></a><dl>
<dt><a name="index-find_005froot_005frel"></a>Variável de opção: <strong>find_root_rel</strong></dt>
<dd><p>Valor padrão: 0.0
</p>
<p><code>find_root_rel</code> é a precisão do comando <code>find_root</code> e é
governada por <code>find_root_abs</code> e <code>find_root_rel</code> que devem ser
números não negativos em ponto flutuante.  <code>find_root</code> terminará quando o
primeiro argumento avaliar para alguma coisa menor que ou igual a <code>find_root_abs</code> ou se
sucessivos aproximandos para a raíz diferirem de não mais que <code>find_root_rel * &lt;um dos aproximandos&gt;</code>.
Os valores padrão de <code>find_root_labs</code> e
<code>find_root_rel</code> é 0.0 de forma que <code>find_root</code> toma como boa uma resposta que for possível
com a precisão aritmética simples que tivermos.
</p>
</dd></dl>

<a name="Item_003a-Numerical_002fdeffn_002fnewton"></a><dl>
<dt><a name="index-newton"></a>Função: <strong>newton</strong> <em>(<var>expr</var>, <var>x</var>, <var>x_0</var>, <var>eps</var>)</em></dt>
<dd><p>Retorna uma solução aproximada de <code><var>expr</var> = 0</code> através do método de Newton,
considerando <var>expr</var> como sendo uma função de uma variável, <var>x</var>.
A busca pela solução começa com <code><var>x</var> = <var>x_0</var></code>
e prossegue até <code>abs(<var>expr</var>) &lt; <var>eps</var></code>
(com <var>expr</var> avaliada para o valor corrente de <var>x</var>).
</p>
<p><code>newton</code> permite que variáveis indefinidas apareçam em <var>expr</var>,
contanto que o teste de terminação <code>abs(<var>expr</var>) &lt; <var>eps</var></code> avalie
para <code>true</code> ou <code>false</code>.
Dessa forma não é necessário que <var>expr</var> avalie para um número.
</p>
<p><code>load(&quot;newton1&quot;)</code> chama essa função.
</p>
<p>Veja também <code>realroots</code>, <code>allroots</code>, <code>find_root</code>, e <code>mnewton</code>.
</p>
<p>Exemplos:
</p>
<div class="example">
<pre class="example">(%i1) load (&quot;newton1&quot;);
(%o1) /usr/share/maxima/5.10.0cvs/share/numeric/newton1.mac
(%i2) newton (cos (u), u, 1, 1/100);
(%o2)                   1.570675277161251
(%i3) ev (cos (u), u = %);
(%o3)                 1.2104963335033528E-4
(%i4) assume (a &gt; 0);
(%o4)                        [a &gt; 0]
(%i5) newton (x^2 - a^2, x, a/2, a^2/100);
(%o5)                  1.00030487804878 a
(%i6) ev (x^2 - a^2, x = %);
                                           2
(%o6)                6.098490481853958E-4 a
</pre></div>

</dd></dl>

<a name="Item_003a-Numerical_002fnode_002fFun_00e7_00f5es-e-Vari_00e1veis-Definidas-para-S_00e9ries-de-Fourier"></a><hr>
<div class="header">
<p>
Pr&oacute;ximo: <a href="maxima_75.html#Fun_00e7_00f5es-e-Vari_00e1veis-Definidas-para-S_00e9ries-de-Fourier" accesskey="n" rel="next">Funções e Variáveis Definidas para Séries de Fourier</a>, Previous: <a href="maxima_73.html#Pacotes-de-Fourier" accesskey="p" rel="previous">Pacotes de Fourier</a>, Acima: <a href="maxima_71.html#Num_00e9rico" accesskey="u" rel="up">Numérico</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Sum&aacute;rio" rel="contents">Conte&uacute;do</a>][<a href="maxima_231.html#g_t_00cdndice-de-Fun_00e7_00f5es-e-Vari_00e1veis" title="&Iacute;ndice" rel="index">&Iacute;ndice</a>]</p>
</div>



</body>
</html>
