<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Manual do Maxima: Funções e Variáveis Definidas para ctensor</title>

<meta name="description" content="Manual do Maxima: Funções e Variáveis Definidas para ctensor">
<meta name="keywords" content="Manual do Maxima: Funções e Variáveis Definidas para ctensor">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="maxima_toc.html#Top" rel="start" title="Top">
<link href="maxima_231.html#g_t_00cdndice-de-Fun_00e7_00f5es-e-Vari_00e1veis" rel="index" title="Índice de Funções e Variáveis">
<link href="maxima_toc.html#SEC_Contents" rel="contents" title="Sum&aacute;rio">
<link href="maxima_89.html#ctensor" rel="up" title="ctensor">
<link href="maxima_92.html#Pacote-atensor" rel="next" title="Pacote atensor">
<link href="maxima_90.html#Introdu_00e7_00e3o-a-ctensor" rel="previous" title="Introdução a ctensor">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 1em; padding-bottom: 1em;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%; display: block; margin-left: auto; margin-right: auto}

-->
</style>

<link rel="icon" href="figures/favicon.ico">

</head>

<body lang="pt" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="Fun_00e7_00f5es-e-Vari_00e1veis-Definidas-para-ctensor"></a>
<div class="header">
<p>
Previous: <a href="maxima_90.html#Introdu_00e7_00e3o-a-ctensor" accesskey="p" rel="previous">Introdução a ctensor</a>, Acima: <a href="maxima_89.html#ctensor" accesskey="u" rel="up">ctensor</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Sum&aacute;rio" rel="contents">Conte&uacute;do</a>][<a href="maxima_231.html#g_t_00cdndice-de-Fun_00e7_00f5es-e-Vari_00e1veis" title="&Iacute;ndice" rel="index">&Iacute;ndice</a>]</p>
</div>

<a name="Funcoes-e-Variaveis-Definidas-para-ctensor"></a>
<h3 class="section">28.2 Funções e Variáveis Definidas para ctensor</h3>

<a name="Inicializacao-e-configuracao"></a>
<h4 class="subsection">28.2.1 Inicialização e configuração</h4>

<a name="Item_003a-Ctensor_002fdeffn_002fcsetup"></a><dl>
<dt><a name="index-csetup"></a>Função: <strong>csetup</strong> <em>()</em></dt>
<dd><p>É uma função no pacote <code>ctensor</code> (component tensor)
que inicializa o pacote e permite ao usuário inserir uma métrica
interativamente. Veja <code>ctensor</code> para mais detalhes.
</p></dd></dl>

<a name="Item_003a-Ctensor_002fdeffn_002fcmetric"></a><dl>
<dt><a name="index-cmetric"></a>Função: <strong>cmetric</strong> <em>(<var>dis</var>)</em></dt>
<dt><a name="index-cmetric-1"></a>Função: <strong>cmetric</strong> <em>()</em></dt>
<dd><p>É uma função no pacote <code>ctensor</code>
que calcula o inverso da métrica e prepara o pacote para
cálculos adiante.
</p>
<p>Se <code>cframe_flag</code> for <code>false</code>, a função calcula a métrica inversa
<code>ug</code> a partir da matriz <code>lg</code> (definida pelo usuário). O determinante da métrica é
também calculado e armazenado na variável <code>gdet</code>. Mais adiante, o
pacote determina se a métrica é diagonal e escolhe o valor
de <code>diagmetric</code> conforme a determinação. Se o argumento opcional <var>dis</var>
estiver presente e não for <code>false</code>, a saída é mostrada ao usuário pela linha de comando para que ele possa ver
o inverso da métrica.
</p>
<p>Se <code>cframe_flag</code> for <code>true</code>, a função espera que o valor de
<code>fri</code> (a matriz moldura inversa) e <code>lfg</code> (a métrica da moldura) sejam
definidas. A partir dessas, a matriz da moldura <code>fr</code> e a métrica da moldura
inversa <code>ufg</code> são calculadas.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdeffn_002fct_005fcoordsys"></a><dl>
<dt><a name="index-ct_005fcoordsys"></a>Função: <strong>ct_coordsys</strong> <em>(<var>sistema_de_coordenadas</var>, <var>extra_arg</var>)</em></dt>
<dt><a name="index-ct_005fcoordsys-1"></a>Função: <strong>ct_coordsys</strong> <em>(<var>sistema_de_coordenadas</var>)</em></dt>
<dd><p>Escolhe um sistema de coordenadas predefinido e uma métrica. O argumento
<var>sistema_de_coordenadas</var> pode ser um dos seguintes símbolos:
</p>
<div class="example">
<pre class="example">
  SYMBOL               Dim Coordenadas       Descrição/comentários
  --------------------------------------------------------------------------
  cartesian2d           2  [x,y]             Sist. de coord. cartesianas 2D
  polar                 2  [r,phi]           Sist. de coord. Polare
  elliptic              2  [u,v]
  confocalelliptic      2  [u,v]
  bipolar               2  [u,v]
  parabolic             2  [u,v]
  cartesian3d           3  [x,y,z]           Sist. de coord. cartesianas 3D
  polarcylindrical      3  [r,theta,z]
  ellipticcylindrical   3  [u,v,z]           Elíptica 2D com Z cilíndrico
  confocalellipsoidal   3  [u,v,w]
  bipolarcylindrical    3  [u,v,z]           Bipolar 2D com Z cilíndrico
  paraboliccylindrical  3  [u,v,z]           Parabólico 2D com Z cilíndrico
  paraboloidal          3  [u,v,phi]
  conical               3  [u,v,w]
  toroidal              3  [u,v,phi]
  spherical             3  [r,theta,phi]     Sist. de coord. Esféricas
  oblatespheroidal      3  [u,v,phi]
  oblatespheroidalsqrt  3  [u,v,phi]
  prolatespheroidal     3  [u,v,phi]
  prolatespheroidalsqrt 3  [u,v,phi]
  ellipsoidal           3  [r,theta,phi]
  cartesian4d           4  [x,y,z,t]         Sist. de coord. 4D
  spherical4d           4  [r,theta,eta,phi]
  exteriorschwarzschild 4  [t,r,theta,phi]   Métrica de Schwarzschild
  interiorschwarzschild 4  [t,z,u,v]        Métrica de Schwarzschild Interior
  kerr_newman           4  [t,r,theta,phi]   Métrica simétrica axialmente alterada

</pre></div>

<p><code>sistema_de_coordenadas</code> pode também ser uma lista de funções de transformação,
seguida por uma lista contendo as varáveis coordenadas. Por exemplo,
você pode especificar uma métrica esférica como segue:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;ctensor&quot;);
(%o1)       /share/tensor/ctensor.mac
(%i2) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
      r*sin(theta),[r,theta,phi]]);
(%o2)                                done
(%i3) lg:trigsimp(lg);
                           [ 1  0         0        ]
                           [                       ]
                           [     2                 ]
(%o3)                      [ 0  r         0        ]
                           [                       ]
                           [         2    2        ]
                           [ 0  0   r  cos (theta) ]
(%i4) ct_coords;
(%o4)                           [r, theta, phi]
(%i5) dim;
(%o5)                                  3

</pre></div>

<p>Funções de transformação podem também serem usadas quando <code>cframe_flag</code> for <code>true</code>:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;ctensor&quot;);
(%o1)       /share/tensor/ctensor.mac
(%i2) cframe_flag:true;
(%o2)                                true
(%i3) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
      r*sin(theta),[r,theta,phi]]);
(%o3)                                done
(%i4) fri;
      [ cos(phi) cos(theta)  - cos(phi) r sin(theta)  - sin(phi) r cos(theta) ]
      [                                                                       ]
(%o4) [ sin(phi) cos(theta)  - sin(phi) r sin(theta)   cos(phi) r cos(theta)  ]
      [                                                                       ]
      [     sin(theta)            r cos(theta)                   0            ]
(%i5) cmetric();
(%o5)                                false
(%i6) lg:trigsimp(lg);
                           [ 1  0         0        ]
                           [                       ]
                           [     2                 ]
(%o6)                      [ 0  r         0        ]
                           [                       ]
                           [         2    2        ]
                           [ 0  0   r  cos (theta) ]

</pre></div>

<p>O argumento opcional <var>extra_arg</var> pode ser qualquer um dos seguintes:
</p>
<p><code>cylindrical</code> diz a <code>ct_coordsys</code> para anexar uma coordenada adicional cilíndrica.
</p>
<p><code>minkowski</code> diz a <code>ct_coordsys</code> para anexar uma coordenada com assinatura métrica negativa.
</p>
<p><code>all</code> diz a <code>ct_coordsys</code> para chamar <code>cmetric</code> e <code>christof(false)</code> após escolher a métrica.
</p>
<p>Se a variável global <code>verbose</code> for escolhida para <code>true</code>, <code>ct_coordsys</code> mostra os valores de <code>dim</code>, <code>ct_coords</code>, e ou <code>lg</code> ou <code>lfg</code> e <code>fri</code>, dependendo do valor de <code>cframe_flag</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdeffn_002finit_005fctensor"></a><dl>
<dt><a name="index-init_005fctensor"></a>Função: <strong>init_ctensor</strong> <em>()</em></dt>
<dd><p>Inicializa o pacote <code>ctensor</code>.
</p>
<p>A função <code>init_ctensor</code> reinicializa o pacote <code>ctensor</code>. Essa função remove todos os arrays e matrizes usados por <code>ctensor</code>, coloca todos os sinalizadores de volta a seus valores padrão, retorna <code>dim</code> para 4, e retorna a métrica da moldura para a métrica da moldura de Lorentz.
</p>
</dd></dl>


<a name="Os-tensores-do-espaco-curvo"></a>
<h4 class="subsection">28.2.2 Os tensores do espaço curvo</h4>

<p>O principal propósito do pacote <code>ctensor</code> é calcular os tensores
do espaç(tempo) curvo, mais notavelmente os tensores usados na relatividade
geral.
</p>
<p>Quando uma base métrica é usada, <code>ctensor</code> pode calcular os seguintes tensores:
</p>
<div class="example">
<pre class="example">
 lg  -- ug
   \      \
    lcs -- mcs -- ric -- uric 
              \      \       \
               \      tracer - ein -- lein
                \
                 riem -- lriem -- weyl
                     \
                      uriem


</pre></div>

<p><code>ctensor</code> pode também usar molduras móveis. Quando <code>cframe_flag</code> for
escolhida para <code>true</code>, os seguintes tensores podem ser calculados:
</p>
<div class="example">
<pre class="example">
 lfg -- ufg
     \
 fri -- fr -- lcs -- mcs -- lriem -- ric -- uric
      \                       |  \      \       \
       lg -- ug               |   weyl   tracer - ein -- lein
                              |\
                              | riem
                              |
                              \uriem

</pre></div>

<a name="Item_003a-Ctensor_002fdeffn_002fchristof"></a><dl>
<dt><a name="index-christof"></a>Função: <strong>christof</strong> <em>(<var>dis</var>)</em></dt>
<dd><p>Uma função no pacote <code>ctensor</code>.
Essa função calcula os símbolos de Christoffel de ambos
os tipos.  O argumento <var>dis</var> determina quais resultados são para serem imediatamente
mostrados.  Os símbolos de Christoffel de primeiro e de segundo tipo são
armazenados nos arrays <code>lcs[i,j,k]</code> e <code>mcs[i,j,k]</code> respectivamente e
definidos para serem simétricos nos primeiros dois índices. Se o argumento para
<code>christof</code> for <code>lcs</code> ou for <code>mcs</code> então o único valor não nulo de <code>lcs[i,j,k]</code>
ou de <code>mcs[i,j,k]</code>, respectivamente, será mostrado. Se o argumento for <code>all</code>
então o único valor não nulo de <code>lcs[i,j,k]</code> e o único valor não nulo de  <code>mcs[i,j,k]</code> serão
mostrados.  Se o argumento for <code>false</code> então a exibição dos elementos
não acontecerá. Os elementos do array <code>mcs[i,j,k]</code> são definidos de uma tal
maneira que o índice final é contravariante.
</p></dd></dl>

<a name="Item_003a-Ctensor_002fdeffn_002fricci"></a><dl>
<dt><a name="index-ricci"></a>Função: <strong>ricci</strong> <em>(<var>dis</var>)</em></dt>
<dd><p>Uma função no pacote <code>ctensor</code>.
<code>ricci</code> calcula as componentes contravariantes
(simétricas) <code>ric[i,j]</code> do tensor de Ricci.  Se o argumento <var>dis</var> for <code>true</code>,
então as componentes não nulas são mostradas.
</p></dd></dl>

<a name="Item_003a-Ctensor_002fdeffn_002furicci"></a><dl>
<dt><a name="index-uricci"></a>Função: <strong>uricci</strong> <em>(<var>dis</var>)</em></dt>
<dd><p>Essa função primeiro calcula as
componentes contravariantes <code>ric[i,j]</code> do tensor de Ricci.
Então o tensor misto de Ricci é calculado usando o
tensor métrico contravariante.  Se o valor do argumento <var>dis</var>
for <code>true</code>, então essas componentes mistas, <code>uric[i,j]</code> (o índice &quot;i&quot; é
covariante e o índice &quot;j&quot; é contravariante), serão mostradas
diretamente.  De outra forma, <code>ricci(false)</code> irá simplesmente calcular as entradas
do array <code>uric[i,j]</code> sem mostrar os resultados.
</p>
</dd></dl>
<a name="Item_003a-Ctensor_002fdeffn_002fscurvature"></a><dl>
<dt><a name="index-scurvature"></a>Função: <strong>scurvature</strong> <em>()</em></dt>
<dd>
<p>Retorna a curvatura escalar (obtida através da contração
do tensor de Ricci) do Riemaniano multiplicado com a métrica dada.
</p>
</dd></dl>
<a name="Item_003a-Ctensor_002fdeffn_002feinstein"></a><dl>
<dt><a name="index-einstein"></a>Função: <strong>einstein</strong> <em>(<var>dis</var>)</em></dt>
<dd><p>Uma função no pacote <code>ctensor</code>.
<code>einstein</code> calcula o tensor misto de Einstein
após os símbolos de Christoffel e o tensor de Ricci terem sido obtidos
(com as funções <code>christof</code> e <code>ricci</code>).  Se o argumento <var>dis</var> for
<code>true</code>, então os valores não nulos do tensor misto de Einstein <code>ein[i,j]</code>
serão mostrados quando <code>j</code> for o índice contravariante.
A variável <code>rateinstein</code> fará com que a simplificação racional ocorra sobre
esses componentes. Se <code>ratfac</code> for <code>true</code> então as componentes irão
também ser fatoradas.
</p>
</dd></dl>
<a name="Item_003a-Ctensor_002fdeffn_002fleinstein"></a><dl>
<dt><a name="index-leinstein"></a>Função: <strong>leinstein</strong> <em>(<var>dis</var>)</em></dt>
<dd><p>Tensor covariante de Einstein. <code>leinstein</code> armazena o valor do tensor covariante de Einstein no array <code>lein</code>. O tensor covariante de Einstein é calculado a partir tensor misto de Einstein <code>ein</code> através da multiplicação desse pelo tensor métrico. Se o argumento <var>dis</var> for <code>true</code>, então os valores não nulos do tensor covariante de Einstein são mostrados.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdeffn_002friemann"></a><dl>
<dt><a name="index-riemann"></a>Função: <strong>riemann</strong> <em>(<var>dis</var>)</em></dt>
<dd><p>Uma função no pacote <code>ctensor</code>.
<code>riemann</code> calcula o tensor de curvatura de Riemann
a partir da métrica dada e correspondendo aos símbolos de Christoffel. As seguintes
convenções de índice são usadas:
</p>
<div class="example">
<pre class="example">                l      _l       _l       _l   _m    _l   _m
 R[i,j,k,l] =  R    = |      - |      + |    |   - |    |
                ijk     ij,k     ik,j     mk   ij    mj   ik
</pre></div>

<p>Essa notação é consistente com a notação usada por no pacote
<code>itensor</code> e sua função <code>icurvature</code>.
Se o argumento opcional <var>dis</var> for <code>true</code>,
as componentes não nulas <code>riem[i,j,k,l]</code> serão mostradas.
Como com o tensor de Einstein, vários comutadores escolhidos pelo usuário
controlam a simplificação de componentes do tensor de Riemann.
Se <code>ratriemann</code> for <code>true</code>, então
simplificação racional será feita. Se <code>ratfac</code>
for <code>true</code> então
cada uma das componentes irá também ser fatorada.
</p>
<p>Se a variável <code>cframe_flag</code> for <code>false</code>, o tensor de Riemann é
calculado diretamente dos símbolos de Christoffel. Se <code>cframe_flag</code> for
<code>true</code>, o tensor covariante de Riemann é calculado primeiro dos
coeficientes de campo da moldura.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdeffn_002flriemann"></a><dl>
<dt><a name="index-lriemann"></a>Função: <strong>lriemann</strong> <em>(<var>dis</var>)</em></dt>
<dd><p>Tensor covariante de Riemann (<code>lriem[]</code>).
</p>
<p>Calcula o tensor covariante de Riemann como o array <code>lriem</code>. Se o
argumento <var>dis</var> for <code>true</code>, únicos valores não nulos são mostrados.
</p>
<p>Se a variável <code>cframe_flag</code> for <code>true</code>, o tensor covariante
de Riemann é calculado diretamente dos coeficientes de campo da moldura. De outra forma,
o tensor (3,1) de Riemann é calculado primeiro.
</p>
<p>Para informação sobre a ordenação de índice, veja <code>riemann</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdeffn_002furiemann"></a><dl>
<dt><a name="index-uriemann"></a>Função: <strong>uriemann</strong> <em>(<var>dis</var>)</em></dt>
<dd><p>Calcula as componentes contravariantes do tensor de curvatura
 de Riemann como elementos do array <code>uriem[i,j,k,l]</code>.  Esses são mostrados
se <var>dis</var> for <code>true</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdeffn_002frinvariant"></a><dl>
<dt><a name="index-rinvariant"></a>Função: <strong>rinvariant</strong> <em>()</em></dt>
<dd><p>Compõe o invariante de Kretchmann (<code>kinvariant</code>) obtido através da
contração dos tensores
</p>
<div class="example">
<pre class="example">lriem[i,j,k,l]*uriem[i,j,k,l].
</pre></div>

<p>Esse objeto não é automaticamente simplificado devido ao fato de poder ser muito largo.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdeffn_002fweyl"></a><dl>
<dt><a name="index-weyl"></a>Função: <strong>weyl</strong> <em>(<var>dis</var>)</em></dt>
<dd><p>Calcula o tensor conformal de Weyl.  Se o argumento <var>dis</var> for
<code>true</code>, as componentes não nulas <code>weyl[i,j,k,l]</code> irão ser mostradas para o
usuário.  De outra forma, essas componentes irão simplesmente serem calculadas e armazenadas.
Se o comutador <code>ratweyl</code> é escolhido para <code>true</code>, então as componentes irão ser
racionalmente simplificadas; se <code>ratfac</code> for <code>true</code> então os resultados irão ser
fatorados também.
</p>
</dd></dl>

<a name="Expansao-das-series-de-Taylor"></a>
<h4 class="subsection">28.2.3 Expansão das séries de Taylor</h4>

<p>O pacote <code>ctensor</code> possui a habilidade para truncar resultados assumindo
que eles são aproximações das séries de Taylor. Esse comportamenteo é controlado através
da variável <code>ctayswitch</code>; quando escolhida para <code>true</code>, <code>ctensor</code> faz uso
internamente da função <code>ctaylor</code> quando simplifica resultados.
</p>
<p>A função <code>ctaylor</code> é invocada pelas seguintes funções de <code>ctensor</code>:
</p>
<div class="example">
<pre class="example">
    Function     Comments
    ---------------------------------
    christof()   só para mcs
    ricci()
    uricci()
    einstein()
    riemann()
    weyl()
    checkdiv()
</pre></div>

<a name="Item_003a-Ctensor_002fdeffn_002fctaylor"></a><dl>
<dt><a name="index-ctaylor"></a>Função: <strong>ctaylor</strong> <em>()</em></dt>
<dd>
<p>A função <code>ctaylor</code> trunca seus argumentos através da conversão
destes para uma série de Taylor usando <code>taylor</code>, e então chamando
<code>ratdisrep</code>. Isso tem efeito combinado de abandonar termos
de ordem mais alta na variável de expansão <code>ctayvar</code>. A ordem
dos termos que podem ser abandonados é definida através de <code>ctaypov</code>; o
ponto em torno do qual a expansão da série é realizada está especificado
em <code>ctaypt</code>.
</p>
<p>Como um exemplo, considere uma métrica simples que é uma perturbação da
métrica de Minkowski. Sem restrições adicionais, mesmo uma métrica
diagonal produz expressões para o tensor de Einstein que são de longe muito
complexas:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;ctensor&quot;);
(%o1)       /share/tensor/ctensor.mac
(%i2) ratfac:true;
(%o2)                                true
(%i3) derivabbrev:true;
(%o3)                                true
(%i4) ct_coords:[t,r,theta,phi];
(%o4)                         [t, r, theta, phi]
(%i5) lg:matrix([-1,0,0,0],[0,1,0,0],[0,0,r^2,0],[0,0,0,r^2*sin(theta)^2]);
                        [ - 1  0  0         0        ]
                        [                            ]
                        [  0   1  0         0        ]
                        [                            ]
(%o5)                   [          2                 ]
                        [  0   0  r         0        ]
                        [                            ]
                        [              2    2        ]
                        [  0   0  0   r  sin (theta) ]
(%i6) h:matrix([h11,0,0,0],[0,h22,0,0],[0,0,h33,0],[0,0,0,h44]);
                            [ h11   0    0    0  ]
                            [                    ]
                            [  0   h22   0    0  ]
(%o6)                       [                    ]
                            [  0    0   h33   0  ]
                            [                    ]
                            [  0    0    0   h44 ]
(%i7) depends(l,r);
(%o7)                               [l(r)]
(%i8) lg:lg+l*h;
         [ h11 l - 1      0          0                 0            ]
         [                                                          ]
         [     0      h22 l + 1      0                 0            ]
         [                                                          ]
(%o8)    [                        2                                 ]
         [     0          0      r  + h33 l            0            ]
         [                                                          ]
         [                                    2    2                ]
         [     0          0          0       r  sin (theta) + h44 l ]
(%i9) cmetric(false);
(%o9)                                done
(%i10) einstein(false);
(%o10)                               done
(%i11) ntermst(ein);
[[1, 1], 62] 
[[1, 2], 0] 
[[1, 3], 0] 
[[1, 4], 0] 
[[2, 1], 0] 
[[2, 2], 24] 
[[2, 3], 0] 
[[2, 4], 0] 
[[3, 1], 0] 
[[3, 2], 0] 
[[3, 3], 46] 
[[3, 4], 0] 
[[4, 1], 0] 
[[4, 2], 0] 
[[4, 3], 0] 
[[4, 4], 46] 
(%o12)                               done

</pre></div>

<p>Todavia, se nós recalcularmos esse exemplo como uma aproximação que é
linear na variável <code>l</code>, pegamos expressões muito simples:
</p>
<div class="example">
<pre class="example">
(%i14) ctayswitch:true;
(%o14)                               true
(%i15) ctayvar:l;
(%o15)                                 l
(%i16) ctaypov:1;
(%o16)                                 1
(%i17) ctaypt:0;
(%o17)                                 0
(%i18) christof(false);
(%o18)                               done
(%i19) ricci(false);
(%o19)                               done
(%i20) einstein(false);
(%o20)                               done
(%i21) ntermst(ein);
[[1, 1], 6] 
[[1, 2], 0] 
[[1, 3], 0] 
[[1, 4], 0] 
[[2, 1], 0] 
[[2, 2], 13] 
[[2, 3], 2] 
[[2, 4], 0] 
[[3, 1], 0] 
[[3, 2], 2] 
[[3, 3], 9] 
[[3, 4], 0] 
[[4, 1], 0] 
[[4, 2], 0] 
[[4, 3], 0] 
[[4, 4], 9] 
(%o21)                               done
(%i22) ratsimp(ein[1,1]);
                         2      2  4               2     2
(%o22) - (((h11 h22 - h11 ) (l )  r  - 2 h33 l    r ) sin (theta)
                              r               r r

                                2               2      4    2
                  - 2 h44 l    r  - h33 h44 (l ) )/(4 r  sin (theta))
                           r r                r



</pre></div>

<p>Essa compatibilidade pode ser útil, por exemplo, quando trabalhamos no limite
do campo fraco longe de uma fonte gravitacional.
</p>
</dd></dl>
    

<a name="Campos-de-moldura"></a>
<h4 class="subsection">28.2.4 Campos de moldura</h4>

<p>Quando a variável <code>cframe_flag</code> for escolhida para <code>true</code>, o pacote <code>ctensor</code>
executa seus cálculos usando uma moldura móvel.
</p>
<a name="Item_003a-Ctensor_002fdeffn_002fframe_005fbracket"></a><dl>
<dt><a name="index-frame_005fbracket"></a>Função: <strong>frame_bracket</strong> <em>(<var>fr</var>, <var>fri</var>, <var>diagframe</var>)</em></dt>
<dd><p>O delimitador da moldura (<code>fb[]</code>).
</p>
<p>Calcula o delimitador da moldura conforme a seguinte definição:
</p>
<div class="example">
<pre class="example">   c          c         c        d     e
ifb   = ( ifri    - ifri    ) ifr   ifr
   ab         d,e       e,d      a     b
</pre></div>

</dd></dl>

<a name="Classificacao-Algebrica"></a>
<h4 class="subsection">28.2.5 Classificação Algébrica</h4>

<p>Um novo recurso (a partir de November de 2004) de <code>ctensor</code> é sua habilidade para
calcular a classificação de Petrov de uma métrica espaço tempo tetradimensional.
Para uma demonstração dessa compatibilidade, veja o arquivo
<code>share/tensor/petrov.dem</code>.
</p>
<a name="Item_003a-Ctensor_002fdeffn_002fnptetrad"></a><dl>
<dt><a name="index-nptetrad"></a>Função: <strong>nptetrad</strong> <em>()</em></dt>
<dd><p>Calcula um tetrad nulo de Newman-Penrose (<code>np</code>) e seus índices ascendentes
em contrapartida (<code>npi</code>). Veja <code>petrov</code> para um exemplo.
</p>
<p>O tetrad nulo é construído assumindo que uma moldura métrica ortonormal
tetradimensional com assinatura métrica (-,+,+,+) está sendo usada.
As componentes do tetrad nulo são relacionadas para a matriz moldura inversa
como segue:
</p>
<div class="example">
<pre class="example">
np  = (fri  + fri ) / sqrt(2)
  1       1      2

np  = (fri  - fri ) / sqrt(2)
  2       1      2

np  = (fri  + %i fri ) / sqrt(2)
  3       3         4

np  = (fri  - %i fri ) / sqrt(2)
  4       3         4

</pre></div>

</dd></dl>

<a name="Item_003a-Ctensor_002fdeffn_002fpsi"></a><dl>
<dt><a name="index-psi-1"></a>Função: <strong>psi</strong> <em>(<var>dis</var>)</em></dt>
<dd><p>Calcula os cinco coeficientes de Newman-Penrose <code>psi[0]</code>...<code>psi[4]</code>.
Se <code>psi</code> for escolhida para <code>true</code>, os coeficientes são mostrados.
Veja <code>petrov</code> para um exemplo.
</p>
<p>Esses coeficientes são calculados a partir do tensor de Weyl em uma base de coordenada.
Se uma base de moldura for usada,o tensor de Weyl é primeiro convertido para a base de
coordenada, que pode ser um procedimento computacional expansível. Por essa razão,
em alguns casos pode ser mais vantajoso usar uma base de coordenada em
primeiro lugar antes que o tensor de Weyl seja calculado. Note todavia, que
para a construção de um tetrad nulo de Newman-Penrose é necessário uma base de moldura. Portanto,
uma seq&uuml;ência de cálculo expressiva pode começar com uma base de moldura, que
é então usada para calcular <code>lg</code> (calculada automaticamente através de <code>cmetric</code>)
e em seguida calcula <code>ug</code>. Nesse ponto, você pode comutar de volta para uma base de coordenada
escolhendo <code>cframe_flag</code> para <code>false</code> antes de começar a calcular os
símbolos de Christoffel. Mudando para uma base de moldura em um estágio posterior pode retornar
resultados inconsistentes, já que você pode terminar com um grande mistura de tensores, alguns
calculados em uma base de moldura, alguns em uma base de coordenada, sem nenhum modo para
disting&uuml;ir entre os dois tipos.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdeffn_002fpetrov"></a><dl>
<dt><a name="index-petrov"></a>Função: <strong>petrov</strong> <em>()</em></dt>
<dd><p>Calcula a classificação de petrov da métrica caracterizada através de <code>psi[0]</code>...<code>psi[4]</code>.
</p>
<p>Por exemplo, o seguinte demonstra como obter a classificação de Petrov
da métrica de Kerr:
</p>
<div class="example">
<pre class="example">(%i1) load(&quot;ctensor&quot;);
(%o1)       /share/tensor/ctensor.mac
(%i2) (cframe_flag:true,gcd:spmod,ctrgsimp:true,ratfac:true);
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) ug:invert(lg)$
(%i5) weyl(false);
(%o5)                                done
(%i6) nptetrad(true);
(%t6) np = 

       [  sqrt(r - 2 m)           sqrt(r)                                     ]
       [ ---------------   ---------------------      0             0         ]
       [ sqrt(2) sqrt(r)   sqrt(2) sqrt(r - 2 m)                              ]
       [                                                                      ]
       [  sqrt(r - 2 m)            sqrt(r)                                    ]
       [ ---------------  - ---------------------     0             0         ]
       [ sqrt(2) sqrt(r)    sqrt(2) sqrt(r - 2 m)                             ]
       [                                                                      ]
       [                                              r      %i r sin(theta)  ]
       [        0                    0             -------   ---------------  ]
       [                                           sqrt(2)       sqrt(2)      ]
       [                                                                      ]
       [                                              r       %i r sin(theta) ]
       [        0                    0             -------  - --------------- ]
       [                                           sqrt(2)        sqrt(2)     ]

                             sqrt(r)          sqrt(r - 2 m)
(%t7) npi = matrix([- ---------------------, ---------------, 0, 0], 
                      sqrt(2) sqrt(r - 2 m)  sqrt(2) sqrt(r)

          sqrt(r)            sqrt(r - 2 m)
[- ---------------------, - ---------------, 0, 0], 
   sqrt(2) sqrt(r - 2 m)    sqrt(2) sqrt(r)

           1               %i
[0, 0, ---------, --------------------], 
       sqrt(2) r  sqrt(2) r sin(theta)

           1                 %i
[0, 0, ---------, - --------------------])
       sqrt(2) r    sqrt(2) r sin(theta)

(%o7)                                done
(%i7) psi(true);
(%t8)                              psi  = 0
                                      0

(%t9)                              psi  = 0
                                      1

                                          m
(%t10)                             psi  = --
                                      2    3
                                          r

(%t11)                             psi  = 0
                                      3

(%t12)                             psi  = 0
                                      4
(%o12)                               done
(%i12) petrov();
(%o12)                                 D

</pre></div>

<p>A função de classificação Petrov é baseada no algorítmo publicado em
&quot;Classifying geometries in general relativity: III Classification in practice&quot;
por Pollney, Skea, e d&rsquo;Inverno, Class. Quant. Grav. 17 2885-2902 (2000).
Exceto para alguns casos de teste simples, a implementação não está testada até
19 de Dezembro de 2004, e é provável que contenha erros.
</p>
</dd></dl>


<a name="Torsao-e-nao-metricidade-1"></a>
<h4 class="subsection">28.2.6 Torsão e não metricidade</h4>

<p><code>ctensor</code> possui a habilidade de calcular e incluir coeficientes de torsão e não
metricidade nos coeficientes de conecção.
</p>
<p>Os coeficientes de torsão são calculados a partir de um tensor fornecido pelo usuário
<code>tr</code>, que pode ser um tensor de categoria (2,1).  A partir disso, os coeficientes de
torsão <code>kt</code> são calculados de acordo com a seguinte fórmula:
</p>
<div class="example">
<pre class="example">
              m          m      m
       - g  tr   - g   tr   - tr   g
          im  kj    jm   ki     ij  km
kt   = -------------------------------
  ijk                 2


  k     km
kt   = g   kt
  ij         ijm

</pre></div>

<p>Note que somente o tensor de índice misto é calculao e armazenado no
array <code>kt</code>.
</p>
<p>Os coeficientes de não metricidade são calculados a partir  do vetor de não metricidade
fornecido pelo usuário <code>nm</code>. A partir disso, os coeficientes de não metricidade
<code>nmc</code> são calculados como segue:
</p>
<div class="example">
<pre class="example">
             k    k        km
       -nm  D  - D  nm  + g   nm  g
   k      i  j    i   j         m  ij
nmc  = ------------------------------
   ij                2

</pre></div>

<p>onde D simboliza o delta de Kronecker.
</p>
<p>Quando <code>ctorsion_flag</code> for escolhida para <code>true</code>, os valores de <code>kt</code>
são subtraídos dos coeficientes de conecção indexados mistos calculados através de
<code>christof</code> e armazenados em <code>mcs</code>. Similarmente, se <code>cnonmet_flag</code>
for escolhida para <code>true</code>, os valores de <code>nmc</code> são subtraídos dos
coeficientes de conecção indexados mistos.
</p>
<p>Se necessário, <code>christof</code> chama as funções <code>contortion</code> e
<code>nonmetricity</code> com o objetivo de calcular <code>kt</code> e <code>nm</code>.
</p>
<a name="Item_003a-Ctensor_002fdeffn_002fcontortion"></a><dl>
<dt><a name="index-contortion"></a>Função: <strong>contortion</strong> <em>(<var>tr</var>)</em></dt>
<dd>
<p>Calcula os coeficientes de contorsão de categoria (2,1) a partir do tensor de torsão <var>tr</var>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdeffn_002fnonmetricity"></a><dl>
<dt><a name="index-nonmetricity"></a>Função: <strong>nonmetricity</strong> <em>(<var>nm</var>)</em></dt>
<dd>
<p>Calcula o coeficiente de não metricidade de categoria (2,1) a partir do vetor de
não metricidade <var>nm</var>.
</p>
</dd></dl>



<a name="Recursos-diversos"></a>
<h4 class="subsection">28.2.7 Recursos diversos</h4>

<a name="Item_003a-Ctensor_002fdeffn_002fctransform"></a><dl>
<dt><a name="index-ctransform"></a>Função: <strong>ctransform</strong> <em>(<var>M</var>)</em></dt>
<dd><p>Uma função no pacote <code>ctensor</code>
que irá executar uma transformação de coordenadas
sobre uma matriz simétrica quadrada arbitrária <var>M</var>. O usuário deve informar as
funçãoes que definem a transformação.  (Formalmente chamada <code>transform</code>.)
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdeffn_002ffindde"></a><dl>
<dt><a name="index-findde"></a>Função: <strong>findde</strong> <em>(<var>A</var>, <var>n</var>)</em></dt>
<dd>
<p>Retorna uma lista de equações diferenciais únicas (expressões)
correspondendo aos elementos do array quadrado <var>n</var> dimensional
<var>A</var>. Atualmente, <var>n</var> pode ser 2 ou 3. <code>deindex</code> é uma lista global
contendo os índices de <var>A</var> correspondendo a essas únicas
equações diferenciais. Para o tensor de Einstein (<code>ein</code>), que
é um array dimensional, se calculado para a métrica no exemplo
abaixo, <code>findde</code> fornece as seguintes equações diferenciais independentes:
</p>

<div class="example">
<pre class="example">(%i1) load(&quot;ctensor&quot;);
(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;
(%o2)                                true
(%i3) dim:4;
(%o3)                                  4
(%i4) lg:matrix([a,0,0,0],[0,x^2,0,0],[0,0,x^2*sin(y)^2,0],[0,0,0,-d]);
                          [ a  0       0        0  ]
                          [                        ]
                          [     2                  ]
                          [ 0  x       0        0  ]
(%o4)                     [                        ]
                          [         2    2         ]
                          [ 0  0   x  sin (y)   0  ]
                          [                        ]
                          [ 0  0       0       - d ]
(%i5) depends([a,d],x);
(%o5)                            [a(x), d(x)]
(%i6) ct_coords:[x,y,z,t];
(%o6)                            [x, y, z, t]
(%i7) cmetric();
(%o7)                                done
(%i8) einstein(false);
(%o8)                                done
(%i9) findde(ein,2);
                                            2
(%o9) [d  x - a d + d, 2 a d d    x - a (d )  x - a  d d  x + 2 a d d
        x                     x x         x        x    x            x

                                                        2          2
                                                - 2 a  d , a  x + a  - a]
                                                     x      x
(%i10) deindex;
(%o10)                     [[1, 1], [2, 2], [4, 4]]

</pre></div>


</dd></dl>
<a name="Item_003a-Ctensor_002fdeffn_002fcograd"></a><dl>
<dt><a name="index-cograd"></a>Função: <strong>cograd</strong> <em>()</em></dt>
<dd><p>Calcula o gradiente covariante de uma função escalar permitindo ao
usuário escolher o nome do vetor correspondente como o exemplo sob
<code>contragrad</code> ilustra.
</p></dd></dl>
<a name="Item_003a-Ctensor_002fdeffn_002fcontragrad"></a><dl>
<dt><a name="index-contragrad"></a>Função: <strong>contragrad</strong> <em>()</em></dt>
<dd>
<p>Calcula o gradiente contravariante de uma função escalar permitindo
ao usuário escolher o nome do vetor correspondente como o exemplo
abaixo como ilustra a métrica de Schwarzschild:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;ctensor&quot;);
(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) depends(f,r);
(%o4)                               [f(r)]
(%i5) cograd(f,g1);
(%o5)                                done
(%i6) listarray(g1);
(%o6)                            [0, f , 0, 0]
                                      r
(%i7) contragrad(f,g2);
(%o7)                                done
(%i8) listarray(g2);
                               f  r - 2 f  m
                                r        r
(%o8)                      [0, -------------, 0, 0]
                                     r

</pre></div>

</dd></dl>
<a name="Item_003a-Ctensor_002fdeffn_002fdscalar"></a><dl>
<dt><a name="index-dscalar-1"></a>Função: <strong>dscalar</strong> <em>()</em></dt>
<dd><p>Calcula o tensor d&rsquo;Alembertiano da função escalar assim que
as dependências tiverem sido declaradas sobre a função. Po exemplo:
</p>
<div class="example">
<pre class="example">(%i1) load(&quot;ctensor&quot;);
(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) depends(p,r);
(%o4)                               [p(r)]
(%i5) factor(dscalar(p));
                          2
                    p    r  - 2 m p    r + 2 p  r - 2 m p
                     r r           r r        r          r
(%o5)               --------------------------------------
                                       2
                                      r
</pre></div>

</dd></dl>
<a name="Item_003a-Ctensor_002fdeffn_002fcheckdiv"></a><dl>
<dt><a name="index-checkdiv"></a>Função: <strong>checkdiv</strong> <em>()</em></dt>
<dd>
<p>Calcula a divergência covariante do tensor de segunda categoria misto
(cujo primeiro índice deve ser covariante) imprimindo as
correspondentes n componentes do campo do vetor (a divergência) onde
n = <code>dim</code>. Se o argumento para a função for <code>g</code> então a
divergência do tensor de Einstein será formada e pode ser zero.
Adicionalmente, a divergência (vetor) é dada no array chamado <code>div</code>.
</p></dd></dl>

<a name="Item_003a-Ctensor_002fdeffn_002fcgeodesic"></a><dl>
<dt><a name="index-cgeodesic"></a>Função: <strong>cgeodesic</strong> <em>(<var>dis</var>)</em></dt>
<dd><p>Uma função no pacote <code>ctensor</code>.
<code>cgeodesic</code> calcula as equações geodésicas de
movimento para uma dada métrica.  Elas são armazenadas no array <code>geod[i]</code>.  Se
o argumento <var>dis</var> for <code>true</code> então essas equações são mostradas.
</p>
</dd></dl>


<a name="Item_003a-Ctensor_002fdeffn_002fbdvac"></a><dl>
<dt><a name="index-bdvac"></a>Função: <strong>bdvac</strong> <em>(<var>f</var>)</em></dt>
<dd>
<p>Gera as componentes covariantes das equações de campo de vácuo da
teoria de gravitação de Brans-Dicke. O campo escalar é especificado
através do argumento <var>f</var>, que pode ser um nome de função (com apóstrofo)
com dependências funcionais, e.g., <code>'p(x)</code>.
</p>
<p>As componentes de segunda categoria do tensor campo covariante são as componentes de segunda categoria
representadas pelo array <code>bd</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdeffn_002finvariant1"></a><dl>
<dt><a name="index-invariant1"></a>Função: <strong>invariant1</strong> <em>()</em></dt>
<dd>
<p>Gera o tensor misto de Euler-Lagrange (equações de campo) para a
densidade invariante de R^2. As equações de campo são componentes de um
array chamado <code>inv1</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdeffn_002finvariant2"></a><dl>
<dt><a name="index-invariant2"></a>Função: <strong>invariant2</strong> <em>()</em></dt>
<dd>
<p>*** NOT YET IMPLEMENTED ***
</p>
<p>Gera o tensor misto de Euler-Lagrange (equações de campo) para a
densidade invariante de <code>ric[i,j]*uriem[i,j]</code>. As equações de campo são as
componentes de um array chamado <code>inv2</code>.
</p>

</dd></dl>
<a name="Item_003a-Ctensor_002fdeffn_002fbimetric"></a><dl>
<dt><a name="index-bimetric"></a>Função: <strong>bimetric</strong> <em>()</em></dt>
<dd>
<p>*** NOT YET IMPLEMENTED ***
</p>
<p>Gera as euauações de campo da teoria bimétrica de Rosen. As equações
de campo são as componentes de um array chamado <code>rosen</code>.
</p>
</dd></dl>

<a name="Funcoes-utilitarias"></a>
<h4 class="subsection">28.2.8 Funções utilitárias</h4>

<a name="Item_003a-Ctensor_002fdeffn_002fdiagmatrixp"></a><dl>
<dt><a name="index-diagmatrixp"></a>Função: <strong>diagmatrixp</strong> <em>(<var>M</var>)</em></dt>
<dd>
<p>Retorna <code>true</code> se <var>M</var> for uma matriz diagonal ou um array (2D).
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdeffn_002fsymmetricp"></a><dl>
<dt><a name="index-symmetricp"></a>Função: <strong>symmetricp</strong> <em>(<var>M</var>)</em></dt>
<dd>
<p>Retorna <code>true</code> se <var>M</var> for uma matriz simétrica ou um array (2D).
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdeffn_002fntermst"></a><dl>
<dt><a name="index-ntermst"></a>Função: <strong>ntermst</strong> <em>(<var>f</var>)</em></dt>
<dd><p>Fornece ao usuário um rápido quadro do &quot;tamanho&quot; do tensor duplamente
subscrito (array) <var>f</var>.  Imprime uma lista de dois elementos onde o segundo
elemento corresponde a N-TERMOS de componentes especificadas através dos primeiros
elementos.  Nesse caminho, é possível rapidamente encontrar as expressões
não nulas e tentar simplificação.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdeffn_002fcdisplay"></a><dl>
<dt><a name="index-cdisplay"></a>Função: <strong>cdisplay</strong> <em>(<var>ten</var>)</em></dt>
<dd><p>Mostra todos os elementos do tensor <var>ten</var>, como representados por
um array multidimensional. Tensores de categoria 0 e 1, assim como outros tipos de
variáveis, são mostrados com <code>ldisplay</code>. Tensores de categoria 2 são
mostrados como matrizes bidimensionais, enquanto tensores de alta categoria são mostrados
como uma lista de matrizes bidimensionais. Por exemplo, o tensor de Riemann da
métrica de Schwarzschild pode ser visto como:
</p>
<div class="example">
<pre class="example">(%i1) load(&quot;ctensor&quot;);
(%o1)       /share/tensor/ctensor.mac
(%i2) ratfac:true;
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) riemann(false);
(%o4)                                done
(%i5) cdisplay(riem);
               [ 0               0                    0            0      ]
               [                                                          ]
               [                              2                           ]
               [      3 m (r - 2 m)   m    2 m                            ]
               [ 0  - ------------- + -- - ----       0            0      ]
               [            4          3     4                            ]
               [           r          r     r                             ]
               [                                                          ]
    riem     = [                                 m (r - 2 m)              ]
        1, 1   [ 0               0               -----------       0      ]
               [                                      4                   ]
               [                                     r                    ]
               [                                                          ]
               [                                              m (r - 2 m) ]
               [ 0               0                    0       ----------- ]
               [                                                   4      ]
               [                                                  r       ]

                                [    2 m (r - 2 m)       ]
                                [ 0  -------------  0  0 ]
                                [          4             ]
                                [         r              ]
                     riem     = [                        ]
                         1, 2   [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]

                                [         m (r - 2 m)    ]
                                [ 0  0  - -----------  0 ]
                                [              4         ]
                                [             r          ]
                     riem     = [                        ]
                         1, 3   [ 0  0        0        0 ]
                                [                        ]
                                [ 0  0        0        0 ]
                                [                        ]
                                [ 0  0        0        0 ]

                                [            m (r - 2 m) ]
                                [ 0  0  0  - ----------- ]
                                [                 4      ]
                                [                r       ]
                     riem     = [                        ]
                         1, 4   [ 0  0  0        0       ]
                                [                        ]
                                [ 0  0  0        0       ]
                                [                        ]
                                [ 0  0  0        0       ]

                               [       0         0  0  0 ]
                               [                         ]
                               [       2 m               ]
                               [ - ------------  0  0  0 ]
                    riem     = [    2                    ]
                        2, 1   [   r  (r - 2 m)          ]
                               [                         ]
                               [       0         0  0  0 ]
                               [                         ]
                               [       0         0  0  0 ]

                   [     2 m                                         ]
                   [ ------------  0        0               0        ]
                   [  2                                              ]
                   [ r  (r - 2 m)                                    ]
                   [                                                 ]
                   [      0        0        0               0        ]
                   [                                                 ]
        riem     = [                         m                       ]
            2, 2   [      0        0  - ------------        0        ]
                   [                     2                           ]
                   [                    r  (r - 2 m)                 ]
                   [                                                 ]
                   [                                         m       ]
                   [      0        0        0         - ------------ ]
                   [                                     2           ]
                   [                                    r  (r - 2 m) ]

                                [ 0  0       0        0 ]
                                [                       ]
                                [            m          ]
                                [ 0  0  ------------  0 ]
                     riem     = [        2              ]
                         2, 3   [       r  (r - 2 m)    ]
                                [                       ]
                                [ 0  0       0        0 ]
                                [                       ]
                                [ 0  0       0        0 ]

                                [ 0  0  0       0       ]
                                [                       ]
                                [               m       ]
                                [ 0  0  0  ------------ ]
                     riem     = [           2           ]
                         2, 4   [          r  (r - 2 m) ]
                                [                       ]
                                [ 0  0  0       0       ]
                                [                       ]
                                [ 0  0  0       0       ]

                                      [ 0  0  0  0 ]
                                      [            ]
                                      [ 0  0  0  0 ]
                                      [            ]
                           riem     = [ m          ]
                               3, 1   [ -  0  0  0 ]
                                      [ r          ]
                                      [            ]
                                      [ 0  0  0  0 ]

                                      [ 0  0  0  0 ]
                                      [            ]
                                      [ 0  0  0  0 ]
                                      [            ]
                           riem     = [    m       ]
                               3, 2   [ 0  -  0  0 ]
                                      [    r       ]
                                      [            ]
                                      [ 0  0  0  0 ]

                               [   m                      ]
                               [ - -   0   0       0      ]
                               [   r                      ]
                               [                          ]
                               [        m                 ]
                               [  0   - -  0       0      ]
                    riem     = [        r                 ]
                        3, 3   [                          ]
                               [  0    0   0       0      ]
                               [                          ]
                               [              2 m - r     ]
                               [  0    0   0  ------- + 1 ]
                               [                 r        ]

                                    [ 0  0  0    0   ]
                                    [                ]
                                    [ 0  0  0    0   ]
                                    [                ]
                         riem     = [            2 m ]
                             3, 4   [ 0  0  0  - --- ]
                                    [             r  ]
                                    [                ]
                                    [ 0  0  0    0   ]

                                [       0        0  0  0 ]
                                [                        ]
                                [       0        0  0  0 ]
                                [                        ]
                     riem     = [       0        0  0  0 ]
                         4, 1   [                        ]
                                [      2                 ]
                                [ m sin (theta)          ]
                                [ -------------  0  0  0 ]
                                [       r                ]

                                [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]
                                [                        ]
                     riem     = [ 0        0        0  0 ]
                         4, 2   [                        ]
                                [         2              ]
                                [    m sin (theta)       ]
                                [ 0  -------------  0  0 ]
                                [          r             ]

                              [ 0  0          0          0 ]
                              [                            ]
                              [ 0  0          0          0 ]
                              [                            ]
                   riem     = [ 0  0          0          0 ]
                       4, 3   [                            ]
                              [                2           ]
                              [         2 m sin (theta)    ]
                              [ 0  0  - ---------------  0 ]
                              [                r           ]

                 [        2                                             ]
                 [   m sin (theta)                                      ]
                 [ - -------------         0                0         0 ]
                 [         r                                            ]
                 [                                                      ]
                 [                         2                            ]
                 [                    m sin (theta)                     ]
      riem     = [        0         - -------------         0         0 ]
          4, 4   [                          r                           ]
                 [                                                      ]
                 [                                          2           ]
                 [                                   2 m sin (theta)    ]
                 [        0                0         ---------------  0 ]
                 [                                          r           ]
                 [                                                      ]
                 [        0                0                0         0 ]

(%o5)                                done

</pre></div>
</dd></dl>

<a name="Item_003a-Ctensor_002fdeffn_002fdeleten"></a><dl>
<dt><a name="index-deleten"></a>Função: <strong>deleten</strong> <em>(<var>L</var>, <var>n</var>)</em></dt>
<dd><p>Retorna uma nova lista consistindo de <var>L</var> com o <var>n</var>&rsquo;ésimo elemento
apagado.
</p></dd></dl>

<a name="Variaveis-usadas-por-ctensor"></a>
<h4 class="subsection">28.2.9 Variáveis usadas por <code>ctensor</code></h4>


<a name="Item_003a-Ctensor_002fdefvr_002fdim"></a><dl>
<dt><a name="index-dim"></a>Variável de opção: <strong>dim</strong></dt>
<dd><p>Valor padrão: 4
</p>
<p>Uma opção no pacote <code>ctensor</code>.
<code>dim</code> é a dimensão de multiplicação com o
padrão 4. O comando <code>dim: n</code> irá escolher a dimensão para qualquer outro
valor <code>n</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002fdiagmetric"></a><dl>
<dt><a name="index-diagmetric"></a>Variável de opção: <strong>diagmetric</strong></dt>
<dd><p>Valor padrão: <code>false</code>
</p>
<p>Uma opção no pacote <code>ctensor</code>.
Se <code>diagmetric</code> for <code>true</code> rotinas especiais calculam
todos os objetos geométricos (que possuem o tensor métrico explicitamente)
levando em consideração a diagonalidade da métrica. Tempo de
execuçào reduzido irá, com certeza, resultar dessa escolha. Nota: essa opção é escolhida
automaticamente por <code>csetup</code> se uma métrica diagonal for especificada.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002fctrgsimp"></a><dl>
<dt><a name="index-ctrgsimp"></a>Variável de opção: <strong>ctrgsimp</strong></dt>
<dd>
<p>Faz com que simplificações trigonométricas sejam usadas quando tensores forem calculados. Atualmente,
<code>ctrgsimp</code> afeta somente cálculos envolvendo uma moldura móvel.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002fcframe_005fflag"></a><dl>
<dt><a name="index-cframe_005fflag"></a>Variável de opção: <strong>cframe_flag</strong></dt>
<dd>
<p>Faz com que cálculos sejam executados relativamente a uma moldura móvel em oposição a
uma métrica holonômica. A moldura é definida através do array da moldura inversa <code>fri</code>
e da métrica da moldura <code>lfg</code>. Para cálculos usando uma moldura Cartesiana,
<code>lfg</code> pode ser a matriz unitária de dimensão apropriada; para
cálculos em uma moldura de Lorentz, <code>lfg</code> pode ter a assinatura
apropriada.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002fctorsion_005fflag"></a><dl>
<dt><a name="index-ctorsion_005fflag"></a>Variável de opção: <strong>ctorsion_flag</strong></dt>
<dd>
<p>Faz com que o tensor de contorsão seja incluído no cálculo dos
coeficientes de conecção. O tensor de contorsão por si mesmo é calculado através de
<code>contortion</code> a partir do tensor <code>tr</code> fornecido pelo usuário.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002fcnonmet_005fflag"></a><dl>
<dt><a name="index-cnonmet_005fflag"></a>Variável de opção: <strong>cnonmet_flag</strong></dt>
<dd>
<p>Faz com que os coeficientes de não metricidade sejam incluídos no cálculo dos
coeficientes de conecção. Os coeficientes de não metricidade são calculados
a partir do vetor de não metricidade <code>nm</code> fornecido pelo usuário através da função
<code>nonmetricity</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002fctayswitch"></a><dl>
<dt><a name="index-ctayswitch"></a>Variável de opção: <strong>ctayswitch</strong></dt>
<dd>
<p>Se escolhida para <code>true</code>, faz com que alguns cálculos de <code>ctensor</code> sejam realizados usando
expansões das séries de Taylor. atualmente, <code>christof</code>, <code>ricci</code>,
<code>uricci</code>, <code>einstein</code>, e <code>weyl</code> levam em conta essa
escolha.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002fctayvar"></a><dl>
<dt><a name="index-ctayvar"></a>Variável de opção: <strong>ctayvar</strong></dt>
<dd>
<p>Variável usada pela expansão de séries de Taylor se <code>ctayswitch</code> é escolhida para
<code>true</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002fctaypov"></a><dl>
<dt><a name="index-ctaypov"></a>Variável de opção: <strong>ctaypov</strong></dt>
<dd>
<p>Maximo expoente usado em expansões de séries de Taylor quando <code>ctayswitch</code> for
escolhida para <code>true</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002fctaypt"></a><dl>
<dt><a name="index-ctaypt"></a>Variável de opção: <strong>ctaypt</strong></dt>
<dd>
<p>Ponto em torno do qual expansões de séries de Taylor sao realizadas quando
<code>ctayswitch</code> for escolhida para <code>true</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002fgdet"></a><dl>
<dt><a name="index-gdet"></a>Variável de sistema: <strong>gdet</strong></dt>
<dd>
<p>O determinante do tensor métrico <code>lg</code>. Calculado através de <code>cmetric</code> quando
<code>cframe_flag</code> for escolhido para <code>false</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002fratchristof"></a><dl>
<dt><a name="index-ratchristof"></a>Variável de opção: <strong>ratchristof</strong></dt>
<dd>
<p>Faz com que simplificações racionais sejam aplicadas através de <code>christof</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002frateinstein"></a><dl>
<dt><a name="index-rateinstein"></a>Variável de opção: <strong>rateinstein</strong></dt>
<dd><p>Valor padrão: <code>true</code>
</p>
<p>Se <code>true</code> simplificação racional será
executada sobre as componentes não nulas de tensores de Einstein; se
<code>ratfac</code> for <code>true</code> então as componentes irão também ser fatoradas.
</p>
</dd></dl>
<a name="Item_003a-Ctensor_002fdefvr_002fratriemann"></a><dl>
<dt><a name="index-ratriemann"></a>Variável de opção: <strong>ratriemann</strong></dt>
<dd><p>Valor padrão: <code>true</code>
</p>
<p>Um dos comutadores que controlam
simplificações dos tensores de Riemann; se <code>true</code>, então simplificações
racionais irão ser concluídas; se <code>ratfac</code> for <code>true</code> então cada uma das
componentes irá também ser fatorada.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002fratweyl"></a><dl>
<dt><a name="index-ratweyl"></a>Variável de opção: <strong>ratweyl</strong></dt>
<dd><p>Valor padrão: <code>true</code>
</p>
<p>Se <code>true</code>, esse comutador faz com que a função de <code>weyl</code>
aplique simplificações racionais aos valores do tensor de Weyl. Se
<code>ratfac</code> for <code>true</code>, então as componentes irão também ser fatoradas.
</p></dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002flfg"></a><dl>
<dt><a name="index-lfg"></a>Variável: <strong>lfg</strong></dt>
<dd><p>A moldura métrica covariante. Por padrão, é inicializada para a moldura tetradimensional de Lorentz com assinatura (+,+,+,-). Usada quando <code>cframe_flag</code> for <code>true</code>.
</p></dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002fufg"></a><dl>
<dt><a name="index-ufg"></a>Variável: <strong>ufg</strong></dt>
<dd><p>A métrica da moldura inversa. Calculada de <code>lfg</code> quando <code>cmetric</code> for chamada enquanto <code>cframe_flag</code> for escolhida para <code>true</code>.
</p></dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002friem"></a><dl>
<dt><a name="index-riem"></a>Variável: <strong>riem</strong></dt>
<dd><p>O tensor de categoria (3,1) de Riemann. Calculado quando a função <code>riemann</code> é invocada. Para informação sobre ordenação de índices, veja a descrição de <code>riemann</code>.
</p>
<p>Se <code>cframe_flag</code> for <code>true</code>, <code>riem</code> é calculado a partir do tensor covariante de Riemann <code>lriem</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002flriem"></a><dl>
<dt><a name="index-lriem"></a>Variável: <strong>lriem</strong></dt>
<dd>
<p>O tensor covariante de Riemann. Calculado através de <code>lriemann</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002furiem"></a><dl>
<dt><a name="index-uriem"></a>Variável: <strong>uriem</strong></dt>
<dd>
<p>O tensor contravariante de Riemann. Calculado através de <code>uriemann</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002fric"></a><dl>
<dt><a name="index-ric"></a>Variável: <strong>ric</strong></dt>
<dd>
<p>O tensor misto de Ricci. Calculado através de <code>ricci</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002furic"></a><dl>
<dt><a name="index-uric"></a>Variável: <strong>uric</strong></dt>
<dd>
<p>O tensor contravariante de Ricci. Calculado através de <code>uricci</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002flg"></a><dl>
<dt><a name="index-lg"></a>Variável: <strong>lg</strong></dt>
<dd>
<p>O tensor métrico. Esse tensor deve ser especificado (como uma <code>dim</code> através da matriz <code>dim</code>)
antes que outro cálculo possa ser executado.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002fug"></a><dl>
<dt><a name="index-ug"></a>Variável: <strong>ug</strong></dt>
<dd>
<p>O inverso do tensor métrico. Calculado através de <code>cmetric</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002fweyl"></a><dl>
<dt><a name="index-weyl-1"></a>Variável: <strong>weyl</strong></dt>
<dd>
<p>O tensor de Weyl. Calculado através de <code>weyl</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002ffb"></a><dl>
<dt><a name="index-fb"></a>Variável: <strong>fb</strong></dt>
<dd>
<p>Coeficientes delimitadores da moldura, como calculado através de <code>frame_bracket</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002fkinvariant"></a><dl>
<dt><a name="index-kinvariant"></a>Variável: <strong>kinvariant</strong></dt>
<dd>
<p>O invariante de Kretchmann. Calculado através de <code>rinvariant</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002fnp"></a><dl>
<dt><a name="index-np"></a>Variável: <strong>np</strong></dt>
<dd>
<p>Um tetrad nulo de Newman-Penrose. Calculado através de <code>nptetrad</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002fnpi"></a><dl>
<dt><a name="index-npi"></a>Variável: <strong>npi</strong></dt>
<dd>
<p>O índice ascendente do tetrad nulo de Newman-Penrose. Calculado através de <code>nptetrad</code>.
Definido como <code>ug.np</code>. O produto <code>np.transpose(npi)</code> é constante:
</p>
<div class="example">
<pre class="example">(%i39) trigsimp(np.transpose(npi));
                              [  0   - 1  0  0 ]
                              [                ]
                              [ - 1   0   0  0 ]
(%o39)                        [                ]
                              [  0    0   0  1 ]
                              [                ]
                              [  0    0   1  0 ]
</pre></div>

</dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002ftr"></a><dl>
<dt><a name="index-tr"></a>Variável: <strong>tr</strong></dt>
<dd>
<p>Tensor de categoria 3 fornecido pelo usuário representando torsão. Usado por <code>contortion</code>.
</p></dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002fkt"></a><dl>
<dt><a name="index-kt"></a>Variável: <strong>kt</strong></dt>
<dd>
<p>O tensor de contorsão, calculado a partir de <code>tr</code> através de <code>contortion</code>.
</p></dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002fnm"></a><dl>
<dt><a name="index-nm"></a>Variável: <strong>nm</strong></dt>
<dd>
<p>Vetor de não metrcidade fornecido pelo usuário. Usado por <code>nonmetricity</code>.
</p></dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002fnmc"></a><dl>
<dt><a name="index-nmc"></a>Variável: <strong>nmc</strong></dt>
<dd>
<p>Os coeficientes de não metricidade, calculados a partir de <code>nm</code> por <code>nonmetricity</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002ftensorkill"></a><dl>
<dt><a name="index-tensorkill"></a>Variável de sistema: <strong>tensorkill</strong></dt>
<dd>
<p>Variável indicando se o pacote tensor foi inicializado. Escolhida e usada por
<code>csetup</code>, retornada ao seu valor original através de <code>init_ctensor</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002fdefvr_002fct_005fcoords"></a><dl>
<dt><a name="index-ct_005fcoords"></a>Variável de opção: <strong>ct_coords</strong></dt>
<dd><p>Valor padrão: <code>[]</code>
</p>
<p>Uma opção no pacote <code>ctensor</code>.
<code>ct_coords</code> contém uma lista de coordenadas.
Enquanto normalmente definida quando a função <code>csetup</code> for chamada,
se pode redefinir as coordenadas com a atribuição
<code>ct_coords: [j1, j2, ..., jn]</code> onde os j&rsquo;s são os novos nomes de coordenadas.
Veja também <code>csetup</code>.
</p>
</dd></dl>

<a name="Nomes-reservados"></a>
<h4 class="subsection">28.2.10 Nomes reservados</h4>

<p>Os seguintes nomes são usados internamente pelo pacote <code>ctensor</code> e
não devem ser redefinidos:
</p>
<div class="example">
<pre class="example">  Name         Description
  ---------------------------------------
  _lg()        Avalia para <code>lfg</code> se a moldura métrica for usada,
                    para <code>lg</code> de outra forma
  _ug()        Avalia para <code>ufg</code> se a moldura métrica for usada,
                    para <code>ug</code> de outra forma
  cleanup()    Remove ítens da lista <code>deindex</code>
  contract4()  Usado por psi()
  filemet()    Usado por csetup() quando lendo a métrica de um arquivo
  findde1()    Usado por findde()
  findde2()    Usado por findde()
  findde3()    Usado por findde()
  kdelt()      Delta de Kronecker (não generalizado)
  newmet()     Usado por csetup() para escolher uma métrica
                    interativamente
  setflags()   Usado por init_ctensor()
  readvalue()
  resimp()
  sermet()     Usado por csetup() para informar uma métricacom série
                    de Taylor
  txyzsum()
  tmetric()    Moldura métrica, usado por cmetric() quando
                    cframe_flag:true
  triemann()   Tensor de Riemann em base de moldura, usado quando
                    cframe_flag:true
  tricci()     Tensor de Ricci em base de moldura, usada quando
                    cframe_flag:true
  trrc()       Coeficientes de rotação de Ricci, usado por
                    christof()
  yesp()
</pre></div>


<a name="Modificacoes"></a>
<h4 class="subsection">28.2.11 Modificações</h4>

<p>Em Novembro de 2004, o pacote <code>ctensor</code> foi extensivamente reescrito.
Muitas funções e variáveis foram renomeadas com o objetivo de tornar o
pacote com a versão comercial do Macsyma.
</p>

<div class="example">
<pre class="example">  Novo Nome    Nome Antigo     Descrição
  --------------------------------------------------------------------
  ctaylor()    DLGTAYLOR()     Expansão da série de Taylor de uma
  -----------------------------expressão
  lgeod[]      EM              Equações geodésicas
  ein[]        G[]             Tensor misto de Einstein
  ric[]        LR[]            Tensor misto de Ricci
  ricci()      LRICCICOM()     Calcula o tensor misto de Ricci
  ctaypov      MINP            Maximo expoente em expansões de séries de
  -----------------------------Taylor
  cgeodesic()  MOTION          Calcula as equações geodésicas
  ct_coords    OMEGA           Coordenadas métricas
  ctayvar      PARAM           Variável de expansão de séries de
  -----------------------------Taylor
  lriem[]      R[]             Tensor covariante de Riemann
  uriemann()   RAISERIEMANN()  Calcula o tensor contravariante de
  -----------------------------Riemann
  ratriemann   RATRIEMAN       Simplificação racional do tensor de
  -----------------------------Riemann
  uric[]       RICCI[]         Tensor de Ricci contravariante
  uricci()     RICCICOM()      Calcula o tensor de Ricci contravariante
  cmetric()    SETMETRIC()     Escolhe a métrica
  ctaypt       TAYPT           Ponto para expansões de séries de Taylor
  ctayswitch   TAYSWITCH       Escolhe o comutador de séries de Taylor
  csetup()     TSETUP()        Inicia sessão interativa de configuração
  ctransform() TTRANSFORM()    Transformação de coordenadas interativa
  uriem[]      UR[]            Tensor contravariante de Riemann 
  weyl[]       W[]             Tensor (3,1) de Weyl

</pre></div>



<hr>
<div class="header">
<p>
Previous: <a href="maxima_90.html#Introdu_00e7_00e3o-a-ctensor" accesskey="p" rel="previous">Introdução a ctensor</a>, Acima: <a href="maxima_89.html#ctensor" accesskey="u" rel="up">ctensor</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Sum&aacute;rio" rel="contents">Conte&uacute;do</a>][<a href="maxima_231.html#g_t_00cdndice-de-Fun_00e7_00f5es-e-Vari_00e1veis" title="&Iacute;ndice" rel="index">&Iacute;ndice</a>]</p>
</div>



</body>
</html>
