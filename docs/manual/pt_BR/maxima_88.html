<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Manual do Maxima: Funções e Variáveis Definidas para itensor</title>

<meta name="description" content="Manual do Maxima: Funções e Variáveis Definidas para itensor">
<meta name="keywords" content="Manual do Maxima: Funções e Variáveis Definidas para itensor">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="maxima_toc.html#Top" rel="start" title="Top">
<link href="maxima_231.html#g_t_00cdndice-de-Fun_00e7_00f5es-e-Vari_00e1veis" rel="index" title="Índice de Funções e Variáveis">
<link href="maxima_toc.html#SEC_Contents" rel="contents" title="Sum&aacute;rio">
<link href="maxima_86.html#itensor" rel="up" title="itensor">
<link href="maxima_89.html#ctensor" rel="next" title="ctensor">
<link href="maxima_87.html#Introdu_00e7_00e3o-a-itensor" rel="previous" title="Introdução a itensor">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 1em; padding-bottom: 1em;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%; display: block; margin-left: auto; margin-right: auto}

-->
</style>

<link rel="icon" href="figures/favicon.ico">

</head>

<body lang="pt" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="Fun_00e7_00f5es-e-Vari_00e1veis-Definidas-para-itensor"></a>
<div class="header">
<p>
Previous: <a href="maxima_87.html#Introdu_00e7_00e3o-a-itensor" accesskey="p" rel="previous">Introdução a itensor</a>, Acima: <a href="maxima_86.html#itensor" accesskey="u" rel="up">itensor</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Sum&aacute;rio" rel="contents">Conte&uacute;do</a>][<a href="maxima_231.html#g_t_00cdndice-de-Fun_00e7_00f5es-e-Vari_00e1veis" title="&Iacute;ndice" rel="index">&Iacute;ndice</a>]</p>
</div>

<a name="Funcoes-e-Variaveis-Definidas-para-itensor"></a>
<h3 class="section">27.2 Funções e Variáveis Definidas para itensor</h3>
<a name="Gerenciando-objetos-indexados"></a>
<h4 class="subsection">27.2.1 Gerenciando objetos indexados</h4>

<a name="Item_003a-Itensor_002fdeffn_002fentertensor"></a><dl>
<dt><a name="index-entertensor"></a>Função: <strong>entertensor</strong> <em>(<var>nome</var>)</em></dt>
<dd>
<p>É uma função que, através da linha de comando, permite criar um objeto
indexado chamado <var>nome</var> com qualquer número de índices de tensores e
derivativos. Ou um índice simples ou uma lista de índices (às quais podem ser
nulas) são entradas aceitáveis (veja o exemplo sob <code>covdiff</code>).
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fchangename"></a><dl>
<dt><a name="index-changename"></a>Função: <strong>changename</strong> <em>(<var>antigo</var>, <var>novo</var>, <var>expr</var>)</em></dt>
<dd>
<p>Irá mudar o nome de todos os objetos indexados chamados <var>antigo</var> para <var>novo</var>
em <var>expr</var>. <var>antigo</var> pode ser ou um símbolo ou uma lista da forma
<code>[<var>nome</var>, <var>m</var>, <var>n</var>]</code> nesse caso somente esses objetos indexados chamados
<var>nome</var> com índice covariante <var>m</var> e índice contravariante <var>n</var> serão
renomeados para <var>novo</var>.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002flistoftens"></a><dl>
<dt><a name="index-listoftens"></a>Função: <strong>listoftens</strong></dt>
<dd>
<p>Lista todos os tensores em uma expressão tensorial, incluindo seus índices. E.g.,
</p>
<div class="example">
<pre class="example">
(%i6) ishow(a([i,j],[k])*b([u],[],v)+c([x,y],[])*d([],[])*e)$
                                         k
(%t6)                        d e c    + a    b
                                  x y    i j  u,v
(%i7) ishow(listoftens(%))$
                               k
(%t7)                        [a   , b   , c   , d]
                               i j   u,v   x y

</pre></div>

</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fishow"></a><dl>
<dt><a name="index-ishow"></a>Função: <strong>ishow</strong> <em>(<var>expr</var>)</em></dt>
<dd>
<p>Mostra <var>expr</var> com os objetos indexados tendo seus
índices covariantes como subscritos e índices contravariantes como
sobrescritos.  Os índices derivativos são mostrados como subscritos,
separados dos índices covariantes por uma vírgula (veja os exemplos
através desse documento).
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002findices"></a><dl>
<dt><a name="index-indices"></a>Função: <strong>indices</strong> <em>(<var>expr</var>)</em></dt>
<dd>
<p>Retorna uma lista de dois elementos.  O primeiro é uma lista de índices
livres em <var>expr</var> (aqueles que ocorrem somente uma vez). O segundo é uma
lista de indices que ocorrem exatamente duas vezes em <var>expr</var> (dummy)
como demonstra o seguinte exemplo.
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i,j],[k,l],m,n)*b([k,o],[j,m,p],q,r))$
                                k l      j m p
(%t2)                          a        b
                                i j,m n  k o,q r
(%i3) indices(%);
(%o3)                 [[l, p, i, n, o, q, r], [k, j, m]]

</pre></div>

<p>Um produto de tensores contendo o mesmo índice mais que duas vezes é sintaticamente
ilegal. <code>indices</code> tenta lidar com essas expressões de uma
forma razoável; todavia, quando <code>indices</code> é chamada para operar sobre tal uma
expressão ilegal, seu comportamento pode ser considerado indefinido.
</p>

</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002frename"></a><dl>
<dt><a name="index-rename"></a>Função: <strong>rename</strong> <em>(<var>expr</var>)</em></dt>
<dt><a name="index-rename-1"></a>Função: <strong>rename</strong> <em>(<var>expr</var>, <var>contador</var>)</em></dt>
<dd>
<p>Retorna uma expressão equivalente para <var>expr</var> mas com índices que ocorrem exatamente duas vezes
em cada termo alterado do conjunto <code>[%1, %2,...]</code>, se o segundo argumento
opcional for omitido. De outra forma, os índices que ocorrem exatamente duas vezes são indexados
começando no valor de <var>contador</var>.  Cada índice que ocorre exatamente duas vezes em um produto
será diferente. Para uma adição, <code>rename</code> irá operar sobre cada termo na
a adição zerando o contador com cada termo. Nesse caminho <code>rename</code> pode
servir como um simplificador tensorial. Adicionalmente, os índices serão
ordenados alfanumericamente (se <code>allsym</code> for <code>true</code>) com relação a
índices covariantes ou contravariantes dependendo do valor de <code>flipflag</code>.
Se <code>flipflag</code> for <code>false</code> então os índices serão renomeados conforme
a ordem dos índices contravariantes. Se <code>flipflag</code> for <code>true</code>
a renomeação ocorrerá conforme a ordem dos índices
covariantes. Isso muitas vezes ajuda que o efeito combinado dos dois restantes sejam
reduzidos a uma expressão de valor um ou mais que um por si mesma.
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) allsym:true;
(%o2)                                true
(%i3) g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%4],[%3])*
ichr2([%2,%3],[u])*ichr2([%5,%6],[%1])*ichr2([%7,r],[%2])-
g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%2],[u])*
ichr2([%3,%5],[%1])*ichr2([%4,%6],[%3])*ichr2([%7,r],[%2]),noeval$
(%i4) expr:ishow(%)$

       %4 %5  %6 %7      %3         u          %1         %2
(%t4) g      g      ichr2      ichr2      ichr2      ichr2
                         %1 %4      %2 %3      %5 %6      %7 r

              %4 %5  %6 %7      u          %1         %3         %2
           - g      g      ichr2      ichr2      ichr2      ichr2
                                %1 %2      %3 %5      %4 %6      %7 r
(%i5) flipflag:true;
(%o5)                                true
(%i6) ishow(rename(expr))$
       %2 %5  %6 %7      %4         u          %1         %3
(%t6) g      g      ichr2      ichr2      ichr2      ichr2
                         %1 %2      %3 %4      %5 %6      %7 r

              %4 %5  %6 %7      u          %1         %3         %2
           - g      g      ichr2      ichr2      ichr2      ichr2
                                %1 %2      %3 %4      %5 %6      %7 r
(%i7) flipflag:false;
(%o7)                                false
(%i8) rename(%th(2));
(%o8)                                  0
(%i9) ishow(rename(expr))$
       %1 %2  %3 %4      %5         %6         %7        u
(%t9) g      g      ichr2      ichr2      ichr2     ichr2
                         %1 %6      %2 %3      %4 r      %5 %7

              %1 %2  %3 %4      %6         %5         %7        u
           - g      g      ichr2      ichr2      ichr2     ichr2
                                %1 %3      %2 %6      %4 r      %5 %7
</pre></div>

</dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002fflipflag"></a><dl>
<dt><a name="index-flipflag"></a>Variável de Opção: <strong>flipflag</strong></dt>
<dd>
<p>Valor padrão: <code>false</code>. Se <code>false</code> então os índices irão ser
renomeados conforme a ordem dos índices contravariantes,
de outra forma serão ordenados conforme a ordem dos índices covariantes.
</p>
<p>Se <code>flipflag</code> for <code>false</code> então <code>rename</code> forma uma lista
de índices contravariantes na ordem em que forem encontrados da esquerda para a direita
(se <code>true</code> então de índices contravariantes). O primeiro índice
que ocorre exatamente duas vezes na lista é renomeado para <code>%1</code>, o seguinte para <code>%2</code>, etc.
Então a ordenação ocorre após a ocorrência do <code>rename</code> (veja o exemplo
sob <code>rename</code>).
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fdefcon"></a><dl>
<dt><a name="index-defcon"></a>Função: <strong>defcon</strong> <em>(<var>tensor_1</var>)</em></dt>
<dt><a name="index-defcon-1"></a>Função: <strong>defcon</strong> <em>(<var>tensor_1</var>, <var>tensor_2</var>, <var>tensor_3</var>)</em></dt>
<dd><p>Dado <var>tensor_1</var> a propriedade que a
contração de um produto do <var>tensor_1</var> e do <var>tensor_2</var> resulta em <var>tensor_3</var>
com os índices apropriados.  Se somente um argumento, <var>tensor_1</var>, for
dado, então a contração do produto de <var>tensor_1</var> com qualquer objeto
indexado tendo os índices apropriados (digamos <code>my_tensor</code>) irá retornar como resultado um
objeto indexado com aquele nome, i.e. <code>my_tensor</code>, e com uma nova escolha de
índices refletindo as contrações executadas.
Por exemplo, se <code>imetric:g</code>, então <code>defcon(g)</code> irá implementar o
incremento e decremento de índices através da contração com o tensor
métrico.
Mais de uma <code>defcon</code> pode ser dada para o mesmo objeto indexado; o
último  fornecido que for aplicado a uma contração particular será
usado.
<code>contractions</code> é uma lista de objetos indexados que tenham fornecido
propriedades de contrações com <code>defcon</code>.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fremcon"></a><dl>
<dt><a name="index-remcon"></a>Função: <strong>remcon</strong> <em>(<var>tensor_1</var>, ..., <var>tensor_n</var>)</em></dt>
<dt><a name="index-remcon-1"></a>Função: <strong>remcon</strong> <em>(all)</em></dt>
<dd><p>Remove todas as propriedades de contração
de <var>tensor_1</var>, ..., <var>tensor_n</var>). <code>remcon(all)</code> remove todas as propriedades de
contração de todos os objetos indexados.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fcontract"></a><dl>
<dt><a name="index-contract"></a>Função: <strong>contract</strong> <em>(<var>expr</var>)</em></dt>
<dd>
<p>Realiza contrações tensoriais em <var>expr</var> a qual pode ser qualquer
combinação de adições e produtos. Essa função usa a informação
dada para a função <code>defcon</code>. Para melhores resultados, <code>expr</code>
pode ser completamente expandida. <code>ratexpand</code> é o meio mais rápido para expandir
produtos e expoentes de adições se não existirem variáveis nos denominadores
dos termos. O comutador <code>gcd</code> pode ser <code>false</code> se cancelamentos de
máximo divisor comum forem desnecessários.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002findexed_005ftensor"></a><dl>
<dt><a name="index-indexed_005ftensor"></a>Função: <strong>indexed_tensor</strong> <em>(<var>tensor</var>)</em></dt>
<dd>
<p>Deve ser executada antes de atribuir componentes para um <var>tensor</var> para o qual
um valor interno já existe como com <code>ichr1</code>, <code>ichr2</code>,
<code>icurvature</code>. Veja o exemplo sob <code>icurvature</code>.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fcomponents"></a><dl>
<dt><a name="index-components"></a>Função: <strong>components</strong> <em>(<var>tensor</var>, <var>expr</var>)</em></dt>
<dd>
<p>Permite que se atribua um valor indicial a uma expressão
<var>expr</var> dando os valores das componentes do <var>tensor</var>. Esses
são automaticamente substituídos para o tensor mesmo que isso ocorra com
todos os seus índices. O tensor deve ser da forma <code>t([...],[...])</code>
onde qualquer lista pode ser vazia. <var>expr</var> pode ser qualquer expressão indexada
envolvendo outros objetos com os mesmos índices livres que <var>tensor</var>. Quando
usada para atribuir valores a um tensor métrico no qual as componentes
possuem índices que ocorrem exatamente duas vezes se deve ser cuidadoso para definir esses índices de forma a
evitar a geração de índices que ocorrem exatamente duas vezes e que são multiplos. a remoção dessas
atribuições é dada para a função <code>remcomps</code>.
</p>
<p>É importante ter em mente que <code>components</code> cuida somente da
valência de um tensor, e que ignora completamente qualquer ordenação particular de índices. Dessa forma
atribuindo componentes a, digamos, <code>x([i,-j],[])</code>, <code>x([-j,i],[])</code>, ou
<code>x([i],[j])</code> todas essas atribuições produzem o mesmo resultado, a saber componentes sendo
atribuidas a um tensor chamado <code>x</code> com valência <code>(1,1)</code>.
</p>
<p>Componentes podem ser atribuidas a uma expressão indexada por quatro caminhos, dois
dos quais envolvem o uso do comando <code>components</code>:
</p>
<p>1) Como uma expressão indexada. Por exemplo:
</p>
<div class="example">
<pre class="example">
(%i2) components(g([],[i,j]),e([],[i])*p([],[j]))$
(%i3) ishow(g([],[i,j]))$
                                      i  j
(%t3)                                e  p

</pre></div>

<p>2) Como uma matriz:
</p>
<div class="example">
<pre class="example">
(%i6) components(g([i,j],[]),lg);
(%o6)                                done
(%i7) ishow(g([i,j],[]))$
(%t7)                                g
                                      i j
(%i8) g([3,3],[]);
(%o8)                                  1
(%i9) g([4,4],[]);
(%o9)                                 - 1

</pre></div>

<p>3) Como uma função. Você pode usar uma função Maxima para especificar as
componentes de um tensor baseado nesses índices. Por exemplo, os seguintes
códigos atribuem <code>kdelta</code> a <code>h</code> se <code>h</code> tiver o mesmo número de
índices covariantes e índices contravariantes e nenhum índice derivativo, e
atribui <code>kdelta</code> a <code>g</code> caso as condições anteriores não sejam atendidas:
</p>
<div class="example">
<pre class="example">
(%i4) h(l1,l2,[l3]):=if length(l1)=length(l2) and length(l3)=0
  then kdelta(l1,l2) else apply(g,append([l1,l2], l3))$
(%i5) ishow(h([i],[j]))$
                                          j
(%t5)                               kdelta
                                          i
(%i6) ishow(h([i,j],[k],l))$
                                     k
(%t6)                               g
                                     i j,l

</pre></div>

<p>4) Usando a compatibilidade dos modelos de coincidência do Maxima, especificamente os
comandos <code>defrule</code> e <code>applyb1</code>:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) matchdeclare(l1,listp);
(%o2)                                done
(%i3) defrule(r1,m(l1,[]),(i1:idummy(),
      g([l1[1],l1[2]],[])*q([i1],[])*e([],[i1])))$

(%i4) defrule(r2,m([],l1),(i1:idummy(),
      w([],[l1[1],l1[2]])*e([i1],[])*q([],[i1])))$

(%i5) ishow(m([i,n],[])*m([],[i,m]))$
                                    i m
(%t5)                              m    m
                                         i n
(%i6) ishow(rename(applyb1(%,r1,r2)))$
                           %1  %2  %3 m
(%t6)                     e   q   w     q   e   g
                                         %1  %2  %3 n


</pre></div>

</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fremcomps"></a><dl>
<dt><a name="index-remcomps"></a>Função: <strong>remcomps</strong> <em>(<var>tensor</var>)</em></dt>
<dd>
<p>Desassocia todos os valores de <var>tensor</var> que foram atribuídos com a
função <code>components</code>.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fshowcomps"></a><dl>
<dt><a name="index-showcomps"></a>Função: <strong>showcomps</strong> <em>(<var>tensor</var>)</em></dt>
<dd>
<p>Mostra atribuições de componentes de um tensor, feitas usando o comando
<code>components</code>. Essa função pode ser particularmente útil quando uma matriz é atribuída
a um tensor indicial usando <code>components</code>, como demonstrado através do
seguinte exemplo:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;ctensor&quot;);
(%o1)       /share/tensor/ctensor.mac
(%i2) load(&quot;itensor&quot;);
(%o2)      /share/tensor/itensor.lisp
(%i3) lg:matrix([sqrt(r/(r-2*m)),0,0,0],[0,r,0,0],
                [0,0,sin(theta)*r,0],[0,0,0,sqrt((r-2*m)/r)]);
               [         r                                     ]
               [ sqrt(-------)  0       0              0       ]
               [      r - 2 m                                  ]
               [                                               ]
               [       0        r       0              0       ]
(%o3)          [                                               ]
               [       0        0  r sin(theta)        0       ]
               [                                               ]
               [                                      r - 2 m  ]
               [       0        0       0        sqrt(-------) ]
               [                                         r     ]
(%i4) components(g([i,j],[]),lg);
(%o4)                                done
(%i5) showcomps(g([i,j],[]));
                  [         r                                     ]
                  [ sqrt(-------)  0       0              0       ]
                  [      r - 2 m                                  ]
                  [                                               ]
                  [       0        r       0              0       ]
(%t5)      g    = [                                               ]
            i j   [       0        0  r sin(theta)        0       ]
                  [                                               ]
                  [                                      r - 2 m  ]
                  [       0        0       0        sqrt(-------) ]
                  [                                         r     ]
(%o5)                                false

</pre></div>

<p>O comando <code>showcomps</code> pode também mostrar componentes de um tensor de
categoria maior que 2.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fidummy"></a><dl>
<dt><a name="index-idummy"></a>Função: <strong>idummy</strong> <em>()</em></dt>
<dd>
<p>Incrementos <code>icounter</code> e retorno como seu valor um índice da forma
<code>%n</code> onde n é um inteiro positivo.  Isso garante que índices que ocorrem exatamente duas vezes
e que são necessários na formação de expressões não irão conflitar com índices
que já estiverem sendo usados (veja o exemplo sob <code>indices</code>).
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002fidummyx"></a><dl>
<dt><a name="index-idummyx"></a>Variável de opção: <strong>idummyx</strong></dt>
<dd><p>Valor padrão: <code>%</code>
</p>
<p>É o prefixo para índices que ocorrem exatamente duas vezes (veja o exemplo sob índices <code>indices</code>).
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002ficounter"></a><dl>
<dt><a name="index-icounter"></a>Variável de Opção: <strong>icounter</strong></dt>
<dd><p>Valor padrão: <code>1</code>
</p>
<p>Determina o sufixo numérico a ser usado na
geração do próximo índice que ocorre exatamente duas vezes no pacote tensor.  O prefixo é
determinado através da opção <code>idummy</code> (padrão: <code>%</code>).
</p></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fkdelta"></a><dl>
<dt><a name="index-kdelta"></a>Função: <strong>kdelta</strong> <em>(<var>L1</var>, <var>L2</var>)</em></dt>
<dd><p>é a função delta generalizada de Kronecker definida no
pacote <code>itensor</code> com <var>L1</var> a lista de índices covariantes e <var>L2</var>
a lista de índices contravariantes.  <code>kdelta([i],[j])</code> retorna o delta de
Kronecker comum.  O comando <code>ev(<var>expr</var>,kdelta)</code> faz com que a avaliação de
uma expressão contendo <code>kdelta([],[])</code> se dê para a dimensão de
multiplicação.
</p>
<p>No que conduzir a um abuso dessa notação, <code>itensor</code> também permite
<code>kdelta</code> ter 2 covariantes e nenhum contravariante, ou 2 contravariantes
e nenhum índice covariante, com efeito fornecendo uma compatibilidade para &quot;matriz unitária&quot; covariante ou
contravariante. Isso é estritamente considerado um recurso de programação e não significa
implicar que <code>kdelta([i,j],[])</code> seja um objeto tensorial válido.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fkdels"></a><dl>
<dt><a name="index-kdels"></a>Função: <strong>kdels</strong> <em>(<var>L1</var>, <var>L2</var>)</em></dt>
<dd>
<p>Delta de Kronecker simetrizado, usado em alguns cálculos. Por exemplo:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) kdelta([1,2],[2,1]);
(%o2)                                 - 1
(%i3) kdels([1,2],[2,1]);
(%o3)                                  1
(%i4) ishow(kdelta([a,b],[c,d]))$
                             c       d         d       c
(%t4)                  kdelta  kdelta  - kdelta  kdelta
                             a       b         a       b
(%i4) ishow(kdels([a,b],[c,d]))$
                             c       d         d       c
(%t4)                  kdelta  kdelta  + kdelta  kdelta
                             a       b         a       b

</pre></div>

</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002flevi_005fcivita"></a><dl>
<dt><a name="index-levi_005fcivita"></a>Função: <strong>levi_civita</strong> <em>(<var>L</var>)</em></dt>
<dd><p>é o tensor de permutação (ou de Levi-Civita) que retorna 1 se
a lista <var>L</var> consistir de uma permutação par de inteiros, -1 se isso
consistir de uma permutação ímpar, e 0 se alguns índices em <var>L</var> forem
repetidos.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002flc2kdt"></a><dl>
<dt><a name="index-lc2kdt"></a>Função: <strong>lc2kdt</strong> <em>(<var>expr</var>)</em></dt>
<dd><p>Simplifica expressões contendo os símbolos de Levi-Civita, convertendo esses
para expressões delta de Kronecker quando possível. A principal diferença entre
essa função e simplesmente avaliar os simbolos de Levi-Civita é que a avaliação
direta muitas vezes resulta em expressões Kronecker contendo índices
numéricos. Isso é muitas vezes indesejável como na prevenção de simplificação adicional.
A função <code>lc2kdt</code> evita esse problema, retornando expressões que
são mais facilmente simplificadas com <code>rename</code> ou <code>contract</code>.
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) expr:ishow('levi_civita([],[i,j])*'levi_civita([k,l],[])*a([j],[k]))$
                                  i j  k
(%t2)                  levi_civita    a  levi_civita
                                       j            k l
(%i3) ishow(ev(expr,levi_civita))$
                                  i j  k       1 2
(%t3)                       kdelta    a  kdelta
                                  1 2  j       k l
(%i4) ishow(ev(%,kdelta))$
             i       j         j       i   k
(%t4) (kdelta  kdelta  - kdelta  kdelta ) a
             1       2         1       2   j

                               1       2         2       1
                        (kdelta  kdelta  - kdelta  kdelta )
                               k       l         k       l
(%i5) ishow(lc2kdt(expr))$
                     k       i       j    k       j       i
(%t5)               a  kdelta  kdelta  - a  kdelta  kdelta
                     j       k       l    j       k       l
(%i6) ishow(contract(expand(%)))$
                                 i           i
(%t6)                           a  - a kdelta
                                 l           l

</pre></div>

<p>A função <code>lc2kdt</code> algumas vezes faz uso de tensores métricos.
Se o tensor métrico não tiver sido definido previamente com <code>imetric</code>,
isso resulta em um erro.
</p>
<div class="example">
<pre class="example">
(%i7) expr:ishow('levi_civita([],[i,j])*'levi_civita([],[k,l])*a([j,k],[]))$
                                 i j            k l
(%t7)                 levi_civita    levi_civita    a
                                                     j k
(%i8) ishow(lc2kdt(expr))$
Maxima encountered a Lisp error:

 Error in $IMETRIC [or a callee]:
 $IMETRIC [or a callee] requires less than two arguments.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
(%i9) imetric(g);
(%o9)                                done
(%i10) ishow(lc2kdt(expr))$
         %3 i       k   %4 j       l     %3 i       l   %4 j       k
(%t10) (g     kdelta   g     kdelta   - g     kdelta   g     kdelta  ) a
                    %3             %4               %3             %4   j k
(%i11) ishow(contract(expand(%)))$
                                  l i      l i
(%t11)                           a    - a g

</pre></div>


</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002flc_005fl"></a><dl>
<dt><a name="index-lc_005fl"></a>Função: <strong>lc_l</strong></dt>
<dd>
<p>Regra de simplificação usada para expressões contendo símbolos não avaliados de
Levi-Civita (<code>levi_civita</code>). Juntamente com <code>lc_u</code>, pode ser usada para simplificar
muitas expressões mais eficientemente que a avaliação de <code>levi_civita</code>.
Por exemplo:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2)  el1:ishow('levi_civita([i,j,k],[])*a([],[i])*a([],[j]))$
                             i  j
(%t2)                       a  a  levi_civita
                                             i j k
(%i3) el2:ishow('levi_civita([],[i,j,k])*a([i])*a([j]))$
                                       i j k
(%t3)                       levi_civita      a  a
                                              i  j
(%i4) ishow(canform(contract(expand(applyb1(el1,lc_l,lc_u)))))$
(%t4)                                  0
(%i5) ishow(canform(contract(expand(applyb1(el2,lc_l,lc_u)))))$
(%t5)                                  0

</pre></div>

</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002flc_005fu"></a><dl>
<dt><a name="index-lc_005fu"></a>Função: <strong>lc_u</strong></dt>
<dd>
<p>Regra de simplificação usada para expressões contendo símbolos não avaliados de
Levi-Civita (<code>levi_civita</code>). Juntamente com <code>lc_u</code>, pode ser usada para simplificar
muitas expressões mais eficientemente que a avaliação de <code>levi_civita</code>.
Para detalhes, veja <code>lc_l</code>.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fcanten"></a><dl>
<dt><a name="index-canten"></a>Função: <strong>canten</strong> <em>(<var>expr</var>)</em></dt>
<dd><p>Simplifica <var>expr</var> por renomeação (veja <code>rename</code>)
e permutando índices que ocorrem exatamente duas vezes. <code>rename</code> é restrito a adições de produto
de tensores nos quais nenhum índice derivativo estiver presente. Como tal isso é limitado
e pode somente ser usado se <code>canform</code> não for capaz de realizar a
simplificação requerida.
</p>
<p>A função <code>canten</code> retorna um resultado matematicamente correto somente
se seu argumento for uma expressão que é completamente simétrica em seus índices.
Por essa razão, <code>canten</code> retorna um erro se <code>allsym</code> não for
posicionada em <code>true</code>.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fconcan"></a><dl>
<dt><a name="index-concan"></a>Função: <strong>concan</strong> <em>(<var>expr</var>)</em></dt>
<dd><p>Similar a <code>canten</code> mas também executa contração de índices.
</p>
</dd></dl>

<a name="Simetrias-de-tensores"></a>
<h4 class="subsection">27.2.2 Simetrias de tensores</h4>

<a name="Item_003a-Itensor_002fdefvr_002fallsym"></a><dl>
<dt><a name="index-allsym"></a>Variável de Opção: <strong>allsym</strong></dt>
<dd>
<p>Valor padrão: <code>false</code>. Se <code>true</code> então todos os objetos indexados
são assumidos simétricos em todos os seus índices covariantes e
contravariantes. Se <code>false</code> então nenhum simétrico de qualquer tipo é assumidos
nesses índices. Índices derivativos são sempre tomados para serem simétricos
a menos que <code>iframe_flag</code> seja escolhida para <code>true</code>.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fdecsym"></a><dl>
<dt><a name="index-decsym"></a>Função: <strong>decsym</strong> <em>(<var>tensor</var>, <var>m</var>, <var>n</var>, [<var>cov_1</var>, <var>cov_2</var>, ...], [<var>contr_1</var>, <var>contr_2</var>, ...])</em></dt>
<dd>
<p>Declara propriedades de simetria para <var>tensor</var> de covariante <var>m</var> e
<var>n</var> índices contravariantes. As <var>cov_i</var> e <var>contr_i</var> são
pseudofunções expressando relações de simetrias em meio a índices covariante e
índices contravariantes respectivamente.  Esses são da forma
<code>symoper(<var>index_1</var>, <var>index_2</var>,...)</code> onde <code>symoper</code> é um entre
<code>sym</code>, <code>anti</code> ou <code>cyc</code> e os <var>index_i</var> são inteiros
indicando a posição do índice no <var>tensor</var>.  Isso irá
declarar <var>tensor</var> para ser simétrico, antisimétrico ou cíclico respectivamente
nos <var>index_i</var>. <code>symoper(all)</code> é também forma permitida que
indica todos os índices obedecem à condição de simetria. Por exemplo, dado um
objeto <code>b</code> com 5 índices covariantes,
<code>decsym(b,5,3,[sym(1,2),anti(3,4)],[cyc(all)])</code> declara <code>b</code>
simétrico no seu primeiro e no seu segundo índices e antisimétrico no seu terceiro e
quarto índices covariantes, e cíclico em todos de seus índices contravariantes.
Qualquer lista de declarações de simetria pode ser nula.  A função que
executa as simplificações é <code>canform</code> como o exemplo abaixo
ilustra.
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) expr:contract(expand(a([i1,j1,k1],[])*kdels([i,j,k],[i1,j1,k1])))$
(%i3) ishow(expr)$
(%t3)         a      + a      + a      + a      + a      + a
               k j i    k i j    j k i    j i k    i k j    i j k
(%i4) decsym(a,3,0,[sym(all)],[]);
(%o4)                                done
(%i5) ishow(canform(expr))$
(%t5)                              6 a
                                      i j k
(%i6) remsym(a,3,0);
(%o6)                                done
(%i7) decsym(a,3,0,[anti(all)],[]);
(%o7)                                done
(%i8) ishow(canform(expr))$
(%t8)                                  0
(%i9) remsym(a,3,0);
(%o9)                                done
(%i10) decsym(a,3,0,[cyc(all)],[]);
(%o10)                               done
(%i11) ishow(canform(expr))$
(%t11)                        3 a      + 3 a
                                 i k j      i j k
(%i12) dispsym(a,3,0);
(%o12)                     [[cyc, [[1, 2, 3]], []]]

</pre></div>


</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fremsym"></a><dl>
<dt><a name="index-remsym"></a>Função: <strong>remsym</strong> <em>(<var>tensor</var>, <var>m</var>, <var>n</var>)</em></dt>
<dd><p>Remove todas as propriedades de simetria de <var>tensor</var> que tem <var>m</var>
índices covariantes e <var>n</var> índices contravariantes.
</p></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fcanform"></a><dl>
<dt><a name="index-canform"></a>Função: <strong>canform</strong> <em>(<var>expr</var>)</em></dt>
<dd><p>Simplifica <var>expr</var> através de mudança de nome de índices
que ocorrem exatamente duas vezes e reordenação de todos os índices como ditados pelas condições de simetria
impostas sobre eles. Se <code>allsym</code> for <code>true</code> então todos os índices são assumidos
simétricos, de outra forma a informação de simetria fornecida pelas declarações
<code>decsym</code> irão ser usadas. Os índices que ocorrem exatamente duas vezes são renomeados da mesma
maneira que na função <code>rename</code>. Quando <code>canform</code> é aplicada a uma expressão
larga o cálculo pode tomar um considerável montante de tempo.
Esse tempo pode ser diminuído através do uso de <code>rename</code> sobre a expressão em primeiro lugar.
Também veja o exemplo sob <code>decsym</code>. Nota: <code>canform</code> pode não estar apta a
reduzir um expressão completamente para sua forma mais simples embora
retorne sempre um resultado matemáticamente correto.
</p></dd></dl>

<a name="Calculo-de-tensores-indiciais"></a>
<h4 class="subsection">27.2.3 Cálculo de tensores indiciais</h4>

<a name="Item_003a-Itensor_002fdeffn_002fdiff"></a><dl>
<dt><a name="index-diff-4"></a>Função: <strong>diff</strong> <em>(<var>expr</var>, <var>v_1</var>, [<var>n_1</var>, [<var>v_2</var>, <var>n_2</var>] ...])</em></dt>
<dd>
<p>É a função usual de diferenciação do Maxima que tem sido expandida
nessas habilidades para <code>itensor</code>. <code>diff</code> toma a derivada de <var>expr</var>
 <var>n_1</var> vezes com relação a <var>v_1</var>, <var>n_2</var> vezes com relação a <var>v_2</var>
, etc. Para o pacote <code>tensor</code>, a função tem sido modificada de
forma que os <var>v_i</var> possam ser inteiros de 1 até o valor da variável
<code>dim</code>.  Isso causará a conclusão da diferenciação com
relação ao <var>v_i</var>ésimo membro da lista <code>vect_coords</code>.  Se
<code>vect_coords</code> for associado a uma variável atômica, então aquela variável
subscrita através de <var>v_i</var> será usada para a variável de
diferenciação.  Isso permite que um array de nomes de coordenadas ou
nomes subscritos como <code>x[1]</code>, <code>x[2]</code>, ...  sejam usados.
</p></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fidiff"></a><dl>
<dt><a name="index-idiff"></a>Função: <strong>idiff</strong> <em>(<var>expr</var>, <var>v_1</var>, [<var>n_1</var>, [<var>v_2</var>, <var>n_2</var>] ...])</em></dt>
<dd><p>Diferenciação indicial. A menos que <code>diff</code>, que diferencia
com relação a uma variável independente, <code>idiff</code> possa ser usada
para diferenciar com relação a uma coordenada. Para um objeto indexado,
isso equivale a anexar ao final os <var>v_i</var> como índices derivativos.
Subseq&uuml;êntemente, índices derivativos irão ser ordenados, a menos que <code>iframe_flag</code>
seja escolhida para <code>true</code>.
</p>
<p><code>idiff</code> pode também ser o determinante de um tensor
métrico. Dessa forma, se <code>imetric</code> tiver sido associada a <code>G</code> então
<code>idiff(determinant(g),k)</code> irá retornar
<code>2*determinant(g)*ichr2([%i,k],[%i])</code> onde o índice que ocorre exatamente duas vezes <code>%i</code>
é escolhido apropriadamente.
</p>

</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fliediff"></a><dl>
<dt><a name="index-liediff"></a>Função: <strong>liediff</strong> <em>(<var>v</var>, <var>ten</var>)</em></dt>
<dd>
<p>Calcula a derivada de Lie da expressão tensorial <var>ten</var> com
relação ao campo vetorial <var>v</var>. <var>ten</var> pode ser qualquer expressão tensorial
indexada; <var>v</var> pode ser o nome (sem índices) de um campo
vetorial. Por exemplo:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(liediff(v,a([i,j],[])*b([],[k],l)))$
       k    %2            %2          %2
(%t2) b   (v   a       + v   a     + v   a    )
       ,l       i j,%2    ,j  i %2    ,i  %2 j

                                %1  k        %1  k      %1  k
                            + (v   b      - b   v    + v   b   ) a
                                    ,%1 l    ,l  ,%1    ,l  ,%1   i j

</pre></div>


</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002frediff"></a><dl>
<dt><a name="index-rediff"></a>Função: <strong>rediff</strong> <em>(<var>ten</var>)</em></dt>
<dd>
<p>Avalia todas as ocorrências do comando <code>idiff</code> na expressão
tensorial <var>ten</var>.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fundiff"></a><dl>
<dt><a name="index-undiff"></a>Função: <strong>undiff</strong> <em>(<var>expr</var>)</em></dt>
<dd>
<p>Retorna uma expressão equivalente a <var>expr</var> mas com todas as derivadas
de objetos indexados substituídas pela forma substantiva da função <code>idiff</code>. Seu
argumento pode retornar aquele objeto indexado se a diferenciação for
concluída.  Isso é útil quando for desejado substituir um
objeto indexado que sofreu diferenciação com alguma definição de função resultando
em <var>expr</var> e então concluir a diferenciação através de digamos
<code>ev(<var>expr</var>, idiff)</code>.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fevundiff"></a><dl>
<dt><a name="index-evundiff"></a>Função: <strong>evundiff</strong> <em>(<var>expr</var>)</em></dt>
<dd>
<p>Equivalente à execução de <code>undiff</code>, seguida por <code>ev</code> e
<code>rediff</code>.
</p>
<p>O ponto dessa operação é facilmente avaliar expressões que não possam
ser diretamente avaliadas na forma derivada. Por exemplo, o seguinte
causa um erro:
</p>
<div class="example">
<pre class="example">(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) icurvature([i,j,k],[l],m);
Maxima encountered a Lisp error:

 Error in $ICURVATURE [or a callee]:
 $ICURVATURE [or a callee] requires less than three arguments.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
</pre></div>

<p>Todavia, se <code>icurvature</code> é informado em sua forma substantiva, pode ser avaliado
usando <code>evundiff</code>:
</p>
<div class="example">
<pre class="example">(%i3) ishow('icurvature([i,j,k],[l],m))$
                                         l
(%t3)                          icurvature
                                         i j k,m
(%i4) ishow(evundiff(%))$
             l              l         %1           l           %1
(%t4) - ichr2        - ichr2     ichr2      - ichr2       ichr2
             i k,j m        %1 j      i k,m        %1 j,m      i k

                l              l         %1           l           %1
         + ichr2        + ichr2     ichr2      + ichr2       ichr2
                i j,k m        %1 k      i j,m        %1 k,m      i j
</pre></div>

<p>Nota: Em versões anteriores do Maxima, formas derivadas dos
símbolos de Christoffel também não podiam ser avaliadas. Isso foi corrigido atualmente,
de forma que <code>evundiff</code> não mais é necessária para expressões como essa:
</p>
<div class="example">
<pre class="example">(%i5) imetric(g);
(%o5)                                done
(%i6) ishow(ichr2([i,j],[k],l))$
       k %3
      g     (g         - g         + g        )
              j %3,i l    i j,%3 l    i %3,j l
(%t6) -----------------------------------------
                          2

                         k %3
                        g     (g       - g       + g      )
                         ,l     j %3,i    i j,%3    i %3,j
                      + -----------------------------------
                                         2
</pre></div>


</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fflush"></a><dl>
<dt><a name="index-flush"></a>Função: <strong>flush</strong> <em>(<var>expr</var>, <var>tensor_1</var>, <var>tensor_2</var>, ...)</em></dt>
<dd><p>Escolhe para zero, em
<var>expr</var>, todas as ocorrências de <var>tensor_i</var> que não tiverem índices derivativos.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fflushd"></a><dl>
<dt><a name="index-flushd"></a>Função: <strong>flushd</strong> <em>(<var>expr</var>, <var>tensor_1</var>, <var>tensor_2</var>, ...)</em></dt>
<dd><p>Escolhe para zero, em
<var>expr</var>, todas as ocorrências de <var>tensor_i</var> que tiverem índices derivativos.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fflushnd"></a><dl>
<dt><a name="index-flushnd"></a>Função: <strong>flushnd</strong> <em>(<var>expr</var>, <var>tensor</var>, <var>n</var>)</em></dt>
<dd><p>Escolhe para zero, em <var>expr</var>, todas as
ocorrências do objeto diferenciado <var>tensor</var> que tem <var>n</var> ou mais
índices derivativos como demonstra o seguinte exemplo.
</p><div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i],[J,r],k,r)+a([i],[j,r,s],k,r,s))$
                                J r      j r s
(%t2)                          a      + a
                                i,k r    i,k r s
(%i3) ishow(flushnd(%,a,3))$
                                     J r
(%t3)                               a
                                     i,k r
</pre></div>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fcoord"></a><dl>
<dt><a name="index-coord"></a>Função: <strong>coord</strong> <em>(<var>tensor_1</var>, <var>tensor_2</var>, ...)</em></dt>
<dd>
<p>Dados os <var>tensor_i</var> a propriedade de diferenciação da coordenada que a
derivada do vetor contravariante cujo nome é um dos
<var>tensor_i</var> retorna um delta de Kronecker. Por exemplo, se <code>coord(x)</code> tiver
sido concluída então <code>idiff(x([],[i]),j)</code> fornece <code>kdelta([i],[j])</code>.
<code>coord</code> que é uma lista de todos os objetos indexados tendo essa propriedade.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fremcoord"></a><dl>
<dt><a name="index-remcoord"></a>Função: <strong>remcoord</strong> <em>(<var>tensor_1</var>, <var>tensor_2</var>, ...)</em></dt>
<dt><a name="index-remcoord-1"></a>Função: <strong>remcoord</strong> <em>(all)</em></dt>
<dd>
<p>Remove a propriedade de coordenada de diferenciação dos <code>tensor_i</code>
que foram estabelecidos através da função <code>coord</code>.  <code>remcoord(all)</code>
remove essa propriedade de todos os objetos indexados.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fmakebox"></a><dl>
<dt><a name="index-makebox"></a>Função: <strong>makebox</strong> <em>(<var>expr</var>)</em></dt>
<dd><p>Mostra <var>expr</var> da mesma maneira que <code>show</code>; todavia,
qualquer tensor d&rsquo;Alembertiano ocorrendo em <var>expr</var> será indicado usando o
símbolo <code>[]</code>.  Por exemplo, <code>[]p([m],[n])</code> representa
<code>g([],[i,j])*p([m],[n],i,j)</code>.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fconmetderiv"></a><dl>
<dt><a name="index-conmetderiv"></a>Função: <strong>conmetderiv</strong> <em>(<var>expr</var>, <var>tensor</var>)</em></dt>
<dd>
<p>Simplifica expressões contendo derivadas comuns de
ambas as formas covariantes e contravariantes do tensor métrico (a
restrição corrente).  Por exemplo, <code>conmetderiv</code> pode relatar a
derivada do tensor contravariante métrico com símbolos de
Christoffel como visto adiante:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(g([],[a,b],c))$
                                      a b
(%t2)                                g
                                      ,c
(%i3) ishow(conmetderiv(%,g))$
                         %1 b      a       %1 a      b
(%t3)                 - g     ichr2     - g     ichr2
                                   %1 c              %1 c
</pre></div>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fsimpmetderiv"></a><dl>
<dt><a name="index-simpmetderiv"></a>Função: <strong>simpmetderiv</strong> <em>(<var>expr</var>)</em></dt>
<dt><a name="index-simpmetderiv-1"></a>Função: <strong>simpmetderiv</strong> <em>(<var>expr</var>[, <var>stop</var>])</em></dt>
<dd>
<p>Simplifica expressões contendo produtos de derivadas de
tensores métricos. Especificamente, <code>simpmetderiv</code> reconhece duas identidades:
</p>
<div class="example">
<pre class="example">
   ab        ab           ab                 a
  g   g   + g   g     = (g   g  )   = (kdelta )   = 0
   ,d  bc        bc,d         bc ,d          c ,d

</pre></div>

<p>conseq&uuml;êntemente
</p>
<div class="example">
<pre class="example">
   ab          ab
  g   g   = - g   g
   ,d  bc          bc,d
</pre></div>

<p>e
</p>
<div class="example">
<pre class="example">
  ab          ab
 g   g     = g   g
  ,j  ab,i    ,i  ab,j

</pre></div>

<p>que seguem de simetrias de símbolos de Christoffel.
</p>
<p>A função <code>simpmetderiv</code> toma um parâmetro opcional que, quando
presente, faz com que a função pare após a primeira substituição feita com
sucesso em uma expressão produto. A função <code>simpmetderiv</code>
também faz uso da variável global <var>flipflag</var> que determina
como aplicar uma ordenação &ldquo;canonica&rdquo; para os índices de produto.
</p>
<p>Colocados juntos, essas compatibilidades podem ser usadas poderosamente para encontrar
simplificações que são difíceis ou impossíveis de realizar de outra forma.
Isso é demonstrado através do seguinte exemplo que explicitamente usa o 
recurso de simplificação parcial de <code>simpmetderiv</code> para obter uma
expressão contractível:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                                done
(%i3) ishow(g([],[a,b])*g([],[b,c])*g([a,b],[],d)*g([b,c],[],e))$
                             a b  b c
(%t3)                       g    g    g      g
                                       a b,d  b c,e
(%i4) ishow(canform(%))$

errexp1 has improper indices
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) ishow(simpmetderiv(%))$
                             a b  b c
(%t5)                       g    g    g      g
                                       a b,d  b c,e
(%i6) flipflag:not flipflag;
(%o6)                                true
(%i7) ishow(simpmetderiv(%th(2)))$
                               a b  b c
(%t7)                         g    g    g    g
                               ,d   ,e   a b  b c
(%i8) flipflag:not flipflag;
(%o8)                                false
(%i9) ishow(simpmetderiv(%th(2),stop))$
                               a b  b c
(%t9)                       - g    g    g      g
                                    ,e   a b,d  b c
(%i10) ishow(contract(%))$
                                    b c
(%t10)                           - g    g
                                    ,e   c b,d

</pre></div>

<p>Veja também <code>weyl.dem</code> para um exemplo que usa <code>simpmetderiv</code>
e <code>conmetderiv</code> juntos para simplificar contrações do tensor de Weyl.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fflush1deriv"></a><dl>
<dt><a name="index-flush1deriv"></a>Função: <strong>flush1deriv</strong> <em>(<var>expr</var>, <var>tensor</var>)</em></dt>
<dd>
<p>Escolhe para zero, em <code>expr</code>, todas as ocorrências de <code>tensor</code> que possuem
exatamente um índice derivativo.
</p>
</dd></dl>

<a name="Tensores-em-espacos-curvos"></a>
<h4 class="subsection">27.2.4 Tensores em espaços curvos</h4>

<a name="Item_003a-Itensor_002fdeffn_002fimetric"></a><dl>
<dt><a name="index-imetric"></a>Função: <strong>imetric</strong> <em>(<var>g</var>)</em></dt>
<dt><a name="index-imetric-1"></a>Variável de sistema: <strong>imetric</strong></dt>
<dd>
<p>Especifica a métrica através de atribuição à variável <code>imetric:<var>g</var></code>
adicionalmente, as propriedades de contração da métrica <var>g</var> são escolhidas através da
execução dos comandos <code>defcon(<var>g</var>),defcon(<var>g</var>,<var>g</var>,kdelta)</code>.
A variável <code>imetric</code> (desassociada por padrão), é associada à métrica, atribuida pelo
comando <code>imetric(<var>g</var>)</code>.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fidim"></a><dl>
<dt><a name="index-idim"></a>Função: <strong>idim</strong> <em>(<var>n</var>)</em></dt>
<dd><p>Escolhe as dimensões da métrica. Também inicializa as propriedades de
antisimetria dos símbolos de Levi-Civita para as dimensões dadas.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fichr1"></a><dl>
<dt><a name="index-ichr1"></a>Função: <strong>ichr1</strong> <em>([<var>i</var>, <var>j</var>, <var>k</var>])</em></dt>
<dd><p>Retorna o símbolo de Christoffel de primeiro tipo via
definição
</p><div class="example">
<pre class="example">       (g      + g      - g     )/2 .
         ik,j     jk,i     ij,k
</pre></div>
<p>Para avaliar os símbolos de Christoffel para uma métrica particular, à
variável <code>imetric</code> deve ser atribuída um nome como no exemplo sob <code>chr2</code>.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fichr2"></a><dl>
<dt><a name="index-ichr2"></a>Função: <strong>ichr2</strong> <em>([<var>i</var>, <var>j</var>], [<var>k</var>])</em></dt>
<dd><p>Retorna o símbolo de Christoffel de segundo tipo
definido pela relação
</p><div class="example">
<pre class="example">                       ks
   ichr2([i,j],[k]) = g    (g      + g      - g     )/2
                             is,j     js,i     ij,s
</pre></div>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002ficurvature"></a><dl>
<dt><a name="index-icurvature"></a>Função: <strong>icurvature</strong> <em>([<var>i</var>, <var>j</var>, <var>k</var>], [<var>h</var>])</em></dt>
<dd><p>Retorna o tensor da curvatura de
Riemann em termos de símbolos de Christoffel de segundo
tipo (<code>ichr2</code>).  A seguinte notação é usada:
</p><div class="example">
<pre class="example">               h             h            h         %1         h
     icurvature     = - ichr2      - ichr2     ichr2    + ichr2
               i j k         i k,j        %1 j      i k        i j,k
                               h          %1
                        + ichr2      ichr2
                               %1 k       i j
</pre></div>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fcovdiff"></a><dl>
<dt><a name="index-covdiff"></a>Função: <strong>covdiff</strong> <em>(<var>expr</var>, <var>v_1</var>, <var>v_2</var>, ...)</em></dt>
<dd><p>Retorna a derivada da covariante de <var>expr</var> com
relação às variáveis <var>v_i</var> em termos de símbolos de Christoffel de
segundo tipo (<code>ichr2</code>).  Com o objetivo de avaliar esses, se pode usar
<code>ev(<var>expr</var>,ichr2)</code>.
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) entertensor()$
Enter tensor name: a;
Enter a list of the índices covariantes: [i,j];
Enter a list of the índices contravariantes: [k];
Enter a list of the derivative indices: [];
                                      k
(%t2)                                a
                                      i j
(%i3) ishow(covdiff(%,s))$
             k         %1     k         %1     k            k     %1
(%t3)     - a     ichr2    - a     ichr2    + a      + ichr2     a
             i %1      j s    %1 j      i s    i j,s        %1 s  i j
(%i4) imetric:g;
(%o4)            g
(%i5) ishow(ev(%th(2),ichr2))$
  %1 %4  k
 g      a     (g       - g       + g  )
  i %1   s %4,j  j s,%4    j %4,s
(%t5) - ------------------------------------------
       2
    %1 %3  k
   g   a     (g       - g    + g     )
    %1 j   s %3,i    i s,%3    i %3,s
 - ------------------------------------------
         2
    k %2  %1
   g     a    (g        - g    + g      )
   i j   s %2,%1    %1 s,%2    %1 %2,s   k
 + ------------------------------------------- + a
   2     i j,s
(%i6) 
</pre></div>

</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002florentz_005fgauge"></a><dl>
<dt><a name="index-lorentz_005fgauge"></a>Função: <strong>lorentz_gauge</strong> <em>(<var>expr</var>)</em></dt>
<dd><p>Impõe a condição de Lorentz através da substituição de 0 para todos os
objetos indexados em <var>expr</var> que possui um índice de derivada idêntico ao
índice contravariante.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002figeodesic_005fcoords"></a><dl>
<dt><a name="index-igeodesic_005fcoords"></a>Função: <strong>igeodesic_coords</strong> <em>(<var>expr</var>, <var>nome</var>)</em></dt>
<dd>
<p>Faz com que símbolos de Christoffel não diferenciados e
a primeira derivada do tensor métrico tendam para zero em <var>expr</var>. O <var>nome</var>
na função <code>igeodesic_coords</code> refere-se à métrica <var>nome</var>
(se isso aparecer em <var>expr</var>) enquando os coeficientes de conecção devem ser
chamados com os nomes <code>ichr1</code> e/ou <code>ichr2</code>. O seguinte exemplo
demonstra a verificação da identidade cíclica satisfeita através do tensor da
curvatura de Riemann usando a função <code>igeodesic_coords</code>.
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(icurvature([r,s,t],[u]))$
             u            u         %1         u            u         %1
(%t2) - ichr2      - ichr2     ichr2    + ichr2      + ichr2     ichr2
             r t,s        %1 s      r t        r s,t        %1 t      r s
(%i3) ishow(igeodesic_coords(%,ichr2))$
                                 u            u
(%t3)                       ichr2      - ichr2
                                 r s,t        r t,s
(%i4) ishow(igeodesic_coords(icurvature([r,s,t],[u]),ichr2)+
            igeodesic_coords(icurvature([s,t,r],[u]),ichr2)+
            igeodesic_coords(icurvature([t,r,s],[u]),ichr2))$
             u            u            u            u            u
(%t4) - ichr2      + ichr2      + ichr2      - ichr2      - ichr2
             t s,r        t r,s        s t,r        s r,t        r t,s

                                                                  u
                                                           + ichr2
                                                                  r s,t
(%i5) canform(%);
(%o5)                                  0

</pre></div>

</dd></dl>

<a name="Molduras-moveis"></a>
<h4 class="subsection">27.2.5 Molduras móveis</h4>

<p>Maxima atualmente tem a habilidade de executar cálculos usando molduras móveis.
Essas podem ser molduras ortonormais (tetrads, vielbeins) ou uma moldura arbitrária.
</p>
<p>Para usar molduras, você primeiro escolhe <code>iframe_flag</code> para <code>true</code>. Isso
faz com que os símbolos de Christoffel, <code>ichr1</code> e <code>ichr2</code>, sejam substituídos
pelas molduras mais gerais de coeficientes de conecção <code>icc1</code> e <code>icc2</code>
em cálculos. Especialmente, o comportamento de <code>covdiff</code> e
<code>icurvature</code> são alterados.
</p>
<p>A moldura é definida através de dois tensores: o campo de moldura inversa (<code>ifri</code>),
a base tetrad dual),
e a métrica da moldura <code>ifg</code>. A métrica da moldura é a matriz identidade para
molduras ortonormais, ou a métrica de Lorentz para molduras ortonormais no espaço-tempo de
Minkowski. O campo de moldura inversa define a base da moldura (vetores unitários).
Propriedades de contração são definidas para o campo de moldura e para a métrica da moldura.
</p>
<p>Quando <code>iframe_flag</code> for <code>true</code>, muitas expressões <code>itensor</code> usam a métrica da
moldura <code>ifg</code> em lugar da métrica definida através de <code>imetric</code> para
o decremento e para o incremento de índices.
</p>
<p>IMPORTANTE: Escolhendo a variável <code>iframe_flag</code> para <code>true</code> NÃO
remove a definição das propriedades de contração de uma métrica definida através de uma chamada a
<code>defcon</code> ou <code>imetric</code>. Se um campo de moldura for usado, ele é melhor para
definir a métrica através de atribuição desse nome para a variável <code>imetric</code>
e NÃO invoque a função <code>imetric</code>.
</p>
<p>Maxima usa esses dois tensores para definir os coeficientes de moldura (<code>ifc1</code>
e <code>ifc2</code>) cuja forma parte dos coeficientes de conecção (<code>icc1</code>
e <code>icc2</code>), como demonstra o seguinte exemplo:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) iframe_flag:true;
(%o2)                                true
(%i3) ishow(covdiff(v([],[i]),j))$
                               i        i     %1
(%t3)                         v   + icc2     v
                               ,j       %1 j
(%i4) ishow(ev(%,icc2))$
                        %1      i           i        i
(%t4)                  v   (ifc2     + ichr2    ) + v
                                %1 j        %1 j     ,j
(%i5) ishow(ev(%,ifc2))$
            %1    i %2
           v   ifg     (ifb        - ifb        + ifb       )
                           j %2 %1      %2 %1 j      %1 j %2     i
(%t5)      -------------------------------------------------- + v
                                   2                             ,j
(%i6) ishow(ifb([a,b,c]))$
                       %5    %4
(%t6)               ifr   ifr   (ifri        - ifri       )
                       a     b       c %4,%5       c %5,%4

</pre></div>

<p>Um método alternativo é usado para calcular o suporte da moldura (<code>ifb</code>) se
o sinalizador <code>iframe_bracket_form</code> é escolhido para <code>false</code>:
</p>
<div class="example">
<pre class="example">
(%i8) block([iframe_bracket_form:false],ishow(ifb([a,b,c])))$
                       %7    %6        %6      %7
(%t8)              (ifr   ifr     - ifr     ifr  ) ifri
                       a     b,%7      a,%7    b       c %6

</pre></div>


<a name="Item_003a-Itensor_002fdeffn_002fiframes"></a><dl>
<dt><a name="index-iframes"></a>Função: <strong>iframes</strong> <em>()</em></dt>
<dd>
<p>Uma vez que nessa versão do Maxima, identidades de contração para <code>ifr</code> e
<code>ifri</code> são sempre definidas, como é o suporte da moldura (<code>ifb</code>), essa
função não faz nada.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002fifb"></a><dl>
<dt><a name="index-ifb"></a>Variável: <strong>ifb</strong></dt>
<dd>
<p>O suporte da moldura. A contribuição da métrica da moldura para os coeficientes
de conecção é expressa usando o suporte da moldura:
</p>
<div class="example">
<pre class="example">
          - ifb      + ifb      + ifb
               c a b      b c a      a b c
ifc1    = --------------------------------
    abc                  2

</pre></div>

<p>O suporte da moldura por si mesmo é definido em termos de campo de moldura e métrica da
moldura. Dois métodos alternativos de cálculo são usados dependendo do
valor de <code>frame_bracket_form</code>. Se <code>true</code> (o padrão) ou se o sinalizador
<code>itorsion_flag</code> for <code>true</code>:
</p>
<div class="example">
<pre class="example">
          d      e                                      f
ifb =  ifr    ifr   (ifri      - ifri      - ifri    itr   )
   abc    b      c       a d,e       a e,d       a f    d e


</pre></div>

<p>Otherwise:
</p>
<div class="example">
<pre class="example">
             e      d        d      e
ifb    = (ifr    ifr    - ifr    ifr   ) ifri
   abc       b      c,e      b,e    c        a d

</pre></div>


</dd></dl>


<a name="Item_003a-Itensor_002fdefvr_002ficc1"></a><dl>
<dt><a name="index-icc1"></a>Variável: <strong>icc1</strong></dt>
<dd>
<p>Coeficientes de conecção de primeiro tipo. Em <code>itensor</code>, definido como
</p>
<div class="example">
<pre class="example">
icc1    = ichr1    - ikt1    - inmc1
    abc        abc       abc        abc

</pre></div>

<p>Nessa expressão, se <code>iframe_flag</code> for <code>true</code>, o símbolo de Christoffel
<code>ichr1</code> é substituído com o coeficiente de conecção da moldura <code>ifc1</code>.
Se <code>itorsion_flag</code> for <code>false</code>, <code>ikt1</code>
será omitido. <code>ikt1</code> é também omitido se uma base de moldura for usada, como a
torsão está já calculada como parte do suporte da moldura.
Ultimamente, como <code>inonmet_flag</code> é <code>false</code>,
<code>inmc1</code> não estará presente.
</p>

</dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002ficc2"></a><dl>
<dt><a name="index-icc2"></a>Variável: <strong>icc2</strong></dt>
<dd>
<p>Coeficientes de conecção de segundo tipo. Em <code>itensor</code>, definido como
</p>
<div class="example">
<pre class="example">
    c         c        c         c
icc2   = ichr2   - ikt2   - inmc2
    ab        ab       ab        ab

</pre></div>

<p>Nessa expressão, se <code>iframe_flag</code> for <code>true</code>, o símbolo de Christoffel
<code>ichr2</code> é substituído com o coeficiente de conecção <code>ifc2</code>.
Se <code>itorsion_flag</code> for <code>false</code>, <code>ikt2</code>
será omitido. <code>ikt2</code> também será omitido se uma base de moldura for usada, uma vez que a
torsão já está calculada como parte do suporte da moldura.
Ultimamente, como <code>inonmet_flag</code> é <code>false</code>,
<code>inmc2</code> não estará presente.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002fifc1"></a><dl>
<dt><a name="index-ifc1"></a>Variável: <strong>ifc1</strong></dt>
<dd>
<p>Coeficiente de moldura de primeiro tipo (também conhecido como coeficientes de
rotação de Ricci).  Esse tensor representa a contribuição
da métrica da moldura para o coeficiente de conecção de primeiro tipo. Definido
como:
</p>
<div class="example">
<pre class="example">
          - ifb      + ifb      + ifb
               c a b      b c a      a b c
ifc1    = --------------------------------
    abc                   2


</pre></div>

</dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002fifc2"></a><dl>
<dt><a name="index-ifc2"></a>Variável: <strong>ifc2</strong></dt>
<dd>
<p>Coeficiente de moldura de primeiro tipo. Esse tensor representa a contribuição
da métrica da moldura para o coeficiente de conecção de primeiro tipo. Definido
como uma permutação de suporte de moldura (<code>ifb</code>) com os índices
apropriados incrementados e decrementados como necessário:
</p>
<div class="example">
<pre class="example">
    c       cd
ifc2   = ifg   ifc1
    ab             abd

</pre></div>

</dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002fifr"></a><dl>
<dt><a name="index-ifr"></a>Variável: <strong>ifr</strong></dt>
<dd>
<p>O campo da moldura. Contrai (<code>ifri</code>) para e com a forma do campo inverso da
moldura para formar a métrica da moldura (<code>ifg</code>).
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002fifri"></a><dl>
<dt><a name="index-ifri"></a>Variável: <strong>ifri</strong></dt>
<dd>
<p>O campo inverso da moldura. Especifica a base da moldura (vetores base duais). Juntamente
com a métrica da moldura, forma a base de todos os cálculos baseados em
molduras.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002fifg"></a><dl>
<dt><a name="index-ifg"></a>Variável: <strong>ifg</strong></dt>
<dd>
<p>A métrica da moldura. O valor padrão é <code>kdelta</code>, mas pode ser mudada usando
<code>components</code>.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002fifgi"></a><dl>
<dt><a name="index-ifgi"></a>Variável: <strong>ifgi</strong></dt>
<dd>
<p>O inverso da métrica da moldura. Contrai com a métrica da moldura (<code>ifg</code>)
para <code>kdelta</code>.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002fiframe_005fbracket_005fform"></a><dl>
<dt><a name="index-iframe_005fbracket_005fform"></a>Variável de Opção: <strong>iframe_bracket_form</strong></dt>
<dd><p>Valor padrão: <code>true</code>
</p>
<p>Especifica como o suporte da moldura (<code>ifb</code>) é calculado.
</p>
</dd></dl>

<a name="Torsao-e-nao-metricidade"></a>
<h4 class="subsection">27.2.6 Torsão e não metricidade</h4>

<p>Maxima pode trabalhar com torsão e não metricidade. Quando o sinalizador
<code>itorsion_flag</code> for escolhido para <code>true</code>, a contribuição de torsão
é adicionada aos coeficientes de conecção. Similarmente, quando o sinalizador
<code>inonmet_flag</code> for <code>true</code>, componentes de não metricidades são incluídos.
</p>
<a name="Item_003a-Itensor_002fdefvr_002finm"></a><dl>
<dt><a name="index-inm"></a>Variável: <strong>inm</strong></dt>
<dd>
<p>O vetor de não metricidade. Conforme a não metricidade está definida através da
derivada covariante do tensor métrico. Normalmente zero, o tensor da
métrica derivada covariante irá avaliar para o seguinte quando
<code>inonmet_flag</code> for escolhido para <code>true</code>:
</p>
<div class="example">
<pre class="example">
g     =- g  inm
 ij;k     ij  k

</pre></div>

</dd></dl>


<a name="Item_003a-Itensor_002fdefvr_002finmc1"></a><dl>
<dt><a name="index-inmc1"></a>Variável: <strong>inmc1</strong></dt>
<dd>
<p>Permutação covariante de componentes do vetor de não metricidade. Definida como
</p>
<div class="example">
<pre class="example">
           g   inm  - inm  g   - g   inm
            ab    c      a  bc    ac    b
inmc1    = ------------------------------
     abc                 2

</pre></div>

<p>(Substitue <code>ifg</code> em lugar de <code>g</code> se uma moldura métrica for usada.)
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002finmc2"></a><dl>
<dt><a name="index-inmc2"></a>Variável: <strong>inmc2</strong></dt>
<dd>
<p>Permutação covariante de componentes do vetor de não metricidade. Usada
nos coeficicientes de conecção se <code>inonmet_flag</code> for <code>true</code>. Definida
como:
</p>
<div class="example">
<pre class="example">
                      c         c         cd
          -inm  kdelta  - kdelta  inm  + g   inm  g
     c        a       b         a    b          d  ab
inmc2   = -------------------------------------------
     ab                        2

</pre></div>

<p>(Substitue <code>ifg</code> em lugar de <code>g</code> se uma moldura métrica for usada.)
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002fikt1"></a><dl>
<dt><a name="index-ikt1"></a>Variável: <strong>ikt1</strong></dt>
<dd>
<p>Permutação covariante do tensor de torsão (também conhecido como contorsão).
Definido como:
</p>
<div class="example">
<pre class="example">
                  d           d       d
          -g   itr  - g    itr   - itr   g
            ad    cb    bd    ca      ab  cd
ikt1    = ----------------------------------
    abc                   2

</pre></div>

<p>(Substitue <code>ifg</code> em lugar de <code>g</code> se uma moldura métrica for usada.)
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002fikt2"></a><dl>
<dt><a name="index-ikt2"></a>Variável: <strong>ikt2</strong></dt>
<dd>
<p>Permutação contravariante do tensor de torsão (também conhecida como contorsão).
Definida como:
</p>
<div class="example">
<pre class="example">
    c     cd
ikt2   = g   ikt1
    ab           abd

</pre></div>

<p>(Substitue <code>ifg</code> em lugar de <code>g</code> se uma moldura métrica for usada.)
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002fitr"></a><dl>
<dt><a name="index-itr"></a>Variável: <strong>itr</strong></dt>
<dd>
<p>O tensor de torsão. Para uma métrica com torsão, diferenciação covariante
repetida sobre uma funçào escalar não irá comutar,como demonstrado
através do seguinte exemplo:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric:g;
(%o2)                                  g
(%i3) covdiff(covdiff(f([],[]),i),j)-covdiff(covdiff(f([],[]),j),i)$
(%i4) ishow(%)$
                                   %4              %2
(%t4)                    f    ichr2    - f    ichr2
                          ,%4      j i    ,%2      i j
(%i5) canform(%);
(%o5)                                  0
(%i6) itorsion_flag:true;
(%o6)                                true
(%i7) covdiff(covdiff(f([],[]),i),j)-covdiff(covdiff(f([],[]),j),i)$
(%i8) ishow(%)$
                           %8             %6
(%t8)             f    icc2    - f    icc2    - f     + f
                   ,%8     j i    ,%6     i j    ,j i    ,i j
(%i9) ishow(canform(%))$
                                   %1             %1
(%t9)                     f    icc2    - f    icc2
                           ,%1     j i    ,%1     i j
(%i10) ishow(canform(ev(%,icc2)))$
                                   %1             %1
(%t10)                    f    ikt2    - f    ikt2
                           ,%1     i j    ,%1     j i
(%i11) ishow(canform(ev(%,ikt2)))$
                      %2 %1                    %2 %1
(%t11)          f    g      ikt1       - f    g      ikt1
                 ,%2            i j %1    ,%2            j i %1
(%i12) ishow(factor(canform(rename(expand(ev(%,ikt1))))))$
                           %3 %2            %1       %1
                     f    g      g      (itr    - itr   )
                      ,%3         %2 %1     j i      i j
(%t12)               ------------------------------------
                                      2
(%i13) decsym(itr,2,1,[anti(all)],[]);
(%o13)                               done
(%i14) defcon(g,g,kdelta);
(%o14)                               done
(%i15) subst(g,nounify(g),%th(3))$
(%i16) ishow(canform(contract(%)))$
                                           %1
(%t16)                           - f    itr
                                    ,%1    i j

</pre></div>

</dd></dl>

<a name="Algebra-externa-_0028como-em-produto-externo_0029"></a>
<h4 class="subsection">27.2.7 Álgebra externa (como em produto externo)</h4>

<p>O pacote <code>itensor</code> pode executar operações sobre campos tensores
covariantes totalmente antisimétricos. Um campo tensor totalmente antisimétrico de classe
(0,L) corresponde a uma forma diferencial L. Sobre esses objetos, uma
operação de multiplicação funciona como um produto externo, ou produto cunha,
é definido.
</p>
<p>Desafortunadamente, nem todos os autores concordam sobre a definição de produto
cunha. Alguns autores preferem uma definição que corresponde à
noção de antisimetrização: nessas palavras, o produto cunha de
dois campos vetoriais, por exemplo, pode ser definido como
</p>
<div class="example">
<pre class="example">            a a  - a a
             i j    j i
 a  /\ a  = -----------
  i     j        2
</pre></div>

<p>Mais geralmente, o produto de uma forma p e uma forma q pode ser definido como
</p>
<div class="example">
<pre class="example">                       1     k1..kp l1..lq
A       /\ B       = ------ D              A       B
 i1..ip     j1..jq   (p+q)!  i1..ip j1..jq  k1..kp  l1..lq
</pre></div>

<p>onde <code>D</code> simboliza o delta de Kronecker.
</p>
<p>Outros autores, todavia, preferem uma definição &ldquo;geométrica&rdquo; que corresponde à
notação de elemento volume:
</p>
<div class="example">
<pre class="example">a  /\ a  = a a  - a a
 i     j    i j    j i
</pre></div>

<p>e, no caso geral
</p>
<div class="example">
<pre class="example">                       1    k1..kp l1..lq
A       /\ B       = ----- D              A       B
 i1..ip     j1..jq   p! q!  i1..ip j1..jq  k1..kp  l1..lq
</pre></div>

<p>Uma vez que <code>itensor</code> é um pacote de algebra de tensores, a primeira dessas duas
definições aparenta ser a mais natural por si mesma. Muitas aplicações, todavia,
usam a segunda definição. Para resolver esse dilema, um sinalizador tem sido
implementado que controla o comportamento do produto cunha: se
<code>igeowedge_flag</code> for <code>false</code> (o padrão), a primeira, definição
&quot;tensorial&quot; é usada, de outra forma a segunda, definição &quot;geométrica&quot; irá
ser aplicada.
</p>
<a name="Item_003a-Itensor_002fdefvr_002f_007e"></a><dl>
<dt><a name="index-_007e"></a>Operador: <strong>~</strong></dt>
<dd><p>O operador do produto cunha é definido como sendo o acento til <code>~</code>. O til é
um operador binário. Seus argumentos podem ser expressões envolvendo escalares,
tensores covariantes de categoria 1, ou tensores covariantes de categoria <code>l</code> que
tiverem sido declarados antisimétricos em todos os índices covariantes.
</p>
<p>O comportamento do operador do produto cunha é controlado através do
sinalizador <code>igeowedge_flag</code>, como no seguinte exemplo:
</p>
<div class="example">
<pre class="example">(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i])~b([j]))$
                                 a  b  - b  a
                                  i  j    i  j
(%t2)                            -------------
                                       2
(%i3) decsym(a,2,0,[anti(all)],[]);
(%o3)                                done
(%i4) ishow(a([i,j])~b([k]))$
                          a    b  + b  a    - a    b
                           i j  k    i  j k    i k  j
(%t4)                     ---------------------------
                                       3
(%i5) igeowedge_flag:true;
(%o5)                                true
(%i6) ishow(a([i])~b([j]))$
(%t6)                            a  b  - b  a
                                  i  j    i  j
(%i7) ishow(a([i,j])~b([k]))$
(%t7)                     a    b  + b  a    - a    b
                           i j  k    i  j k    i k  j
</pre></div>

</dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002f_007c"></a><dl>
<dt><a name="index-_007c"></a>Operador: <strong>|</strong></dt>
<dd><p>A barra vertical <code>|</code> denota a operação binária
&quot;contração com um vetor&quot;. Quando um tensor covariante totalmente antisimétrico é contraído
com um vetor contravariante, o resultado é o mesmo independente de qual índice
foi usado para a contração. Dessa forma, é possível definir a
operação de contração de uma forma livre de índices.
</p>
<p>No pacote <code>itensor</code>, contração com um vetor é sempre realizada
com relação ao primeiro índice na ordem literal de ordenação. Isso garante
uma melhor simplificação de expressões envolvendo o operador <code>|</code>. Por exemplo:
</p>
<div class="example">
<pre class="example">(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) decsym(a,2,0,[anti(all)],[]);
(%o2)                                done
(%i3) ishow(a([i,j],[])|v)$
                                    %1
(%t3)                              v   a
                                        %1 j
(%i4) ishow(a([j,i],[])|v)$
                                     %1
(%t4)                             - v   a
                                         %1 j
</pre></div>

<p>Note que isso é essencial que os tensores usado como o operador <code>|</code> seja
declarado totalmente antisimétrico em seus índices covariantes. De outra forma,
os resultados serão incorretos.
</p>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fextdiff"></a><dl>
<dt><a name="index-extdiff"></a>Função: <strong>extdiff</strong> <em>(<var>expr</var>, <var>i</var>)</em></dt>
<dd>
<p>Calcula a derivada externa de <var>expr</var> com relação ao índice
<var>i</var>. A derivada externa é formalmente definida como o produto
cunha do operador de derivada parcial e uma forma diferencial. Como
tal, essa operação é também controlada através da escolha de <code>igeowedge_flag</code>.
Por exemplo:
</p>
<div class="example">
<pre class="example">(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(extdiff(v([i]),j))$
                                  v    - v
                                   j,i    i,j
(%t2)                             -----------
                                       2
(%i3) decsym(a,2,0,[anti(all)],[]);
(%o3)                                done
(%i4) ishow(extdiff(a([i,j]),k))$
                           a      - a      + a
                            j k,i    i k,j    i j,k
(%t4)                      ------------------------
                                      3
(%i5) igeowedge_flag:true;
(%o5)                                true
(%i6) ishow(extdiff(v([i]),j))$
(%t6)                             v    - v
                                   j,i    i,j
(%i7) ishow(extdiff(a([i,j]),k))$
(%t7)                      a      - a      + a
                            j k,i    i k,j    i j,k
</pre></div>

</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fhodge"></a><dl>
<dt><a name="index-hodge"></a>Função: <strong>hodge</strong> <em>(<var>expr</var>)</em></dt>
<dd>
<p>Calcula o Hodge dual de <var>expr</var>. Por exemplo:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                            done
(%i3) idim(4);
(%o3)                            done
(%i4) icounter:100;
(%o4)                             100
(%i5) decsym(A,3,0,[anti(all)],[])$

(%i6) ishow(A([i,j,k],[]))$
(%t6)                           A
                                 i j k
(%i7) ishow(canform(hodge(%)))$
                          %1 %2 %3 %4
               levi_civita            g        A
                                       %1 %102  %2 %3 %4
(%t7)          -----------------------------------------
                                   6
(%i8) ishow(canform(hodge(%)))$
                 %1 %2 %3 %8            %4 %5 %6 %7
(%t8) levi_civita            levi_civita            g        g
                                                     %1 %106  %2 %107
                                            g        g      A        /6
                                             %3 %108  %4 %8  %5 %6 %7
(%i9) lc2kdt(%)$

(%i10) %,kdelta$

(%i11) ishow(canform(contract(expand(%))))$
(%t11)                     - A
                              %106 %107 %108

</pre></div>

</dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002figeowedge_005fflag"></a><dl>
<dt><a name="index-igeowedge_005fflag"></a>Variável de Opção: <strong>igeowedge_flag</strong></dt>
<dd><p>Valor padrão: <code>false</code>
</p>
<p>Controla o comportamento de produto cunha e derivada externa. Quando
for esconhida para <code>false</code> (o padrão), a noção de formas diferenciais irá
corresponder àquela de um campo tensor covariante totalmente antisimétrico.
Quando escolhida para <code>true</code>, formas diferenciais irão concordar com a noção do
elemento volume.
</p>
</dd></dl>


<a name="Exportando-expressoes-TeX"></a>
<h4 class="subsection">27.2.8 Exportando expressões TeX</h4>

<p>O pacote <code>itensor</code> fornece suporte limitado à exportação de expressões
de tensores para o TeX.  Uma vez que expressões <code>itensor</code> aparecem como chamada a funções,
o comando regular <code>tex</code> do Maxima não produzirá a saída
esperada. Você pode tentar em seu lugar o comando <code>tentex</code>, o qual tenta
traduzir expressões de tensores dentro de objetos TeX indexados apropriadamente.
</p>
<a name="Item_003a-Itensor_002fdeffn_002ftentex"></a><dl>
<dt><a name="index-tentex"></a>Função: <strong>tentex</strong> <em>(<var>expr</var>)</em></dt>
<dd>
<p>Para usar a função <code>tentex</code>, você deve primeiro chamar <code>tentex</code>,
como no seguinte exemplo:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) load(&quot;tentex&quot;);
(%o2)       /share/tensor/tentex.lisp
(%i3) idummyx:m;
(%o3)                                  m
(%i4) ishow(icurvature([j,k,l],[i]))$
            m1       i           m1       i           i            i
(%t4)  ichr2    ichr2     - ichr2    ichr2     - ichr2      + ichr2
            j k      m1 l        j l      m1 k        j l,k        j k,l
(%i5) tentex(%)$
$$\Gamma_{j\,k}^{m_1}\,\Gamma_{l\,m_1}^{i}-\Gamma_{j\,l}^{m_1}\,
 \Gamma_{k\,m_1}^{i}-\Gamma_{j\,l,k}^{i}+\Gamma_{j\,k,l}^{i}$$

</pre></div>

<p>Note o uso da declaração <code>idummyx</code>, para evitar o aparecimento
do sinal de porcentagem na expressão TeX, o qual pode induzir a erros de compilação.
</p>
<p>Note Bem: Essa vesão da função <code>tentex</code> é um tanto quanto experimental.
</p>
</dd></dl>

<a name="Interagindo-com-o-pacote-ctensor"></a>
<h4 class="subsection">27.2.9 Interagindo com o pacote <code>ctensor</code></h4>

<p>O pacote <code>itensor</code> possui a habilidade de gerar código Maxima que pode
então ser executado no contexto do pacote <code>ctensor</code>. A função que executa
essa tarefa é <code>ic_convert</code>.
</p>
<a name="Item_003a-Itensor_002fdeffn_002fic_005fconvert"></a><dl>
<dt><a name="index-ic_005fconvert"></a>Função: <strong>ic_convert</strong> <em>(<var>eqn</var>)</em></dt>
<dd>
<p>Converte a equação <var>eqn</var> na sintaxe <code>itensor</code> para uma declaração de atribuição <code>ctensor</code>.
Adições implícitas sobre índices que ocorrem exatamente duas vezes são tornadas explícitas enquanto objetos
indexados são transformados em arrays (os arrays subscritos estão na
ordem de covariância seguidos de índices contravariantes dos objetos
indexados). A derivada de um objeto indexado será substituída pela
forma substantiva de <code>diff</code> tomada com relação a <code>ct_coords</code> subscrita
pelo índice de derivação. Os símbolos de Christoffel <code>ichr1</code> e <code>ichr2</code>
irão ser traduzidos para <code>lcs</code> e <code>mcs</code>, respectivamente e se
<code>metricconvert</code> for <code>true</code> então todas as ocorrências da métrica
com dois índices covariantes (ou contravariantes) irão ser renomeadas para <code>lg</code>
(ou <code>ug</code>). Adicionalmente, ciclos <code>do</code> irão ser introduzidos adicionando sobre
todos os índices livres de forma que a
declaração de atribuição transformada pode ser avaliada através de apenas fazendo
<code>ev</code>. Os seguintes exemplos demonstam os recursos dessa
função.
</p>
<div class="example">
<pre class="example">(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) eqn:ishow(t([i,j],[k])=f([],[])*g([l,m],[])*a([],[m],j)*b([i],[l,k]))$
                             k        m   l k
(%t2)                       t    = f a   b    g
                             i j      ,j  i    l m
(%i3) ic_convert(eqn);
(%o3) for i thru dim do (for j thru dim 

do (for k thru dim do t        : f sum(sum(diff(a , ct_coords ) b
                       i, j, k                   m           j   i, l, k

 g    , l, 1, dim), m, 1, dim)))
  l, m
(%i4) imetric(g);
(%o4)                                done
(%i5) metricconvert:true;
(%o5)                                true
(%i6) ic_convert(eqn);
(%o6) for i thru dim do (for j thru dim 

do (for k thru dim do t        : f sum(sum(diff(a , ct_coords ) b
                       i, j, k                   m           j   i, l, k

 lg    , l, 1, dim), m, 1, dim)))
   l, m
</pre></div>

</dd></dl>

<a name="Palavras-reservadas"></a>
<h4 class="subsection">27.2.10 Palavras reservadas</h4>

<p>As palavras seguintes do Maxima são usadas internamente pelo pacote <code>itensor</code> e
não podem ser redefinidas:
</p>
<div class="example">
<pre class="example">  Keyword    Comments
  ------------------------------------------
  indices2() versão interna de <code>indices()</code>
  conti      Lista de índices contravariantes
  covi       Lista de índices covariantes de um objeto indexado
  deri       Lista de índices de derivada de um objeto indexado
  name       Retorna o nome de um objeto indexado
  concan
  irpmon
  lc0
  _lc2kdt0
  _lcprod
  _extlc
</pre></div>



<hr>
<div class="header">
<p>
Previous: <a href="maxima_87.html#Introdu_00e7_00e3o-a-itensor" accesskey="p" rel="previous">Introdução a itensor</a>, Acima: <a href="maxima_86.html#itensor" accesskey="u" rel="up">itensor</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Sum&aacute;rio" rel="contents">Conte&uacute;do</a>][<a href="maxima_231.html#g_t_00cdndice-de-Fun_00e7_00f5es-e-Vari_00e1veis" title="&Iacute;ndice" rel="index">&Iacute;ndice</a>]</p>
</div>



</body>
</html>
