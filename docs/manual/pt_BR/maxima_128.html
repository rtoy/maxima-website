<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Manual do Maxima: Funções e Variáveis Definidas para Fluxo de Programa</title>

<meta name="description" content="Manual do Maxima: Funções e Variáveis Definidas para Fluxo de Programa">
<meta name="keywords" content="Manual do Maxima: Funções e Variáveis Definidas para Fluxo de Programa">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="maxima_toc.html#Top" rel="start" title="Top">
<link href="maxima_231.html#g_t_00cdndice-de-Fun_00e7_00f5es-e-Vari_00e1veis" rel="index" title="Índice de Funções e Variáveis">
<link href="maxima_toc.html#SEC_Contents" rel="contents" title="Sum&aacute;rio">
<link href="maxima_126.html#Fluxo-de-Programa" rel="up" title="Fluxo de Programa">
<link href="maxima_129.html#Depurando" rel="next" title="Depurando">
<link href="maxima_127.html#Introdu_00e7_00e3o-a-Fluxo-de-Programa" rel="previous" title="Introdução a Fluxo de Programa">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 1em; padding-bottom: 1em;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%; display: block; margin-left: auto; margin-right: auto}

-->
</style>

<link rel="icon" href="figures/favicon.ico">

</head>

<body lang="pt" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="Fun_00e7_00f5es-e-Vari_00e1veis-Definidas-para-Fluxo-de-Programa"></a>
<div class="header">
<p>
Previous: <a href="maxima_127.html#Introdu_00e7_00e3o-a-Fluxo-de-Programa" accesskey="p" rel="previous">Introdução a Fluxo de Programa</a>, Acima: <a href="maxima_126.html#Fluxo-de-Programa" accesskey="u" rel="up">Fluxo de Programa</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Sum&aacute;rio" rel="contents">Conte&uacute;do</a>][<a href="maxima_231.html#g_t_00cdndice-de-Fun_00e7_00f5es-e-Vari_00e1veis" title="&Iacute;ndice" rel="index">&Iacute;ndice</a>]</p>
</div>
<a name="Funcoes-e-Variaveis-Definidas-para-Fluxo-de-Programa"></a>
<h3 class="section">40.2 Funções e Variáveis Definidas para Fluxo de Programa</h3>

<a name="Item_003a-Program_002fdeffn_002fbacktrace"></a><dl>
<dt><a name="index-backtrace"></a>Função: <strong>backtrace</strong> <em>()</em></dt>
<dt><a name="index-backtrace-1"></a>Função: <strong>backtrace</strong> <em>(<var>n</var>)</em></dt>
<dd><p>Imprime a pilha de chamadas, que é, a lista de funções que
foram chamadas pela função correntemente ativa.
</p>
<p><code>backtrace()</code> imprime toda a pilha de chamadas.
</p>
<p><code>backtrace (<var>n</var>)</code> imprime as <var>n</var> mais recentes chamadas a
funções, incluindo a função correntemente ativa.
</p>
<p><code>backtrace</code> pode ser chamada por um script, uma função, ou a partir da linha de comando interativa
(não somente em um contexto de depuração).
</p>
<p>Exemplos:
</p>
<ul>
<li> <code>backtrace()</code> imprime toda a pilha de chamadas.

<div class="example">
<pre class="example">(%i1) h(x) := g(x/7)$
(%i2) g(x) := f(x-11)$
(%i3) f(x) := e(x^2)$
(%i4) e(x) := (backtrace(), 2*x + 13)$
(%i5) h(10);
#0: e(x=4489/49)
#1: f(x=-67/7)
#2: g(x=10/7)
#3: h(x=10)
                              9615
(%o5)                         ----
                               49
</pre></div>
</li></ul>

<ul>
<li> <code>backtrace (<var>n</var>)</code> imprime as <var>n</var> mais recentes chamadas a
funções, incluindo a função correntemente ativa.

<div class="example">
<pre class="example">(%i1) h(x) := (backtrace(1), g(x/7))$
(%i2) g(x) := (backtrace(1), f(x-11))$
(%i3) f(x) := (backtrace(1), e(x^2))$
(%i4) e(x) := (backtrace(1), 2*x + 13)$
(%i5) h(10);
#0: h(x=10)
#0: g(x=10/7)
#0: f(x=-67/7)
#0: e(x=4489/49)
                              9615
(%o5)                         ----
                               49
</pre></div>
</li></ul>

</dd></dl>

<a name="Item_003a-Program_002fdeffn_002fdo"></a><dl>
<dt><a name="index-do"></a>Operador especial: <strong>do</strong></dt>
<dd><p>A declaração <code>do</code> é usada para executar iteração.  Devido à sua
grande generalidade a declaração <code>do</code> será  descrita em duas partes.
Primeiro a forma usual será dada que é análoga à forma que é usada em
muitas outras linguagens de programação (Fortran, Algol, PL/I, etc.); em segundo lugar
os outros recursos serão mencionados.
</p>
<p>Existem três variantes do operador especial <code>do</code> que diferem somente por suas
condições de encerramento.  São elas:
</p>
<ul>
<li> <code>for <var>Variável</var>: <var>valor_inicial</var> step <var>incremento</var>
      thru <var>limite</var> do <var>corpo</var></code>
</li><li> <code>for <var>Variável</var>: <var>valor_inicial</var> step <var>incremento</var>
      while <var>condição</var> do <var>corpo</var></code>
</li><li> <code>for <var>Variável</var>: <var>valor_inicial</var> step <var>incremento</var>
      unless <var>condição</var> do <var>corpo</var></code>
</li></ul>

<p>(Alternativamente, o <code>step</code> pode ser dado após a <var>condição</var> de encerramento
ou limite.)
</p>
<p><var>valor_inicial</var>, <var>incremento</var>, <var>limite</var>, e <var>corpo</var> podem ser quaisquer
expressões.  Se o incremento for 1 então &quot;<code>step 1</code>&quot; pode ser omitido.
</p>
<p>A execução da declaração <code>do</code> processa-se primeiro atribuindo o
<code>valor_inicial</code> para a variável (daqui em diante chamada a
variável de controle).  Então: (1) Se a variável de controle excede
o limite de uma especificação <code>thru</code>, ou se a condição de <code>unless</code> for
<code>true</code>, ou se a condição de <code>while</code> for <code>false</code> então o <code>do</code>
será encerrado.  (2) O <var>corpo</var> é avaliado.  (3) O incremento é adicionado à
variável de controle.  O processo de (1) a (3) é executado
repetidamente até que a condição de encerramento seja satisfeita.  Pode-se também
dar muitas condições de encerramento e nesse caso o <code>do</code> termina
quando qualquer delas for satisfeita.
</p>
<p>Em geral o teste <code>thru</code> é satisfeito quando a variável de controle for
maior que o <var>limite</var> se o incremento for não negativo, ou quando a
variável de controle for menor que o <var>limite</var> se o <var>incremento</var> for negativo.
O <var>incremento</var> e o <var>limite</var> podem ser expressões não numéricas enquanto essa
desigualdade puder ser determinada.  Todavia, a menos que o <var>incremento</var> seja
sintaticamente negativo (e.g. for um número negativo) na hora em que a declaração <code>do</code>
for iniciada, Maxima assume que o incremento e o limite serão positivos quando o <code>do</code> for
executado.  Se o limite e o incremento não forem positivos, então o <code>do</code> pode não terminar
propriamente.
</p>
<p>Note que o <var>limite</var>, <var>incremento</var>, e <var>condição</var> de encerramento são
avaliados cada vez que ocorre um ciclo.  Dessa forma se qualquer desses for responsável por
muitos cálculos, e retornar um resultado que não muda durante todas
as execuções do <var>corpo</var>, então é mais eficiente escolher uma
variável para seu valor prévio para o <code>do</code> e usar essa variável na
forma <code>do</code>.
</p>
<p>O valor normalmente retornado por uma declaração <code>do</code> é o átomo <code>done</code>.
Todavia, a função
<code>return</code> pode ser usada dentro do <var>corpo</var> para sair da delcaração <code>do</code> prematuramente e dar
a isso qualquer valor desejado.
Note todavia que um <code>return</code> dentro de um <code>do</code> que
ocorre em um <code>block</code> encerrará somente o <code>do</code> e não o <code>block</code>.  Note também
que a função <code>go</code> não pode ser usada para sair de dentro de um <code>do</code> dentro de um
<code>block</code> que o envolve.
</p>
<p>A variável de controle é sempre local para o <code>do</code> e dessa forma qualquer
variável pode ser usada sem afetar o valor de uma variável com
o mesmo nome fora da declaração <code>do</code>.  A variável de controle é liberada
após o encerramento da declaração <code>do</code>.
</p>
<div class="example">
<pre class="example">(%i1) for a:-3 thru 26 step 7 do display(a)$
                             a = - 3

                              a = 4

                             a = 11

                             a = 18

                             a = 25
</pre></div>

<div class="example">
<pre class="example">(%i1) s: 0$
(%i2) for i: 1 while i &lt;= 10 do s: s+i;
(%o2)                         done
(%i3) s;
(%o3)                          55
</pre></div>

<p>Note que a condição <code>while i &lt;= 10</code>
é equivalente a <code>unless i &gt; 10</code> e também <code>thru 10</code>.
</p>
<div class="example">
<pre class="example">(%i1) series: 1$
(%i2) term: exp (sin (x))$
(%i3) for p: 1 unless p &gt; 7 do
          (term: diff (term, x)/p, 
           series: series + subst (x=0, term)*x^p)$
(%i4) series;
                  7    6     5    4    2
                 x    x     x    x    x
(%o4)            -- - --- - -- - -- + -- + x + 1
                 90   240   15   8    2
</pre></div>

<p>que fornece 8 termos da série de Taylor para <code>e^sin(x)</code>.
</p>
<div class="example">
<pre class="example">(%i1) poly: 0$
(%i2) for i: 1 thru 5 do
          for j: i step -1 thru 1 do
              poly: poly + i*x^j$
(%i3) poly;
                  5      4       3       2
(%o3)          5 x  + 9 x  + 12 x  + 14 x  + 15 x
(%i4) guess: -3.0$
(%i5) for i: 1 thru 10 do
          (guess: subst (guess, x, 0.5*(x + 10/x)),
           if abs (guess^2 - 10) &lt; 0.00005 then return (guess));
(%o5)                  - 3.162280701754386
</pre></div>

<p>Esse exemplo calcula a raíz quadrada negativa de 10 usando a
iteração de Newton- Raphson um maximum de 10 vezes.  Caso o critério de
convergêcia não tenha sido encontrado o valor retornado pode ser <code>done</code>.
Em lugar de sempre adicionar uma quantidade à variável de controle pode-se
algumas vezes desejar alterar isso de alguma outra forma para cada iteração.
Nesse caso pode-se usar <code>next <var>expressão</var></code> em lugar de <code>step <var>incremento</var></code>.
Isso fará com que a variável de controle seja escolhida para o
resultado de avaliação da <var>expressão</var> cada vez que o ciclo de repetição for executado.
</p>
<div class="example">
<pre class="example">(%i6) for count: 2 next 3*count thru 20 do display (count)$
                            count = 2

                            count = 6

                           count = 18
</pre></div>

<p>Como uma alternativa para <code>for <var>Variável</var>: <var>valor</var> ...do...</code> a sintaxe
<code>for <var>Variável</var> from <var>valor</var> ...do...</code>  pode ser usada.  Isso permite o
<code>from <var>valor</var></code> ser colocado após o <code>step</code> ou após o <var>next</var> valor ou após a
<var>condição</var> de encerramento.  Se <code>from <var>valor</var></code> for omitido então 1 é usado como
o valor inicial.
</p>
<p>Algumas vezes se pode estar interessado em executar uma iteração onde
a variável de controle nunca seja usada.  Isso é permissível
para dar somente as condições de encerramento omitindo a inicialização
e a informação de atualização como no exemplo seguinte para para calcular a
raíz quadrada de 5 usando uma fraca suposição inicial.
</p>
<div class="example">
<pre class="example">(%i1) x: 1000$
(%i2) thru 20 do x: 0.5*(x + 5.0/x)$
(%i3) x;
(%o3)                   2.23606797749979
(%i4) sqrt(5), numer;
(%o4)                   2.23606797749979
</pre></div>

<p>Se isso for desejado pode-se sempre omitir as condições de encerramento
inteiramente e apenas dar o <code>do <var>corpo</var></code> que o <var>corpo</var> continuará a ser 
avaliado indefinidamente.  Nesse caso a função <code>return</code> será usada para
encerrar a execução da declaração <code>do</code>.
</p>
<div class="example">
<pre class="example">(%i1) newton (f, x):= ([y, df, dfx], df: diff (f ('x), 'x),
          do (y: ev(df), x: x - f(x)/y, 
              if abs (f (x)) &lt; 5e-6 then return (x)))$
(%i2) sqr (x) := x^2 - 5.0$
(%i3) newton (sqr, 1000);
(%o3)                   2.236068027062195
</pre></div>

<p>(Note que <code>return</code>, quando executado, faz com que o valor corrente de
<code>x</code> seja retornado como o valor da declaração <code>do</code>.  O <code>block</code> é encerrado e
esse valor da declaração <code>do</code> é retornado como o valor do <code>block</code> porque o
<code>do</code> é a última declaração do <code>block</code>.)
</p>
<p>Uma outra forma de <code>do</code> é disponível no Maxima.  A sintaxe é:
</p>
<div class="example">
<pre class="example">for <var>Variável</var> in <var>list</var> <var>end_tests</var> do <var>corpo</var>
</pre></div>

<p>Os elementos de <var>list</var> são quaisquer expressões que irão
sucessivamente ser atribuídas para a <var>variável</var> a cada iteração do
<var>corpo</var>.  O teste opcional <var>end_tests</var> pode ser usado para encerrar a execução da
declaração <code>do</code>; de outra forma o <code>do</code> terminará quando a <var>lista</var> for exaurida ou quando
um <code>return</code> for executado no <var>corpo</var>.  (De fato, a <var>lista</var> pode ser qualquer
expressão não atômica, e partes sucessivas são usadas.)
</p>
<div class="example">
<pre class="example">(%i1)  for f in [log, rho, atan] do ldisp(f(1))$
(%t1)                                  0
(%t2)                                rho(1)
                                     %pi
(%t3)                                 ---
                                      4
(%i4) ev(%t3,numer);
(%o4)                             0.78539816
</pre></div>

</dd></dl>

<a name="Item_003a-Program_002fdeffn_002ferrcatch"></a><dl>
<dt><a name="index-errcatch"></a>Função: <strong>errcatch</strong> <em>(<var>expr_1</var>, ..., <var>expr_n</var>)</em></dt>
<dd><p>Avalia <var>expr_1</var>, ..., <var>expr_n</var> uma por uma e
retorna <code>[<var>expr_n</var>]</code> (uma lista) se nenhum erro ocorrer.  Se um
erro ocorrer na avaliação de qualquer argumento, <code>errcatch</code>
evita que o erro se propague e
retorna a lista vazia <code>[]</code> sem avaliar quaisquer mais argumentos.
</p>
<p><code>errcatch</code>
é útil em arquivos <code>batch</code> onde se suspeita que um erro possa estar ocorrendo o <code>errcatch</code>
terminará o <code>batch</code> se o erro não for detectado.
</p>
</dd></dl>

<a name="Item_003a-Program_002fdeffn_002ferror"></a><dl>
<dt><a name="index-error"></a>Função: <strong>error</strong> <em>(<var>expr_1</var>, ..., <var>expr_n</var>)</em></dt>
<dt><a name="index-error-1"></a>Variável de sistema: <strong>error</strong></dt>
<dd><p>Avalia e imprime <var>expr_1</var>, ..., <var>expr_n</var>,
e então causa um retorno de erro para o nível mais alto do Maxima
ou para o mais próximo contendo <code>errcatch</code>.
</p>
<p>A variável <code>error</code> é escolhida para uma lista descrevendo o erro.
O primeiro elemento de <code>error</code> é uma seq&uuml;ência de caracteres de formato,
que junta todas as seq&uuml;ências de caracteres entre os argumentos <var>expr_1</var>, ..., <var>expr_n</var>,
e os elementos restantes são os valores de quaisquer argumentos que não são seq&uuml;ências de caracteres.
</p>
<p><code>errormsg()</code> formata e imprime <code>error</code>.
Isso efetivamente reimprime a mais recente mensagem de erro.
</p>
</dd></dl>

<a name="Item_003a-Program_002fdeffn_002ferrormsg"></a><dl>
<dt><a name="index-errormsg"></a>Função: <strong>errormsg</strong> <em>()</em></dt>
<dd><p>Reimprime a mais recente mensagem de erro.
A variável <code>error</code> recebe a mensagem,
e <code>errormsg</code> formata e imprime essa mensagem.
</p>
</dd></dl>

<a name="Item_003a-Program_002fdeffn_002ffor"></a><dl>
<dt><a name="index-for"></a>Operador especial: <strong>for</strong></dt>
<dd><p>Usado em iterações.  Veja <code>do</code> para uma descrição das
facilidades de iteração do Maxima.
</p>
</dd></dl>

<a name="Item_003a-Program_002fdeffn_002fgo"></a><dl>
<dt><a name="index-go"></a>Função: <strong>go</strong> <em>(<var>tag</var>)</em></dt>
<dd><p>é usada dentro de um <code>block</code> para transferir o controle para a declaração
do bloco que for identificada com o argumento para <code>go</code>.  Para identificar uma
declaração, coloque antes dessa declaração um argumento atômico como outra declaração no
<code>block</code>.  Por exemplo:
</p>
<div class="example">
<pre class="example">block ([x], x:1, loop, x+1, ..., go(loop), ...)
</pre></div>

<p>O argumento para <code>go</code> deve ser o nome de um identificardor aparecendo no mesmo
<code>block</code>.  Não se pode usar <code>go</code> para transferir para um identificador em um outro <code>block</code> que não seja
o próprio contendo o <code>go</code>.
</p>
</dd></dl>

<a name="Item_003a-Program_002fdeffn_002fif"></a><dl>
<dt><a name="index-if"></a>Operador especial: <strong>if</strong></dt>
<dd><p>Representa avaliação condicional. Várias formas de expressões <code>if</code> são reconhecidas.
<code>if <var>cond_1</var> then <var>expr_1</var> else <var>expr_0</var></code>
avalia para <var>expr_1</var> se <var>cond_1</var> avaliar para <code>true</code>,
de outra forma a expressão avalia para <code>expr_0</code>.
</p>
<p><code>if <var>cond_1</var> then <var>expr_1</var> elseif <var>cond_2</var> then <var>expr_2</var> elseif ... else <var>expr_0</var></code>
avalia para <var>expr_k</var> se <var>cond_k</var> for <code>true</code> e todas as condições precedentes forem <code>false</code>.
Se nenhuma das condições forem <code>true</code>, a expressão avalia para <code>expr_0</code>.
</p>
<p>O comportamento <code>else false</code> é assumido se <code>else</code> for omitido.
Isso é, <code>if <var>cond_1</var> then <var>expr_1</var></code> é equivalente a
<code>if <var>cond_1</var> then <var>expr_1</var> else false</code>,
e <code>if <var>cond_1</var> then <var>expr_1</var> elseif ... elseif <var>cond_n</var> then <var>expr_n</var></code>
é equivalente a
<code>if <var>cond_1</var> then <var>expr_1</var> elseif ... elseif <var>cond_n</var> then <var>expr_n</var> else false</code>.
</p>
<p>As alternativas <var>expr_0</var>, ..., <var>expr_n</var> podem ser quaisquer expressões do Maxima,
incluíndo expressões <code>if</code> aninhadas ( if dentro de if).
As alternativas não são nem simplificadas nem avaliadas a menos que a correspondente condição seja <code>true</code>.
</p>
<p>As condições <var>cond_1</var>, ..., <var>cond_n</var> são expressões as quais potencialmente ou atualmente
avaliem para <code>true</code> ou para <code>false</code>.
Quando uma condição não avalia atualmente para para <code>true</code> ou para <code>false</code>,
o comportamento de <code>if</code> é governado pelo sinalizador global <code>prederror</code>.
Quando <code>prederror</code> for <code>true</code>,
isso é um erro se qualquer condição avaliada não avaliar para <code>true</code> ou <code>false</code>.
De outra forma, condições que não avaliem para <code>true</code> ou <code>false</code> são aceitas,
e o resultado é uma expressão condicional.
</p>
<p>Entre outros elementos, condições podem compreender operadores lógicos e relacionais como segue.
</p>
<div class="example">
<pre class="example">Operação             Símbolo      Tipo
 
menor que            &lt;           infixo relacional
menor que            &lt;=
  ou igual a                     infixo relacional
igualdade            =
  (sintática)                    infixo relacional
negação de =         #           infixo relacional
igualdade (valor)    equal       função relacional
negação de           notequal
  igualdade                      função relacional
maior que            &gt;=
  ou igual a                     infixo relacional
maior que            &gt;           infixo relacional
e                    and         infixo lógico
ou                   or          infixo lógico
não                  not         prefixo lógico
</pre></div>

</dd></dl>

<a name="Item_003a-Program_002fdeffn_002fmap"></a><dl>
<dt><a name="index-map"></a>Função: <strong>map</strong> <em>(<var>f</var>, <var>expr_1</var>, ..., <var>expr_n</var>)</em></dt>
<dd><p>Retorna uma expressão cujo operador principal
é o mesmo que o das expressões
<var>expr_1</var>, ..., <var>expr_n</var> mas cujas subpartes são os resultados da
aplicação de <var>f</var> nas correspondentes subpartes das expressões.  <var>f</var> é ainda
o nome de uma função de <em>n</em> argumentos
ou é uma forma <code>lambda</code> de <em>n</em> argumentos.
</p>
<p><code>maperror</code> - se <code>false</code> fará com que todas as funções mapeadas
(1) parem quando elas terminarem retornando a menor <var>exp_i</var> se não forem todas as
<var>exp_i</var> do mesmo comprimento e (2) aplique fn a [exp1, exp2,...]
se <var>exp_i</var> não forem todas do mesmo tipo de objeto.  Se <code>maperror</code> for <code>true</code>
então uma mensagem de erro será dada nas duas instâncias acima.
</p>
<p>Um dos usos dessa função é para mapear (<code>map</code>) uma função (e.g. <code>partfrac</code>)
sobre cada termo de uma expressão muito larga onde isso comumente não poderia
ser possível usar a função sobre a expressão inteira devido a uma
exaustão de espaço da lista de armazenamento no decorrer da computação.
</p>
<div class="example">
<pre class="example">(%i1) map(f,x+a*y+b*z);
(%o1)                        f(b z) + f(a y) + f(x)
(%i2) map(lambda([u],partfrac(u,x)),x+1/(x^3+4*x^2+5*x+2));
                           1       1        1
(%o2)                     ----- - ----- + -------- + x
                         x + 2   x + 1          2
                                         (x + 1)
(%i3) map(ratsimp, x/(x^2+x)+(y^2+y)/y);
                                      1
(%o3)                            y + ----- + 1
                                    x + 1
(%i4) map(&quot;=&quot;,[a,b],[-0.5,3]);
(%o4)                          [a = - 0.5, b = 3]


</pre></div>
</dd></dl>

<a name="Item_003a-Program_002fdeffn_002fmapatom"></a><dl>
<dt><a name="index-mapatom"></a>Função: <strong>mapatom</strong> <em>(<var>expr</var>)</em></dt>
<dd><p>Retorna <code>true</code> se e somente se <var>expr</var> for tratada pelas rotinas de
mapeamento como um átomo.  &quot;Mapatoms&quot; são átomos, números
(incluíndo números racioanais), e variáveis subscritas.
</p>
</dd></dl>

<a name="Item_003a-Program_002fdefvr_002fmaperror"></a><dl>
<dt><a name="index-maperror"></a>Variável de opção: <strong>maperror</strong></dt>
<dd><p>Valor padrão: <code>true</code>
</p>
<p>Quando <code>maperror</code> é <code>false</code>, faz com que todas as funções mapeadas, por exemplo
</p>
<div class="example">
<pre class="example">map (f, <var>expr_1</var>, <var>expr_2</var>, ...)
</pre></div>

<p>para (1) parar quando elas terminarem
retornando a menor <var>exp_i</var> se não forem todas as <var>exp_i</var> do mesmo
comprimento e (2) aplique <code>f</code> a <code>[<var>expr_1</var>, <var>expr_2</var>, ...]</code> se <code>expr_i</code> não forem todas
do mesmo tipo de objeto.
</p>
<p>Se <code>maperror</code> for <code>true</code> então uma ,mensagem de erro
é mostrada nas duas instâncias acima.
</p>
</dd></dl>

<a name="Item_003a-Program_002fdeffn_002fmaplist"></a><dl>
<dt><a name="index-maplist"></a>Função: <strong>maplist</strong> <em>(<var>f</var>, <var>expr_1</var>, ..., <var>expr_n</var>)</em></dt>
<dd><p>Retorna uma lista de aplicações de <var>f</var>
em todas as partes das expressões <var>expr_1</var>, ..., <var>expr_n</var>.
<var>f</var> é o nome de uma função, ou uma expressão lambda.
</p>
<p><code>maplist</code> difere de <code>map (<var>f</var>, <var>expr_1</var>, ..., <var>expr_n</var>)</code>
que retorna uma expressão com o mesmo operador principal que <var>expr_i</var> tem
(exceto para simplificações  e o caso onde <code>map</code> faz um <code>apply</code>).
</p>
</dd></dl>

<a name="Item_003a-Program_002fdefvr_002fprederror"></a><dl>
<dt><a name="index-prederror"></a>Variável de opção: <strong>prederror</strong></dt>
<dd><p>Valor padrão: <code>true</code>
</p>
<p>Quando <code>prederror</code> for <code>true</code>, uma mensagem de erro é mostrada
sempre que o predicado de uma declaração <code>if</code> ou uma função <code>is</code> falha em
avaliar ou para <code>true</code> ou para  <code>false</code>.
</p>
<p>Se <code>false</code>, <code>unknown</code> é retornado
no lugar nesse caso.  O modo <code>prederror: false</code> não é suportado no
código traduzido;
todavia, <code>maybe</code> é suportado no código traduzido.
</p>
<p>Veja também <code>is</code> e <code>maybe</code>.
</p>
</dd></dl>

<a name="Item_003a-Program_002fdeffn_002freturn"></a><dl>
<dt><a name="index-return"></a>Função: <strong>return</strong> <em>(<var>valor</var>)</em></dt>
<dd><p>Pode ser usada para sair explicitamente de um bloco, levando
seu argumento.  Veja <code>block</code> para mais informação.
</p>
</dd></dl>

<a name="Item_003a-Program_002fdeffn_002fscanmap"></a><dl>
<dt><a name="index-scanmap"></a>Função: <strong>scanmap</strong> <em>(<var>f</var>, <var>expr</var>)</em></dt>
<dt><a name="index-scanmap-1"></a>Função: <strong>scanmap</strong> <em>(<var>f</var>, <var>expr</var>, bottomup)</em></dt>
<dd><p>Recursivamente aplica <var>f</var> a <var>expr</var>, de cima
para baixo.  Isso é muito útil quando uma fatoração completa é
desejada, por exemplo:
</p>
<div class="example">
<pre class="example">(%i1) exp:(a^2+2*a+1)*y + x^2$
(%i2) scanmap(factor,exp);
                                    2      2
(%o2)                         (a + 1)  y + x
</pre></div>

<p>Note o caminho através do qual <code>scanmap</code> aplica a dada função <code>factor</code> para as
subexpressões constituintes de <var>expr</var>; se outra forma de <var>expr</var> é apresentada
para <code>scanmap</code> então o resultado pode ser diferente.  Dessa forma, <code>%o2</code> não é
recuperada quando <code>scanmap</code> é aplicada para a forma expandida de <var>exp</var>:
</p>
<div class="example">
<pre class="example">(%i3) scanmap(factor,expand(exp));
                           2                  2
(%o3)                      a  y + 2 a y + y + x
</pre></div>

<p>Aqui está um outro exemplo do caminho no qual <code>scanmap</code> aplica
recursivamente uma função dada para todas as subexpressões, incluindo expoentes:
</p>
<div class="example">
<pre class="example">(%i4) expr : u*v^(a*x+b) + c$
(%i5) scanmap('f, expr);
                    f(f(f(a) f(x)) + f(b))
(%o5) f(f(f(u) f(f(v)                      )) + f(c))
</pre></div>

<p><code>scanmap (<var>f</var>, <var>expr</var>, bottomup)</code> aplica <var>f</var> a <var>expr</var> de
baixo para cima.  E.g., para <code>f</code> indefinida,
</p>
<div class="example">
<pre class="example">scanmap(f,a*x+b) -&gt;
   f(a*x+b) -&gt; f(f(a*x)+f(b)) -&gt; f(f(f(a)*f(x))+f(b))
scanmap(f,a*x+b,bottomup) -&gt; f(a)*f(x)+f(b)
    -&gt; f(f(a)*f(x))+f(b) -&gt;
     f(f(f(a)*f(x))+f(b))
</pre></div>

<p>Nesse caso, você pega a mesma resposta em ambos os
caminhos.
</p>
</dd></dl>

<a name="Item_003a-Program_002fdeffn_002fthrow"></a><dl>
<dt><a name="index-throw"></a>Função: <strong>throw</strong> <em>(<var>expr</var>)</em></dt>
<dd><p>Avalia <var>expr</var> e descarta o valor retornado para o mais recente
<code>catch</code>.  <code>throw</code> é usada com <code>catch</code> como um mecanismo de retorno
não local.
</p>
</dd></dl>

<a name="Item_003a-Program_002fdeffn_002fwhile"></a><dl>
<dt><a name="index-while"></a>Operador especial: <strong>while</strong></dt>
<dd><p>Veja <code>do</code>.
</p>
</dd></dl>

<a name="Item_003a-Program_002fdeffn_002foutermap"></a><dl>
<dt><a name="index-outermap"></a>Função: <strong>outermap</strong> <em>(<var>f</var>, <var>a_1</var>, ..., <var>a_n</var>)</em></dt>
<dd><p>Aplica a função <var>f</var> para cada um dos elementos do produto externo
<var>a_1</var> vezes <var>a_2</var> ... vezes <var>a_n</var>.
</p>
<p><var>f</var> é o nome de uma função de <em>n</em> argumentos
ou uma expressão lambda de <em>n</em> argumentos.
Cada argumento <var>a_k</var> pode ser uma lista simples ou lista aninhada ( lista contendo listas como elementos ), ou uma matrz, ou qualquer outro tip de expressão.
</p>
<p>O valor de retorno de <code>outermap</code> é uma estrutura aninhada.
Tomemos <var>x</var> como sendo o valor de retorno.
Então <var>x</var> tem a mesma estrutura da primeira lista, lista aninhada, ou argumento matriz,
<code><var>x</var>[i_1]...[i_m]</code> tem a mesma estrutura que a segunda lista, lista aninhada, ou argumento matriz,
<code><var>x</var>[i_1]...[i_m][j_1]...[j_n]</code> tem a mesma estrutura que a terceira lista, lista aninhada, ou argumento matriz,
e assim por diante,
onde <var>m</var>, <var>n</var>, ... são os números dos índices requeridos para acessar os
elementos de cada argumento (um para uma lista, dois para uma matriz, um ou mais para uma lista aninhada).
Argumentos que não forem listas ou matrizes não afetam a estrutura do valor de retorno.
</p>
<p>Note que o efeito de <code>outermap</code> é diferente daquele de aplicar <var>f</var>
a cada um dos elementos do produto externo retornado por <code>cartesian_product</code>.
<code>outermap</code> preserva a estrutura dos argumentos no valor de retorno,
enquanto <code>cartesian_product</code> não reserva essa mesma estrutura.
</p>
<p><code>outermap</code> avalia seus argumentos.
</p>
<p>Veja também <code>map</code>, <code>maplist</code>, e <code>apply</code>.
</p>
<p>Exemplos:
Exemplos elementares de <code>outermap</code>.
Para mostrar a a combinação de argumentos mais claramente, <code>F</code> está indefinida à esquerda.
</p>
<div class="example">
<pre class="example">(%i1) outermap (F, [a, b, c], [1, 2, 3]);
(%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)], 
                                     [F(c, 1), F(c, 2), F(c, 3)]]
(%i2) outermap (F, matrix ([a, b], [c, d]), matrix ([1, 2], [3, 4]));
         [ [ F(a, 1)  F(a, 2) ]  [ F(b, 1)  F(b, 2) ] ]
         [ [                  ]  [                  ] ]
         [ [ F(a, 3)  F(a, 4) ]  [ F(b, 3)  F(b, 4) ] ]
(%o2)    [                                            ]
         [ [ F(c, 1)  F(c, 2) ]  [ F(d, 1)  F(d, 2) ] ]
         [ [                  ]  [                  ] ]
         [ [ F(c, 3)  F(c, 4) ]  [ F(d, 3)  F(d, 4) ] ]
(%i3) outermap (F, [a, b], x, matrix ([1, 2], [3, 4]));
       [ F(a, x, 1)  F(a, x, 2) ]  [ F(b, x, 1)  F(b, x, 2) ]
(%o3) [[                        ], [                        ]]
       [ F(a, x, 3)  F(a, x, 4) ]  [ F(b, x, 3)  F(b, x, 4) ]
(%i4) outermap (F, [a, b], matrix ([1, 2]), matrix ([x], [y]));
       [ [ F(a, 1, x) ]  [ F(a, 2, x) ] ]
(%o4) [[ [            ]  [            ] ], 
       [ [ F(a, 1, y) ]  [ F(a, 2, y) ] ]
                              [ [ F(b, 1, x) ]  [ F(b, 2, x) ] ]
                              [ [            ]  [            ] ]]
                              [ [ F(b, 1, y) ]  [ F(b, 2, y) ] ]
(%i5) outermap (&quot;+&quot;, [a, b, c], [1, 2, 3]);
(%o5) [[a + 1, a + 2, a + 3], [b + 1, b + 2, b + 3], 
                                           [c + 1, c + 2, c + 3]]
</pre></div>

<p>Uma explanação final do valor de retorno de <code>outermap</code>.
Os argumentos primeiro, segundo, e terceiro são matriz, lista, e matriz, respectivamente.
O valor de retorno é uma matriz.
Cada elementos daquela matriz é uma lista,
e cada elemento de cada lista é uma matriz.
</p>
<div class="example">
<pre class="example">(%i1) arg_1 :  matrix ([a, b], [c, d]);
                            [ a  b ]
(%o1)                       [      ]
                            [ c  d ]
(%i2) arg_2 : [11, 22];
(%o2)                       [11, 22]
(%i3) arg_3 : matrix ([xx, yy]);
(%o3)                      [ xx  yy ]
(%i4) xx_0 : outermap (lambda ([x, y, z], x / y + z), arg_1, arg_2, arg_3);
               [  [      a        a  ]  [      a        a  ]  ]
               [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
               [  [      11       11 ]  [      22       22 ]  ]
(%o4)  Col 1 = [                                              ]
               [  [      c        c  ]  [      c        c  ]  ]
               [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
               [  [      11       11 ]  [      22       22 ]  ]
                 [  [      b        b  ]  [      b        b  ]  ]
                 [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                 [  [      11       11 ]  [      22       22 ]  ]
         Col 2 = [                                              ]
                 [  [      d        d  ]  [      d        d  ]  ]
                 [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                 [  [      11       11 ]  [      22       22 ]  ]
(%i5) xx_1 : xx_0 [1][1];
           [      a        a  ]  [      a        a  ]
(%o5)     [[ xx + --  yy + -- ], [ xx + --  yy + -- ]]
           [      11       11 ]  [      22       22 ]
(%i6) xx_2 : xx_0 [1][1] [1];
                      [      a        a  ]
(%o6)                 [ xx + --  yy + -- ]
                      [      11       11 ]
(%i7) xx_3 : xx_0 [1][1] [1] [1][1];
                                  a
(%o7)                        xx + --
                                  11
(%i8) [op (arg_1), op (arg_2), op (arg_3)];
(%o8)                  [matrix, [, matrix]
(%i9) [op (xx_0), op (xx_1), op (xx_2)];
(%o9)                  [matrix, [, matrix]
</pre></div>

<p><code>outermap</code> preserves the structure of the arguments in the return value,
while <code>cartesian_product</code> does not.
</p>
<div class="example">
<pre class="example">(%i1) outermap (F, [a, b, c], [1, 2, 3]);
(%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)], 
                                     [F(c, 1), F(c, 2), F(c, 3)]]
(%i2) setify (flatten (%));
(%o2) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3), 
                                       F(c, 1), F(c, 2), F(c, 3)}
(%i3) map (lambda ([L], apply (F, L)), cartesian_product ({a, b, c}, {1, 2, 3}));
(%o3) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3), 
                                       F(c, 1), F(c, 2), F(c, 3)}
(%i4) is (equal (%, %th (2)));
(%o4)                         true
</pre></div>

</dd></dl>


<hr>
<div class="header">
<p>
Previous: <a href="maxima_127.html#Introdu_00e7_00e3o-a-Fluxo-de-Programa" accesskey="p" rel="previous">Introdução a Fluxo de Programa</a>, Acima: <a href="maxima_126.html#Fluxo-de-Programa" accesskey="u" rel="up">Fluxo de Programa</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Sum&aacute;rio" rel="contents">Conte&uacute;do</a>][<a href="maxima_231.html#g_t_00cdndice-de-Fun_00e7_00f5es-e-Vari_00e1veis" title="&Iacute;ndice" rel="index">&Iacute;ndice</a>]</p>
</div>



</body>
</html>
