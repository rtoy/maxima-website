<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Manual de Maxima 5.46.0: Funciones y variables para la definición de funciones</title>

<meta name="description" content="Manual de Maxima 5.46.0: Funciones y variables para la definición de funciones">
<meta name="keywords" content="Manual de Maxima 5.46.0: Funciones y variables para la definición de funciones">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="maxima_toc.html#Top" rel="start" title="Top">
<link href="maxima_304.html#g_t_00cdndice-de-Funciones-y-Variables" rel="index" title="Índice de Funciones y Variables">
<link href="maxima_toc.html#SEC_Contents" rel="contents" title="&Iacute;ndice General">
<link href="maxima_157.html#Definici_00f3n-de-Funciones" rel="up" title="Definición de Funciones">
<link href="maxima_162.html#Programaci_00f3n" rel="next" title="Programación">
<link href="maxima_160.html#Macros" rel="previous" title="Macros">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 1em; padding-bottom: 1em;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%; display: block; margin-left: auto; margin-right: auto}

-->
</style>

<link rel="icon" href="figures/favicon.ico">

</head>

<body lang="es" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="Funciones-y-variables-para-la-definici_00f3n-de-funciones"></a>
<div class="header">
<p>
Previous: <a href="maxima_160.html#Macros" accesskey="p" rel="previous">Macros</a>, Subir: <a href="maxima_157.html#Definici_00f3n-de-Funciones" accesskey="u" rel="up">Definición de Funciones</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="&Iacute;ndice general" rel="contents">&Iacute;ndice general</a>][<a href="maxima_304.html#g_t_00cdndice-de-Funciones-y-Variables" title="&Iacute;ndice" rel="index">&Iacute;ndice</a>]</p>
</div>
<a name="Funciones-y-variables-para-la-definicion-de-funciones"></a>
<h3 class="section">36.4 Funciones y variables para la definición de funciones</h3>

<a name="Item_003a-Function_002ees_002fdeffn_002fapply"></a><dl>
<dt><a name="index-apply"></a>Función: <strong>apply</strong> <em>(<var>F</var>, [<var>x_1</var>, ..., <var>x_n</var>])</em></dt>
<dd><p>Construye y evalúa la expresión <code><var>F</var>(<var>arg_1</var>, ..., <var>arg_n</var>)</code>.
</p>
<p>La función <code>apply</code> no hace distinciones entre funciones array y 
funciones ordinarias; cuando <var>F</var> es el nombre de una función array,
<code>apply</code> evalúa <code><var>F</var>(...)</code>, esto es, hace una llamada con
paréntesis en lugar de corchetes. La función <code>arrayapply</code>
evalúa una llamada a función con corchetes para estos casos.
</p>
<p>Ejemplos:
</p>
<p>La función <code>apply</code> evalúa sus argumentos.
En este ejemplo, <code>min</code> se aplica al valor de <code>L</code>.
</p>
<div class="example">
<pre class="example">(%i1) L : [1, 5, -10.2, 4, 3];
(%o1)                 [1, 5, - 10.2, 4, 3]
(%i2) apply (min, L);
(%o2)                        - 10.2
</pre></div>

<p>La función <code>apply</code> evalúa sus argumentos,
incluso cuando la función <var>F</var> no lo hace.
</p>
<div class="example">
<pre class="example">(%i1) F (x) := x / 1729;
                                   x
(%o1)                     F(x) := ----
                                  1729
(%i2) fname : F;
(%o2)                           F
(%i3) dispfun (F);
                                   x
(%t3)                     F(x) := ----
                                  1729

(%o3)                         [%t3]
(%i4) dispfun (fname);
fname is not the name of a user function.
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) apply (dispfun, [fname]);
                                   x
(%t5)                     F(x) := ----
                                  1729

(%o5)                         [%t5]
</pre></div>

<p>La función <code>apply</code> evalúa el nombre de función <var>F</var>.
La comilla simple <code>'</code> evita la evaluación.
El nombre <code>demoivre</code> corresponde a una variable global y
también a una función.
</p>
<div class="example">
<pre class="example">(%i1) demoivre;
(%o1)                         false
(%i2) demoivre (exp (%i * x));
(%o2)                  %i sin(x) + cos(x)
(%i3) apply (demoivre, [exp (%i * x)]);
demoivre evaluates to false
Improper name or value in functional position.
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) apply ('demoivre, [exp (%i * x)]);
(%o4)                  %i sin(x) + cos(x)
</pre></div>

</dd></dl>


<a name="Item_003a-Function_002ees_002fdeffn_002fblock"></a><dl>
<dt><a name="index-block"></a>Función: <strong>block</strong> <em>([<var>v_1</var>, ..., <var>v_m</var>], <var>expr_1</var>, ..., <var>expr_n</var>)</em></dt>
<dt><a name="index-block-1"></a>Función: <strong>block</strong> <em>(<var>expr_1</var>, ..., <var>expr_n</var>)</em></dt>
<dd>
<p>La función <code>block</code> evalúa <var>expr_1</var>, ..., <var>expr_n</var> secuencialmente y devuelve el valor de la última expresión evaluada. La secuencia puede alterarse con las funciones <code>go</code>, <code>throw</code> y <code>return</code>. La última expresión es <var>expr_n</var> a menos que <code>return</code> o una expresión que contenga un <code>throw</code> sea evaluada. Las variables <var>v_1</var>, ..., <var>v_m</var> son locales en el bloque; éstas se distiguen de las globales que tengan el mismo nombre. Si no se declaran variables locales entonces se puede omitir la lista. Dentro del bloque, cualquier otra variable distinta de <var>v_1</var>, ..., <var>v_m</var> se considera global.
</p>
<p>La función <code>block</code> guarda los valores actuales de las variables <var>v_1</var>, ..., <var>v_m</var>, si los tienen, a la entrada del bloque y luego las evalúa a sí mismas, es decir les saca el valor temporalmente. A las variables locales se les puede asignar cualquier valor dentro del bloque, pero al salir de éste, los valores inicialmente almacenados quedan restaurados, al tiempo que los asignados dentro del bloque se pierden.
</p>
<p>La declaración <code>local(<var>v_1</var>, ..., <var>v_m</var>)</code> dentro de un bloque
almacena las propiedades asociadas a los símbolos <var>v_1</var>, ..., <var>v_m</var>,
borra cualesquiera otras propiedades antes de evaluar las expresiones y
restaura las propiedades guardadas antes de abandonar el bloque.
Algunas declaraciones, como <code>:=</code>, <code>array</code>, <code>dependencies</code>, <code>atvalue</code>,
<code>matchdeclare</code>, <code>atomgrad</code>, <code>constant</code>, <code>nonscalar</code>, <code>assume</code>
y otras se implementan como propiedades de símbolos.
El efecto producido por <code>local</code> consiste en hacer que tales declaraciones tengan
efecto sólo dentro del bloque, en otro caso las declaraciones dentro del bloque 
tendrían un efecto global que afectarían al exterior de <code>block</code>.
</p>
<p>Un <code>block</code> puede aparecer dentro de otro <code>block</code>. Las variables locales se inicializan cada vez que se entra dentro de un nuevo bloque. Las variables locales de un bloque se consideran globales dentro de otro anidado dentro del primero. Si una variable es no local dentro de un bloque, su valor es el que le corresponde en el bloque superior. Este criterio se conoce con el nombre de &quot;alcance dinámico&quot;.
</p>
<p>El valor del bloque es el de la última sentencia o el argumento de la función <code>return</code>, que puede utilizarse para salir del bloque. La función <code>go</code> puede usarse para transferir el control a la sentencia del bloque que esté etiquetada con el argumento de <code>go</code>. Para etiquetar una sentencia basta que vaya precedida de un argumento atómico como cualquier otra sentencia dentro del bloque. Por ejemplo, <code>block ([x], x:1, tururu, x: x+1, ..., go(tururu), ...)</code>.  El argumento de <code>go</code> debe ser el nombre de una etiqueta colocada dentro del bloque. No se puede utilzar <code>go</code> para trasladarse a una etiqueta de un bloque que no sea el que contenga a <code>go</code>.
</p>
<p>Normalmente los bloques aparecerán al lado derecho de las definiciones de funciones, pero también pueden utilizarse en otros contextos.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdeffn_002fbreak"></a><dl>
<dt><a name="index-break"></a>Función: <strong>break</strong> <em>(<var>expr_1</var>, ..., <var>expr_n</var>)</em></dt>
<dd>
<p>Calcula e imprime <var>expr_1</var>, ..., <var>expr_n</var> para luego provocar la detención de Maxima, de modo que el usuario pueda examinar y cambiar el entorno de ejecución. Pulsando posteriormente <code>exit;</code> el cálculo se reanuda.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdeffn_002fcatch"></a><dl>
<dt><a name="index-catch"></a>Función: <strong>catch</strong> <em>(<var>expr_1</var>, ..., <var>expr_n</var>)</em></dt>
<dd>
<p>Evalúa <var>expr_1</var>, ..., <var>expr_n</var> una a una;  si alguna de ellas conlleva la evaluación de una expresión de la forma <code>throw (arg)</code>, entonces el valor de <code>catch</code> es el de <code>throw (arg)</code> y ya no se evalúan más expresiones. Esta respuesta pasa todos los niveles de anidamiento hasta el <code>catch</code> más próximo. Si no hay ningún <code>catch</code>  que contenga un <code>throw</code> se emite un mensaje de error.
</p>
<p>Si la evaluación de los argumentos no conlleva la evaluación de ningún <code>throw</code>, entonces el valor de <code>catch</code> es el devuelto por <var>expr_n</var>.
</p>
<div class="example">
<pre class="example">(%i1) lambda ([x], if x &lt; 0 then throw(x) else f(x))$
(%i2) g(l) := catch (map (''%, l))$
(%i3) g ([1, 2, 3, 7]);
(%o3)               [f(1), f(2), f(3), f(7)]
(%i4) g ([1, 2, -3, 7]);
(%o4)                          - 3
</pre></div>

<p>La función <code>g</code> devuelve las imágenes por <code>f</code> de todos los elementos de la lista <code>l</code> si ésta contiene únicamente números no negativos; si no es este el caso, entonces <code>g</code> captura el primer negativo que encuentra y lo devuelve por medio del <code>throw</code>.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdeffn_002fcompfile"></a><dl>
<dt><a name="index-compfile"></a>Function: <strong>compfile</strong> <em>(<var>filename</var>, <var>f_1</var>, &hellip;, <var>f_n</var>)</em></dt>
<dt><a name="index-compfile-1"></a>Function: <strong>compfile</strong> <em>(<var>filename</var>, functions)</em></dt>
<dt><a name="index-compfile-2"></a>Function: <strong>compfile</strong> <em>(<var>filename</var>, all)</em></dt>
<dd>
<p>Traduce funciones de Maxima a código Lisp, guardándolo 
luego en el fichero <var>filename</var>.
</p>
<p>Con la llamada <code>compfile(<var>filename</var>, <var>f_1</var>, &hellip;, <var>f_n</var>)</code>
se traducen las funciones especificadas, mientras que 
<code>compfile(<var>filename</var>, functions)</code> y
<code>compfile(<var>filename</var>, all)</code> traducen las funciones definidas por
el usuario.
</p>
<p>El código Lisp traducido no se evalúa, ni el fichero 
de salida es procesado por el compilador de Lisp.
La función <code>translate</code> crea y evalúa las traducciones Lisp, mientras que
<code>compile_file</code> traduce primero de Maxima a Lisp y luego
ejecuta el compilador Lisp. 
</p>
<p>Véanse también <code>translate</code>, <code>translate_file</code> y <code>compile_file</code>.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdeffn_002fcompile"></a><dl>
<dt><a name="index-compile"></a>Función: <strong>compile</strong> <em>(<var>f_1</var>, ..., <var>f_n</var>)</em></dt>
<dt><a name="index-compile-1"></a>Función: <strong>compile</strong> <em>(functions)</em></dt>
<dt><a name="index-compile-2"></a>Función: <strong>compile</strong> <em>(all)</em></dt>
<dd>
<p>Traduce las funciones de Maxima <var>f_1</var>, ..., <var>f_n</var> a Lisp, evaluando el código resultante, y llama a la función Lisp <code>COMPILE</code> para cada función traducida. La función <code>compile</code> devuelve una lista con los nombres de las funciones compiladas.
</p>
<p>Las llamadas <code>compile (all)</code> o <code>compile (functions)</code> compilan todas las funciones definidas por el usuario.
</p>
<p>La función <code>compile</code> no evalúa sus argumentos, pero con el operador comilla-comilla (<code>'<!-- /@w -->'</code>) sí lo hace.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdeffn_002fdefine"></a><dl>
<dt><a name="index-define"></a>Función: <strong>define</strong> <em>(<var>f</var>(<var>x_1</var>, ..., <var>x_n</var>), <var>expr</var>)</em></dt>
<dt><a name="index-define-1"></a>Función: <strong>define</strong> <em>(<var>f</var>[<var>x_1</var>, ..., <var>x_n</var>], <var>expr</var>)</em></dt>
<dt><a name="index-define-2"></a>Función: <strong>define</strong> <em>(funmake (<var>f</var>, [<var>x_1</var>, ..., <var>x_n</var>]), <var>expr</var>)</em></dt>
<dt><a name="index-define-3"></a>Función: <strong>define</strong> <em>(arraymake (<var>f</var>, [<var>x_1</var>, ..., <var>x_n</var>]), <var>expr</var>)</em></dt>
<dt><a name="index-define-4"></a>Función: <strong>define</strong> <em>(ev (<var>expr_1</var>), <var>expr_2</var>)</em></dt>
<dd>
<p>Define una función de nombre <var>f</var> con argumentos <var>x_1</var>, ..., <var>x_n</var> y cuerpo <var>expr</var>.
<code>define</code> evalúa siempre su segundo argumento, a menos que se
indique lo contrario con el operador de comilla simple. La función así
definida puede ser una función ordinaria de Maxima (con sus argumentos
encerrados entre paréntesis) o una función array (con sus argumentos encerrados
entre corchetes).
</p>
<p>Cuando el último o único argumento <var>x_n</var> es una lista de un solo 
elemento, la función definida por <code>define</code> acepta un número variable
de argumentos. Los valores de los argumentos se van asignando uno a uno a 
<var>x_1</var>, ..., <var>x_(n - 1)</var>, y los que queden, si los hay, se asignan 
a <var>x_n</var> en forma de lista.
</p>
<p>Cuando el primer argumento de <code>define</code> es una expresión de la
forma <code><var>f</var>(<var>x_1</var>, ..., <var>x_n</var>)</code> o
<code><var>f</var>[<var>x_1</var>, ..., <var>x_n</var>]</code>, se evalúan los argumentos de la función,
pero no <var>f</var>, incluso cuando se trate de una función o variable ya existente 
con ese nombre.
</p>
<p>Cuando el primer argumento es una expresión con operador <code>funmake</code>, 
<code>arraymake</code> o <code>ev</code>, se evalúa este primer argumento, lo que
permite calcular la función.
</p>
<p>Todas las definiciones de funciones aparecen en el mismo espacio
de nombres; definiendo una función <code>f</code> dentro de otra
función <code>g</code> no limita automáticamente el alcance de <code>f</code> a <code>g</code>.
Sin embargo, <code>local(f)</code> hace que la definición de la función <code>f</code>
sea efectiva sólo dentro del bloque o expresión compuesta en el que
aparece <code>local</code>.
</p>
<p>Si un argumento formal <var>x_k</var> es un símbolo afectado
por el operador comilla simple (expresión nominal), la función definida por
<code>define</code> no evalúa el correspondiente valor de argumento.
En cualquier otro caso, los argumentos que se pasan son evaluados.
</p>
<p>Véanse también <code>:=</code> y <code>::=</code>.
</p>
<p>Ejemplos:
</p>
<p><code>define</code> evalúa siempre su segundo argumento, a menos que se
indique lo contrario con el operador de comilla simple.
</p>
<div class="example">
<pre class="example">(%i1) expr : cos(y) - sin(x);
(%o1)                    cos(y) - sin(x)
(%i2) define (F1 (x, y), expr);
(%o2)              F1(x, y) := cos(y) - sin(x)
(%i3) F1 (a, b);
(%o3)                    cos(b) - sin(a)
(%i4) F2 (x, y) := expr;
(%o4)                   F2(x, y) := expr
(%i5) F2 (a, b);
(%o5)                    cos(y) - sin(x)
</pre></div>

<p>La función así
definida puede ser una función ordinaria de Maxima o una función array.
</p>
<div class="example">
<pre class="example">(%i1) define (G1 (x, y), x.y - y.x);
(%o1)               G1(x, y) := x . y - y . x
(%i2) define (G2 [x, y], x.y - y.x);
(%o2)                G2     := x . y - y . x
                       x, y
</pre></div>

<p>Cuando el último o único argumento <var>x_n</var> es una lista de un solo 
elemento, la función definida por <code>define</code> acepta un número variable
de argumentos.
</p>
<div class="example">
<pre class="example">(%i1) define (H ([L]), '(apply (&quot;+&quot;, L)));
(%o1)                H([L]) := apply(&quot;+&quot;, L)
(%i2) H (a, b, c);
(%o2)                       c + b + a
</pre></div>

<p>Cuando el primer argumento es una expresión con operador <code>funmake</code>, 
<code>arraymake</code> o <code>ev</code>, se evalúa este primer argumento.
</p>
<div class="example">
<pre class="example">(%i1) [F : I, u : x];
(%o1)                        [I, x]
(%i2) funmake (F, [u]);
(%o2)                         I(x)
(%i3) define (funmake (F, [u]), cos(u) + 1);
(%o3)                  I(x) := cos(x) + 1
(%i4) define (arraymake (F, [u]), cos(u) + 1);
(%o4)                   I  := cos(x) + 1
                         x
(%i5) define (foo (x, y), bar (y, x));
(%o5)                foo(x, y) := bar(y, x)
(%i6) define (ev (foo (x, y)), sin(x) - cos(y));
(%o6)             bar(y, x) := sin(x) - cos(y)
</pre></div>

</dd></dl>



<a name="Item_003a-Function_002ees_002fdeffn_002fdefine_005fvariable"></a><dl>
<dt><a name="index-define_005fvariable"></a>Función: <strong>define_variable</strong> <em>(<var>name</var>, <var>default_value</var>, <var>mode</var>)</em></dt>
<dd>
<p>Introduce una variable global en el entorno de Maxima. La función 
<code>define_variable</code> puede ser útil en los paquetes escritos por
los usuarios que vayan a ser compilados o traducidos con frecuencia.
</p>
<p>La función <code>define_variable</code> ejecuta los siguientes pasos:
</p>
<ol>
<li> <code>mode_declare (<var>name</var>, <var>mode</var>)</code> declara el modo de <var>name</var> al traductor.
Véase <code>mode_declare</code> para ver la lista de modos aceptables.

</li><li> Si aún no tiene asignación, se le da a la variable <var>default_value</var> el valor <var>name</var>.

</li><li> <code>declare (<var>name</var>, special)</code> la declara como especial.

</li><li> Asocia <var>name</var> a una función de comprobación para asegurar que
a <var>name</var> sólo se le asignan valores del modo declarado.
</li></ol>



<p>La propiedad <code>value_check</code> se puede asociar a cualquier variable que haya
sido definida mediante <code>define_variable</code> en cualquiera de los modos diferentes
a <code>any</code>. La propiedad <code>value_check</code> puede ser una expresión lambda o
una función de una variable, que será invocada al intentar asignar un valor a la
variable; el argumento pasado a la función <code>value_check</code> es el valor que
se le quiere asignar a la variable.
</p>
<p>La función <code>define_variable</code> evalúa <code>default_value</code> pero no
<code>name</code> ni <code>mode</code>; el valor que devuelve es el valor actual de 
<code>name</code>, el cual es <code>default_value</code> si a <code>name</code> no se le ha
aplicado ninguna asignación, o el valor de dicha asignación en caso
contrario.
</p>
<p>Ejemplos:
</p>
<p><code>foo</code> es una variable booleana con valor inicial <code>true</code>.
</p><div class="example">
<pre class="example">(%i1) define_variable (foo, true, boolean);
(%o1)                         true
(%i2) foo;
(%o2)                         true
(%i3) foo: false;
(%o3)                         false
(%i4) foo: %pi;
Error: foo was declared mode boolean, has value: %pi
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) foo;
(%o5)                         false
</pre></div>

<p><code>bar</code> es una variable entera, cuyo valor habrá de ser primo.
</p><div class="example">
<pre class="example">(%i1) define_variable (bar, 2, integer);
(%o1)                           2
(%i2) qput (bar, prime_test, value_check);
(%o2)                      prime_test
(%i3) prime_test (y) := if not primep(y) then
                           error (y, &quot;is not prime.&quot;);
(%o3) prime_test(y) := 
         if not primep(y) then error(y, &quot;is not prime.&quot;)
(%i4) bar: 1439;
(%o4)                         1439
(%i5) bar: 1440;
1440 is not prime.
#0: prime_test(y=1440)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) bar;
(%o6)                         1439
</pre></div>

<p><code>baz_quux</code> es una variable a la que no se le podrá asignar valor alguno.
El modo <code>any_check</code> es como <code>any</code>, 
pero <code>any_check</code> activa el mecanismo <code>value_check</code>, cosa que <code>any</code>
no hace.
</p><div class="example">
<pre class="example">(%i1) define_variable (baz_quux, 'baz_quux, any_check);
(%o1)                       baz_quux
(%i2) F: lambda ([y], if y # 'baz_quux then
                 error (&quot;Cannot assign to `baz_quux'.&quot;));
(%o2) lambda([y], if y # 'baz_quux
                   then error(Cannot assign to `baz_quux'.))
(%i3) qput (baz_quux, ''F, value_check);
(%o3) lambda([y], if y # 'baz_quux
                   then error(Cannot assign to `baz_quux'.))
(%i4) baz_quux: 'baz_quux;
(%o4)                       baz_quux
(%i5) baz_quux: sqrt(2);
Cannot assign to `baz_quux'.
#0: lambda([y],if y # 'baz_quux then
             error(&quot;Cannot assign to `baz_quux'.&quot;))(y=sqrt(2))
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) baz_quux;
(%o6)                       baz_quux
</pre></div>

</dd></dl>


<a name="Item_003a-Function_002ees_002fdeffn_002fdispfun"></a><dl>
<dt><a name="index-dispfun"></a>Función: <strong>dispfun</strong> <em>(<var>f_1</var>, ..., <var>f_n</var>)</em></dt>
<dt><a name="index-dispfun-1"></a>Función: <strong>dispfun</strong> <em>(all)</em></dt>
<dd>
<p>Muestra la deficnión de las funciones de usuario <var>f_1</var>, ..., <var>f_n</var>. Cada argumento puede ser el nombre de una macro (definida mediante <code>::=</code>), una función ordinaria (definida mediante <code>:=</code> o <code>define</code>), una función arreglo  (definida mediante <code>:=</code> o <code>define</code>, pero encerrando los argumentos dentro de corchetes <code>[ ]</code>), una función de subíndice (definida mediante <code>:=</code> o <code>define</code>, pero encerrando algunos argumentos entre corchetes y otros entre paréntesis  <code>( )</code>), una función de subíndice seleccionada por un subíndice variable, o una función de subíndice definida con un subíndice constante.
</p>
<p>La llamada <code>dispfun (all)</code> muestra todas las funciones de usuario tal como las dan las listas <code>functions</code>, <code>arrays</code> y <code>macros</code>, omitiendo las funciones con subíndices definidas con subíndices constantes.
</p>
<p>La función <code>dispfun</code> crea una etiqueta (<code>%t1</code>, <code>%t2</code>, etc.) para cada función mostrada, y asigna la definición de la función a la etiqueta. En contraste, <code>fundef</code> devuelve las definiciones de las funciones.
</p>
<p>La función <code>dispfun</code> no evalúa sus argumentos; el operador de comilla-comilla <code>'<!-- /@w -->'</code> permite la evaluación.
</p>
<p>La función <code>dispfun</code> devuelve la lista de etiquetas de expresiones intermedias correspondientes a las funciones mostradas.
</p>
<p>Ejemplos:
</p>
<div class="example">
<pre class="example">(%i1) m(x, y) ::= x^(-y);
                                     - y
(%o1)                   m(x, y) ::= x
(%i2) f(x, y) :=  x^(-y);
                                     - y
(%o2)                    f(x, y) := x
(%i3) g[x, y] :=  x^(-y);
                                    - y
(%o3)                     g     := x
                           x, y
(%i4) h[x](y) :=  x^(-y);
                                    - y
(%o4)                     h (y) := x
                           x
(%i5) i[8](y) :=  8^(-y);
                                    - y
(%o5)                     i (y) := 8
                           8
(%i6) dispfun (m, f, g, h, h[5], h[10], i[8]);
                                     - y
(%t6)                   m(x, y) ::= x

                                     - y
(%t7)                    f(x, y) := x

                                    - y
(%t8)                     g     := x
                           x, y

                                    - y
(%t9)                     h (y) := x
                           x

                                    1
(%t10)                     h (y) := --
                            5        y
                                    5

                                     1
(%t11)                    h  (y) := ---
                           10         y
                                    10

                                    - y
(%t12)                    i (y) := 8
                           8

(%o12)       [%t6, %t7, %t8, %t9, %t10, %t11, %t12]
(%i12) ''%;
                     - y              - y            - y
(%o12) [m(x, y) ::= x   , f(x, y) := x   , g     := x   , 
                                            x, y
                  - y           1              1             - y
        h (y) := x   , h (y) := --, h  (y) := ---, i (y) := 8   ]
         x              5        y   10         y   8
                                5             10
</pre></div>

</dd></dl>



<a name="Item_003a-Function_002ees_002fdeffn_002ffullmap"></a><dl>
<dt><a name="index-fullmap"></a>Función: <strong>fullmap</strong> <em>(<var>f</var>, <var>expr_1</var>, ...)</em></dt>
<dd><p>Similar a <code>map</code>, pero conservará el mapeado
descendente de todas las subexpresiones hasta que los operadores
principales ya no sean los mismos.
</p>
<p>La función <code>fullmap</code> es utilizada por el simplificador de Maxima
en algunas transformaciones matriciales, por lo que Maxima generará en algunas ocasiones mensajes de error relacionados con <code>fullmap</code> aunque el usuario no haya invocado explícitamente esta función.
</p>
<div class="example">
<pre class="example">(%i1) a + b * c;
(%o1)                        b c + a
(%i2) fullmap (g, %);
(%o2)                   g(b) g(c) + g(a)
(%i3) map (g, %th(2));
(%o3)                     g(b c) + g(a)
</pre></div>

</dd></dl>

<a name="Item_003a-Function_002ees_002fdeffn_002ffullmapl"></a><dl>
<dt><a name="index-fullmapl"></a>Función: <strong>fullmapl</strong> <em>(<var>f</var>, <var>list_1</var>, ...)</em></dt>
<dd><p>Similar a <code>fullmap</code>, pero <code>fullmapl</code> sólo hace mapeo
sobre listas y matrices.
</p>
<div class="example">
<pre class="example">(%i1) fullmapl (&quot;+&quot;, [3, [4, 5]], [[a, 1], [0, -1.5]]);
(%o1)                [[a + 3, 4], [4, 3.5]]
</pre></div>

</dd></dl>


<a name="Item_003a-Function_002ees_002fdefvr_002ffunctions"></a><dl>
<dt><a name="index-functions"></a>Variable del sistema: <strong>functions</strong></dt>
<dd><p>Valor por defecto: <code>[]</code>
</p>
<p>La variable <code>functions</code> es una lista que contiene los nombres de las funciones ordinarias de Maxima. Una función ordinaria es aquella que ha sido construida mediante cualquiera de los métodos <code>define</code> o <code>:=</code> y que es invocada utilizando paréntesis. Una función puede definirse durante una sesión de Maxima o en un fichero que posteriormente será cargado en memoria por <code>load</code> o <code>batch</code>.
</p>
<p>Las funciones array, que son invocadas con corchetes (<code>F[x]</code>),
y las funciones subindicadas, que son las invocadas con corchetes y
paréntesis (<code>F[x](y)</code>) se registran en la variable global <code>arrays</code>,
no en <code>functions</code>.
</p>
<p>Las funciones Lisp no se registran en ninguna lista.
</p>
<p>Ejemplos:
</p>
<div class="example">
<pre class="example">(%i1) F_1 (x) := x - 100;
(%o1)                   F_1(x) := x - 100
(%i2) F_2 (x, y) := x / y;
                                      x
(%o2)                    F_2(x, y) := -
                                      y
(%i3) define (F_3 (x), sqrt (x));
(%o3)                   F_3(x) := sqrt(x)
(%i4) G_1 [x] := x - 100;
(%o4)                    G_1  := x - 100
                            x
(%i5) G_2 [x, y] := x / y;
                                     x
(%o5)                     G_2     := -
                             x, y    y
(%i6) define (G_3 [x], sqrt (x));
(%o6)                    G_3  := sqrt(x)
                            x
(%i7) H_1 [x] (y) := x^y;
                                      y
(%o7)                     H_1 (y) := x
                             x
(%i8) functions;
(%o8)              [F_1(x), F_2(x, y), F_3(x)]
(%i9) arrays;
(%o9)                 [G_1, G_2, G_3, H_1]
</pre></div>

</dd></dl>

<a name="Item_003a-Function_002ees_002fdeffn_002ffundef"></a><dl>
<dt><a name="index-fundef"></a>Función: <strong>fundef</strong> <em>(<var>f</var>)</em></dt>
<dd>
<p>Devuelve la definición de la función <var>f</var>.
</p>
<p>Cada argumento puede ser el nombre de una macro (definida mediante <code>::=</code>), una función ordinaria (definida mediante <code>:=</code> o <code>define</code>), una función arreglo  (definida mediante <code>:=</code> o <code>define</code>, pero encerrando los argumentos dentro de corchetes <code>[ ]</code>), una función de subíndice (definida mediante <code>:=</code> o <code>define</code>, pero encerrando algunos argumentos entre corchetes y otros entre paréntesis  <code>( )</code>), una función de subíndice seleccionada por un subíndice variable, o una función de subíndice definida con un subíndice constante.
</p>
<p>La función <code>fundef</code> no evalúa sus argumentos; el operador comilla-comilla <code>'<!-- /@w -->'</code> permite la evaluación.
</p>
<p>La llamada de función <code>fundef (<var>f</var>)</code> devuelve la definición de <var>f</var>. Por el contrario, <code>dispfun (<var>f</var>)</code> crea una etiqueta intermedia y le asigna la definición a la etiqueta.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdeffn_002ffunmake"></a><dl>
<dt><a name="index-funmake"></a>Función: <strong>funmake</strong> <em>(<var>F</var>, [<var>arg_1</var>, ..., <var>arg_n</var>])</em></dt>
<dd>
<p>Devuelve una expresión <code><var>F</var>(<var>arg_1</var>, ..., <var>arg_n</var>)</code>.
El valor así retornado es simplificado pero no evaluado,
de forma que la función <var>F</var> no es invocada, incluso cuando exista.
</p>
<p>La función <code>funmake</code> no hace distinciones entre funciones array
y funciones ordinarias; cuando <var>F</var> es el nombre de una función array,
<code>funmake</code> devuelve <code><var>F</var>(...)</code>,
esto es, una llamada a función con paréntesis en lugar de corchetes.
La función <code>arraymake</code> devuelve una llamada a función con
corchetes para estos casos.
</p>
<p>La función <code>funmake</code> evalúa sus argumentos.
</p>
<p>Ejemplos:
</p>
<p>La función <code>funmake</code> aplicada a una función ordinaria de Maxima.
</p>
<div class="example">
<pre class="example">(%i1) F (x, y) := y^2 - x^2;
                                   2    2
(%o1)                  F(x, y) := y  - x
(%i2) funmake (F, [a + 1, b + 1]);
(%o2)                    F(a + 1, b + 1)
(%i3) ''%;
                              2          2
(%o3)                  (b + 1)  - (a + 1)
</pre></div>

<p>La función <code>funmake</code> aplicada a una macro.
</p>
<div class="example">
<pre class="example">(%i1) G (x) ::= (x - 1)/2;
                                  x - 1
(%o1)                    G(x) ::= -----
                                    2
(%i2) funmake (G, [u]);
(%o2)                         G(u)
(%i3) ''%;
                              u - 1
(%o3)                         -----
                                2
</pre></div>

<p>La función <code>funmake</code> aplicada a una función subindicada.
</p>
<div class="example">
<pre class="example">(%i1) H [a] (x) := (x - 1)^a;
                                        a
(%o1)                   H (x) := (x - 1)
                         a
(%i2) funmake (H [n], [%e]);
                                       n
(%o2)               lambda([x], (x - 1) )(%e)
(%i3) ''%;
                                    n
(%o3)                       (%e - 1)
(%i4) funmake ('(H [n]), [%e]);
(%o4)                        H (%e)
                              n
(%i5) ''%;
                                    n
(%o5)                       (%e - 1)
</pre></div>

<p>La función <code>funmake</code> aplicada a un símbolo
que no está asociado a función alguna.
</p>
<div class="example">
<pre class="example">(%i1) funmake (A, [u]);
(%o1)                         A(u)
(%i2) ''%;
(%o2)                         A(u)
</pre></div>

<p>La función <code>funmake</code> evalúa sus argumentos,
pero no el valor retornado.
</p>
<div class="example">
<pre class="example">(%i1) det(a,b,c) := b^2 -4*a*c;
                                    2
(%o1)              det(a, b, c) := b  - 4 a c
(%i2) (x : 8, y : 10, z : 12);
(%o2)                          12
(%i3) f : det;
(%o3)                          det
(%i4) funmake (f, [x, y, z]);
(%o4)                    det(8, 10, 12)
(%i5) ''%;
(%o5)                         - 284
</pre></div>

<p>Maxima simplifica el valor retornado de <code>funmake</code>.
</p>
<div class="example">
<pre class="example">(%i1) funmake (sin, [%pi / 2]);
(%o1)                           1
</pre></div>

</dd></dl>

<a name="Item_003a-Function_002ees_002fdeffn_002flambda"></a><dl>
<dt><a name="index-lambda"></a>Función: <strong>lambda</strong> <em>([<var>x_1</var>, ..., <var>x_m</var>], <var>expr_1</var>, ..., <var>expr_n</var>)</em></dt>
<dt><a name="index-lambda-1"></a>Function: <strong>lambda</strong> <em>([[<var>L</var>]], <var>expr_1</var>, ..., <var>expr_n</var>)</em></dt>
<dt><a name="index-lambda-2"></a>Function: <strong>lambda</strong> <em>([<var>x_1</var>, ..., <var>x_m</var>, [<var>L</var>]], <var>expr_1</var>, ..., <var>expr_n</var>)</em></dt>
<dd><p>Define y devuelve una expresión lambda (es decir, una función anónima).
La función puede tener argumentos <var>x_1</var>, ..., <var>x_m</var> y/o argumentos
opcionales <var>L</var>, que aparecerán dentro del cuerpo de la función como una lista.
El valor que devuelve la función es <var>expr_n</var>.
Una expresión lambda puede asignarse a una variable y ser evaluada como si fuese una función ordinaria. Además, puede aparecer en algunos contextos en los que sea necesario un nombre de función.
</p>
<p>Cuando se evalúa la función, se crean las variables <var>x_1</var>, ..., <var>x_m</var> sin asignación de valores. Una función <code>lambda</code> puede aparecer dentro de un <code>block</code> o de otra <code>lambda</code>. Las variables locales se inicializan cada vez que se entra dentro de un nuevo bloque o de otra función <code>lambda</code>. Las variables locales se consideran globales dentro de un bloque o función <code>lambda</code> anidado dentro del primero. Si una variable es no local dentro de un bloque o función <code>lambda</code>, su valor es el que le corresponde en el bloque o función <code>lambda</code> superior. Este criterio se conoce con el nombre de &quot;alcance dinámico&quot;.
</p>
<p>Una vez establecidas las variables locales <var>expr_1</var> a <var>expr_n</var> son secuencialmente evaluadas. La variable especial  <code>%%</code> representa el valor de la expresión inmediata anterior. Las sentencias <code>throw</code> y <code>catch</code> pueden aparecer también en la lista de expresiones.
</p>
<p>La función <code>return</code> no puede aparecer en una expresión <code>lambda</code> a menos que se encuentre acotada dentro de un bloque (<code>block</code>), en cuyo caso <code>return</code> establece el valor de retorno del bloque, pero no de la expresión <code>lambda</code>, a menos que el bloque resulte ser precisamente <var>expr_n</var>. De igual manera, <code>go</code> no puede aparecer en una expresión <code>lambda</code> si no es dentro de un <code>block</code>.
</p>
<p>Las funciones <code>lambda</code> no evalúan sus argumentos;  el operador comilla-comilla <code>'<!-- /@w -->'</code> permite su evaluación.
</p>
<p>Ejemplo:
</p>
<ul>
<li> Una función lambda puede asignarse a una variable y ser evaluada como si fuese una función ordinaria.
</li></ul>
<div class="example">
<pre class="example">(%i1) f: lambda ([x], x^2);
                                      2
(%o1)                    lambda([x], x )
(%i2) f(a);
                                2
(%o2)                          a
</pre></div>
<ul>
<li> Una expresión lambda puede aparecer en algunos contextos en los que sea necesario un nombre de función.
</li></ul>
<div class="example">
<pre class="example">(%i3) lambda ([x], x^2) (a);
                                2
(%o3)                          a
(%i4) apply (lambda ([x], x^2), [a]);
                                2
(%o4)                          a
(%i5) map (lambda ([x], x^2), [a, b, c, d, e]);
                        2   2   2   2   2
(%o5)                 [a , b , c , d , e ]
</pre></div>
<ul>
<li> Los argumentos son variables locales. Otras variables se consideran globales. Las variables globales son evaluadas en el momento que lo es la expresión, a menos que la evaluación de las mismas sea forzada, como cuando se hace uso de <code>'<!-- /@w -->'</code>.
</li></ul>
<div class="example">
<pre class="example">(%i6) a: %pi$
(%i7) b: %e$
(%i8) g: lambda ([a], a*b);
(%o8)                   lambda([a], a b)
(%i9) b: %gamma$
(%i10) g(1/2);
                             %gamma
(%o10)                       ------
                               2
(%i11) g2: lambda ([a], a*''b);
(%o11)                lambda([a], a %gamma)
(%i12) b: %e$
(%i13) g2(1/2);
                             %gamma
(%o13)                       ------
                               2
</pre></div>
<ul>
<li> Las expresiones lambda pueden anidarse. Las variables locales de expresiones lambda exteriores se consideran globales en expresiones internas, a menos que se enmascaren con variables locales de igual nombre.
</li></ul>
<div class="example">
<pre class="example">(%i14) h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
                                                   1
(%o14)    lambda([a, b], h2 : lambda([a], a b), h2(-))
                                                   2
(%i15) h(%pi, %gamma);
                             %gamma
(%o15)                       ------
                               2
</pre></div>
<ul>
<li> Puesto que <code>lambda</code> no evalúa sus argumentos, la expresión lambda <code>i</code> de más abajo no define una función del tipo &quot;multiplicar por <code>a</code>&quot;. Tal tipo de función se puede definir a través de <code>buildq</code>, como en la expresión lambda <code>i2</code> de más abajo.
</li></ul>
<div class="example">
<pre class="example">(%i16) i: lambda ([a], lambda ([x], a*x));
(%o16)            lambda([a], lambda([x], a x))
(%i17) i(1/2);
(%o17)                  lambda([x], a x)
(%i18) i2: lambda([a], buildq([a: a], lambda([x], a*x)));
(%o18)    lambda([a], buildq([a : a], lambda([x], a x)))
(%i19) i2(1/2);
                                     x
(%o19)                   lambda([x], -)
                                     2
(%i20) i2(1/2)(%pi);
                               %pi
(%o20)                         ---
                                2
</pre></div>
<ul>
<li> Una expresión lambda puede tener un número variable de argumentos,
los cuales se indican mediante <code>[<var>L</var>]</code>, bien sea solo o como un
último argumento. Estos argumentos aparecerán dentro del cuerpo de
la función en forma de lista.
</li></ul>
<div class="example">
<pre class="example">(%i1) f : lambda ([aa, bb, [cc]], aa * cc + bb);
(%o1)          lambda([aa, bb, [cc]], aa cc + bb)
(%i2) f (foo, %i, 17, 29, 256);
(%o2)       [17 foo + %i, 29 foo + %i, 256 foo + %i]
(%i3) g : lambda ([[aa]], apply (&quot;+&quot;, aa));
(%o3)             lambda([[aa]], apply(+, aa))
(%i4) g (17, 29, x, y, z, %e);
(%o4)                  z + y + x + %e + 46
</pre></div>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdeffn_002flocal"></a><dl>
<dt><a name="index-local"></a>Función: <strong>local</strong> <em>(<var>v_1</var>, ..., <var>v_n</var>)</em></dt>
<dd>
<p>La declaración <code>local(<var>v_1</var>, ..., <var>v_m</var>)</code> dentro de un bloque
almacena las propiedades asociadas a los símbolos <var>v_1</var>, ..., <var>v_m</var>,
borra cualesquiera otras propiedades antes de evaluar las expresiones y
restaura las propiedades guardadas antes de abandonar el bloque.
</p>
<p>Algunas declaraciones, como <code>:=</code>, <code>array</code>, <code>dependencies</code>, <code>atvalue</code>,
<code>matchdeclare</code>, <code>atomgrad</code>, <code>constant</code>, <code>nonscalar</code>, <code>assume</code>
y otras se implementan como propiedades de símbolos.
El efecto producido por <code>local</code> consiste en hacer que tales declaraciones tengan
efecto sólo dentro del bloque, en otro caso las declaraciones dentro del bloque 
tendrían un efecto global que afectarían al exterior de <code>block</code>.
</p>
<p>La función <code>local</code> sólo puede usarse dentro de un <code>block</code>, en el
cuerpo de definición de funciones o de expresiones <code>lambda</code> o en la
función <code>ev</code>, siéndole permitido aparecer una sóla vez en cada una de ellas.
</p>
<p>La función <code>local</code> no evalúa sus argumentos y devuelve <code>done</code>.
</p>
<p>Ejemplo:
</p>
<p>Definición local de una función.
</p>
<div class="example">
<pre class="example">(%i1) foo (x) := 1 - x;
(%o1)                    foo(x) := 1 - x
(%i2) foo (100);
(%o2)                         - 99
(%i3) block (local (foo), foo (x) := 2 * x, foo (100));
(%o3)                          200
(%i4) foo (100);
(%o4)                         - 99
</pre></div>
</dd></dl>



<a name="Item_003a-Function_002ees_002fdefvr_002fmacroexpansion"></a><dl>
<dt><a name="index-macroexpansion"></a>Variable opcional: <strong>macroexpansion</strong></dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>La variable <code>macroexpansion</code> controla si la expansión (esto es, el valor de retorno) de una función macro se sustituye por la llamada a la función macro. Una sustitución puede acelerar futuras evaluaciones de la expresión, bajo el coste que implica tener que almacenar la expansión.
</p>
<dl compact="compact">
<dt><code>false</code></dt>
<dd><p>La expansión de una función macro no se sustituye por la llamada a la función macro.
</p></dd>
<dt><code>expand</code></dt>
<dd><p>La primera vez que se evalúa una llamada a función macro se almacena la expansión. De esta manera la expansión no se recalcula en llamadas posteriores; cualesquiera efectos laterales (como <code>print</code> o asignaciones a variables globales)
tan solo tienen lugar la primera vez que la función macro es evaluada. La expansión en una expresión no afecta a otras expresiones que llamen a la misma función macro.
</p></dd>
<dt><code>displace</code></dt>
<dd><p>La primera vez que se evalúa una llamada a una función macro, la expansión se sustituye por la llamada, modificando así la expresión desde la que se hizo la llamada a la función macro. La expansión no se recalcula en llamadas posteriores; cualesquiera efectos laterales tan solo tienen lugar la primera vez que la función macro es evaluada. La expansión en una expresión no afecta a otras expresiones que llamen a la misma función macro.
</p></dd>
</dl>

<p>Ejemplos:
</p>
<p>Si <code>macroexpansion</code> vale <code>false</code>,
una función macro es llamada cada vez que la expresión de llamada es evaluada.
</p>
<div class="example">
<pre class="example">(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print (&quot;x + 99 is equal to&quot;, x),
                       return (x + 99));
(%o2) g(x) ::= block(print(&quot;x + 99 is equal to&quot;, x), 
                     return(x + 99))
(%i3) h (x) ::= block (print (&quot;x - 99 is equal to&quot;, x),
                       return (x - 99));
(%o3) h(x) ::= block(print(&quot;x - 99 is equal to&quot;, x), 
                     return(x - 99))
(%i4) macroexpansion: false;
(%o4)                         false
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                  h(x)
(%t6)                     f(x) := ----
                                  g(x)

(%o6)                         done
(%i7) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o7)                       --------
                            a b + 99
</pre></div>

<p>Si <code>macroexpansion</code> vale <code>expand</code>, una función macro tan solo es llamada una vez.
</p>
<div class="example">
<pre class="example">(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print (&quot;x + 99 is equal to&quot;, x),
                       return (x + 99));
(%o2) g(x) ::= block(print(&quot;x + 99 is equal to&quot;, x), 
                     return(x + 99))
(%i3) h (x) ::= block (print (&quot;x - 99 is equal to&quot;, x),
                       return (x - 99));
(%o3) h(x) ::= block(print(&quot;x - 99 is equal to&quot;, x), 
                     return(x - 99))
(%i4) macroexpansion: expand;
(%o4)                        expand
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                  h(x)
(%t6)                     f(x) := ----
                                  g(x)

(%o6)                         done
(%i7) f (a * b);
                            a b - 99
(%o7)                       --------
                            a b + 99
</pre></div>

<p>Si <code>macroexpansion</code> vale <code>expand</code>, una función macro es llamada una vez y la expresión de llamada se modifica.
</p>
<div class="example">
<pre class="example">(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print (&quot;x + 99 is equal to&quot;, x), return (x + 99));
(%o2) g(x) ::= block(print(&quot;x + 99 is equal to&quot;, x), 
                                                  return(x + 99))
(%i3) h (x) ::= block (print (&quot;x - 99 is equal to&quot;, x), return (x - 99));
(%o3) h(x) ::= block(print(&quot;x - 99 is equal to&quot;, x), 
                                                  return(x - 99))
(%i4) macroexpansion: displace;
(%o4)                       displace
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                 x - 99
(%t6)                    f(x) := ------
                                 x + 99

(%o6)                         done
(%i7) f (a * b);
                            a b - 99
(%o7)                       --------
                            a b + 99
</pre></div>

</dd></dl>

<a name="Item_003a-Function_002ees_002fdefvr_002fmode_005fcheckp"></a><dl>
<dt><a name="index-mode_005fcheckp"></a>Variable opcional: <strong>mode_checkp</strong></dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Cuando <code>mode_checkp</code> vale <code>true</code>, <code>mode_declare</code> chequea los modos de las variables con valores asignados.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdefvr_002fmode_005fcheck_005ferrorp"></a><dl>
<dt><a name="index-mode_005fcheck_005ferrorp"></a>Variable opcional: <strong>mode_check_errorp</strong></dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Cuando <code>mode_check_errorp</code> vale <code>true</code>, <code>mode_declare</code> llama a error.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdefvr_002fmode_005fcheck_005fwarnp"></a><dl>
<dt><a name="index-mode_005fcheck_005fwarnp"></a>Variable opcional: <strong>mode_check_warnp</strong></dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Cuando <code>mode_check_warnp</code> vale <code>true</code>, se detallan los errores de modo.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdeffn_002fmode_005fdeclare"></a><dl>
<dt><a name="index-mode_005fdeclare"></a>Función: <strong>mode_declare</strong> <em>(<var>y_1</var>, <var>modo_1</var>, ..., <var>y_n</var>, <var>modo_n</var>)</em></dt>
<dd>
<p>La función <code>mode_declare</code> se utiliza para declarar los modos de variables y funciones para la ulterior traducción a Lisp o compilación de funciones. Se coloca habitualmente al comienzo de la definición de una función, de un script en Maxima o se ejecuta en tiempo real.
</p>
<p>Los argumentos de <code>mode_declare</code> son pares formados por una variable y un modo, el cual debe ser <code>boolean</code>, <code>fixnum</code>, <code>number</code>, <code>rational</code> o <code>float</code>. Cada variable puede ser sustituida por una lista de variables, en cuyo caso todas ellas tendrán el mismo modo.
</p>

<p>Código numérico que utilice arreglos puede ejecutarse más rápido declarando el tamaño que va a ocupar el arreglo, como en:
</p>
<div class="example">
<pre class="example">mode_declare (array (a [10, 10]), float)
</pre></div>

<p>para un arreglo de números en coma flotante de dimensiones 10 x 10.
</p>
<p>Se puede declarar el modo del resultado de una función poniendo <code>function (f_1, f_2, ...)</code> como argumento;
aquí <code>f_1</code>, <code>f_2</code>, ... son los nombres de las funciones. Por ejemplo, la expresión
</p>
<div class="example">
<pre class="example">mode_declare ([function (f_1, f_2, ...)], fixnum)
</pre></div>

<p>declara que el valor a devolver por  <code>f_1</code>, <code>f_2</code>, ... son enteros de modo &quot;single-word&quot;.
</p>
<p>El nombre <code>modedeclare</code> es sinónimo de <code>mode_declare</code>.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdeffn_002fmode_005fidentity"></a><dl>
<dt><a name="index-mode_005fidentity"></a>Función: <strong>mode_identity</strong> <em>(<var>arg_1</var>, <var>arg_2</var>)</em></dt>
<dd><p>Es una forma especial usada con <code>mode_declare</code> y <code>macros</code> para declarar, por ejemplo, una lista de listas de números. 
</p>

</dd></dl>



<a name="Item_003a-Function_002ees_002fdeffn_002fremfunction"></a><dl>
<dt><a name="index-remfunction"></a>Función: <strong>remfunction</strong> <em>(<var>f_1</var>, ..., <var>f_n</var>)</em></dt>
<dt><a name="index-remfunction-1"></a>Función: <strong>remfunction</strong> <em>(all)</em></dt>
<dd><p>Desliga las definiciones de función de sus símbolos <var>f_1</var>, ..., <var>f_n</var>.
Los argumentos pueden ser nombres de funciones ordinarias 
(creadas con <code>:=</code> o <code>define</code>) o de funciones macro (creadas con <code>::=</code>).
</p>
<p>La instrucción <code>remfunction (all)</code> desliga todas las definiciones de funciones.
</p>
<p>La función <code>remfunction</code> no evalúa sus argumentos.
</p>
<p>La función <code>remfunction</code> devuelve una lista con los
símbolos para los que la definición de función
fue desligada. Devuelve <code>false</code> en el lugar de cualquier 
símbolo para el que no hay función definida.
</p>
<p>La función <code>remfunction</code> no se puede aplicar a arrays de funciones ni a
funciones subindicadas. Sí es aplicable en tales casos la 
función <code>remarray</code>.
</p></dd></dl>


<a name="Item_003a-Function_002ees_002fdefvr_002fsavedef"></a><dl>
<dt><a name="index-savedef"></a>Variable opcional: <strong>savedef</strong></dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>savedef</code> vale <code>true</code>, se mantiene la versión Maxima de una función definida por el usuario cuando ésta se traduce, lo que permite mostrar su código con <code>dispfun</code> y que la función pueda ser editada.
</p>
<p>Si <code>savedef</code> vale <code>false</code>, los nombres de las funciones traducidas se eliminan de la lista <code>functions</code>.
</p>
</dd></dl>



<a name="Item_003a-Function_002ees_002fdefvr_002ftranscompile"></a><dl>
<dt><a name="index-transcompile"></a>Variable opcional: <strong>transcompile</strong></dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>transcompile</code> vale <code>true</code>, <code>translate</code> y <code>translate_file</code> generan declaraciones para hacer el código traducido más apto para la compilación.
</p>
<p>La función <code>compfile</code> hace la asignación <code>transcompile: true</code>.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdeffn_002ftranslate"></a><dl>
<dt><a name="index-translate"></a>Función: <strong>translate</strong> <em>(<var>f_1</var>, ..., <var>f_n</var>)</em></dt>
<dt><a name="index-translate-1"></a>Función: <strong>translate</strong> <em>(functions)</em></dt>
<dt><a name="index-translate-2"></a>Función: <strong>translate</strong> <em>(all)</em></dt>
<dd>
<p>Traduce las funciones definidas por el usuario <var>f_1</var>, ..., <var>f_n</var> del lenguaje de Maxima a Lisp y evalúa las traducciones Lisp. Normalmente las funciones traducidas se ejecutan más rapidamente que las originales.
</p>
<p>Las llamadas <code>translate (all)</code> o <code>translate (functions)</code> traducen todas las funciones de usuario.
</p>
<p>Las funciones a ser traducidas deberían incluir una llamada a <code>mode_declare</code> al comienzo siempre que sea posible, a fin de producir código más eficiente. Por ejemplo:
</p>
<div class="example">
<pre class="example">f (x_1, x_2, ...) := block ([v_1, v_2, ...],
    mode_declare (v_1, modo_1, v_2, modo_2, ...), ...)
</pre></div>


<p>donde <var>x_1</var>, <var>x_2</var>, ... son los parámetros que se pasan a la función y <var>v_1</var>, <var>v_2</var>, ... son las variables locales.
</p>
<p>Los nombres de las funciones traducidas son eliminados de la lista <code>functions</code> si <code>savedef</code> vale <code>false</code> (ver más abajo) y son añadidos a las listas <code>props</code>.
</p>
<p>Las funciones no deberían ser traducidas hasta no estar completamente depuradas.
</p>
<p>Se supone que las expresiones están simplificadas; en caso de no estarlo, se generará código correcto pero ineficiente. Así, el usuario no debería asignar a <code>simp</code> el valor <code>false</code>, el cual inhibe la simplificación de la expresión a ser traducida.
</p>
<p>Cuando la variable <code>translate</code> vale <code>true</code>, se traducen automáticamente las funciones de usuario a Lisp.
</p>
<p>Nótese que las funciones traducidas puede que no se ejecuten exactamente igual a como lo hacían antes de la traducción, debido a posibles incompatibilidades entre las versiones de Maxima y Lisp. En general, la función <code>rat</code> con más de un argumento y la función <code>ratvars</code> no deberían utilizarse si algunas de las variables son declaradas como expresiones racionales canónicas (CRE) mediante <code>mode_declare</code>. Además, la asignación  <code>prederror: false</code> no traducirá.
</p>
<p>Si <code>savedef</code> vale <code>true</code>, entonces la versión de Maxima de una función de usuario permanecerá cuando la función sea traducida por <code>translate</code>. Con esto se hace posible que se muestre la definición llamando a <code>dispfun</code> y que la función sea editada.
</p>
<p>Si <code>transrun</code> vale <code>false</code> entonces las versiones interpretadas de todas las funciones serán ejecutadas en lugar de las versiones traducidas.
</p>
<p>El resultado devuelto por <code>translate</code> es una lista con los nombres de las funciones traducidas.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdeffn_002ftranslate_005ffile"></a><dl>
<dt><a name="index-translate_005ffile"></a>Función: <strong>translate_file</strong> <em>(<var>nombre_fichero_maxima</var>)</em></dt>
<dt><a name="index-translate_005ffile-1"></a>Función: <strong>translate_file</strong> <em>(<var>nombre_fichero_maxima</var>, <var>nombre_fichero_lisp</var>)</em></dt>
<dd>
<p>Traduce un fichero en código Maxima a un fichero en código Lisp. La función <code>translate_file</code> devuelve una lista con los nombres de tres ficheros: el nombre del ficheero en Maxima, el nombre del fichero en Lisp y el nombre del fichero que contiene información adicional sobre la traducción. La función <code>translate_file</code> evalúa sus argumentos.
</p>
<p>La llamada <code>translate_file (&quot;foo.mac&quot;); load(&quot;foo.LISP&quot;)</code> es lo mismo que <code>batch (&quot;foo.mac&quot;)</code>, excepto por la presencia de ciertas restricciones, como el uso de <code>'<!-- /@w -->'</code> y <code>%</code>, por ejemplo.
</p>
<p>La llamada <code>translate_file (<var>nombre_fichero_maxima</var>)</code> traduce un fichero en Maxima, <var>nombre_fichero_maxima</var>, a otro en Lisp de nombre similar. Por ejemplo, <code>foo.mac</code> se traduce en <code>foo.LISP</code>. El nombre del fichero en Maxima puede incluir el nombre de un directorio, en cuyo caso el fichero de salida Lisp se guardará en el mismo directorio desde el que se leyó la fuente Maxima.
</p>
<p>La llamada <code>translate_file (<var>nombre_fichero_maxima</var>, <var>nombre_fichero_lisp</var>)</code> traduce el fichero Maxima  <var>nombre_fichero_maxima</var> en el fichero Lisp <var>nombre_fichero_lisp</var>. La función <code>translate_file</code> ignora la extensión del fichero, en caso de que exista, de <code>nombre_fichero_lisp</code>; la extensión del fichero de salida Lisp  será invariablemente <code>LISP</code>. El nombre del fichero Lisp puede incluir la ruta del directorio, en cuyo caso se almacenará en el directorio especificado.
</p>
<p>La función <code>translate_file</code> también escribe un fichero de mensajes de avisos del traductor con diversos niveles de gravedad. La extensión de este fichero es <code>UNLISP</code>. Este fichero puede contener información valiosa, aunque de difícil interpretación, para detectar fallos en el código traducido. El fichero <code>UNLISP</code> se guarda siempre en el mismo directorio desde el que se leyó la fuente de Maxima.
</p>
<p>La función <code>translate_file</code> emite código Lisp que incluye algunas declaraciones y definiciones que entran en efecto tan pronto como el código Lisp es compilado. Véase <code>compile_file</code> para más información sobre este particular.
</p>
<p>Véanse también <code>tr_array_as_ref</code>,
<code>tr_bound_function_applyp</code>,
<code>tr_exponent</code>,
<code>tr_file_tty_messagesp</code>, 
<code>tr_float_can_branch_complex</code>,
<code>tr_function_call_default</code>, 
<code>tr_numer</code>,
<code>tr_optimize_max_loop</code>, 
<code>tr_semicompile</code>,
<code>tr_state_vars</code>, 
<code>tr_warnings_get</code>,
<code>tr_warn_bad_function_calls</code>,
<code>tr_warn_fexpr</code>, 
<code>tr_warn_meval</code>,
<code>tr_warn_mode</code>,
<code>tr_warn_undeclared</code>,
y <code>tr_warn_undefined_variable</code>.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdefvr_002ftransrun"></a><dl>
<dt><a name="index-transrun"></a>Variable opcional: <strong>transrun</strong></dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>transrun</code> vale <code>false</code> entonces se ejecutarán las versiones interpretadas de todas las funciones, en lugar de las versiones traducidas.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdefvr_002ftr_005farray_005fas_005fref"></a><dl>
<dt><a name="index-tr_005farray_005fas_005fref"></a>Variable opcional: <strong>tr_array_as_ref</strong></dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>translate_fast_arrays</code> vale <code>false</code>, referencias de arreglos en el código Lisp creadas por  <code>translate_file</code> se ven afectadas por <code>tr_array_as_ref</code>.
</p>
<p>El valor de la variable <code>tr_array_as_ref</code> no tiene ningún efecto cuando <code>translate_fast_arrays</code> vale <code>true</code>.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdefvr_002ftr_005fbound_005ffunction_005fapplyp"></a><dl>
<dt><a name="index-tr_005fbound_005ffunction_005fapplyp"></a>Variable opcional: <strong>tr_bound_function_applyp</strong></dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>tr_bound_function_applyp</code> vale <code>true</code>, Maxima envía un aviso si encuentra una variable con valor asignado que está siendo utilizada como una función. <code>tr_bound_function_applyp</code> no influye en el código generado bajo estas circunstancias.
</p>
<p>Por ejemplo, una expresión como <code>g (f, x) := f (x+1)</code> provocará un mensaje de esta naturaleza.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdefvr_002ftr_005ffile_005ftty_005fmessagesp"></a><dl>
<dt><a name="index-tr_005ffile_005ftty_005fmessagesp"></a>Variable opcional: <strong>tr_file_tty_messagesp</strong></dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>tr_file_tty_messagesp</code> vale <code>true</code>, los mensajes generados por <code>translate_file</code> durante la traducción de un fichero se muestran en la consola y se insertan en el fichero UNLISP.  Si vale <code>false</code>, los mensajes sobre la traducción del fichero sólo se incorporan al fichero UNLISP.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdefvr_002ftr_005ffloat_005fcan_005fbranch_005fcomplex"></a><dl>
<dt><a name="index-tr_005ffloat_005fcan_005fbranch_005fcomplex"></a>Variable opcional: <strong>tr_float_can_branch_complex</strong></dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Le dice al traductor de Maxima a Lisp que las funciones <code>acos</code>, <code>asin</code>, <code>asec</code> y <code>acsc</code> pueden devolver valores complejos.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdefvr_002ftr_005ffunction_005fcall_005fdefault"></a><dl>
<dt><a name="index-tr_005ffunction_005fcall_005fdefault"></a>Variable opcional: <strong>tr_function_call_default</strong></dt>
<dd><p>Valor por defecto: <code>general</code>
</p>
<p>El valor <code>false</code> significa llama a <code>meval</code>, <code>expr</code> significa que Lisp asignó los argumentos de la función,  <code>general</code>, el valor por defecto, devuelve código apropiado para <code>mexprs</code> y <code>mlexprs</code> pero no para <code>macros</code>. La opción <code>general</code> asegura que las asignaciones de las variables son correctas en el código compilado. En modo <code>general</code>, cuando se traduce F(X), si F es una variable con valor, entonces se entiende que se quiere calcular <code>apply (f, [x])</code>, y como tal se traduce, con el apropiado aviso. No es necesario desactivar esto. Con los valores por defecto la falta de mensajes de aviso implica compatibilidad completa entre el código traducido y compilado con el interpretado por Maxima.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdefvr_002ftr_005fnumer"></a><dl>
<dt><a name="index-tr_005fnumer"></a>Variable opcional: <strong>tr_numer</strong></dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>tr_numer</code> vale <code>true</code> se utilizan las propiedades numéricas en aquellos átomos que las posean, como en  <code>%pi</code>.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdefvr_002ftr_005foptimize_005fmax_005floop"></a><dl>
<dt><a name="index-tr_005foptimize_005fmax_005floop"></a>Variable opcional: <strong>tr_optimize_max_loop</strong></dt>
<dd><p>Valor por defecto: 100
</p>
<p>El valor de <code>tr_optimize_max_loop</code> es el número máximo de veces que el traductor repetirá la macro-expansión y la optimización en el tratamiento de una expresión.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdefvr_002ftr_005fsemicompile"></a><dl>
<dt><a name="index-tr_005fsemicompile"></a>Variable opcional: <strong>tr_semicompile</strong></dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>tr_semicompile</code> vale <code>true</code>, las salidas de <code>translate_file</code> y <code>compfile</code> serán macro-expandidas pero no compiladas a código máquina por el compilador de Lisp.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdefvr_002ftr_005fstate_005fvars"></a><dl>
<dt><a name="index-tr_005fstate_005fvars"></a>Variable del sistema: <strong>tr_state_vars</strong></dt>
<dd><p>Valor por defecto:
</p>
<div class="example">
<pre class="example">[transcompile, tr_semicompile, tr_warn_undeclared, tr_warn_meval,
tr_warn_fexpr, tr_warn_mode, tr_warn_undefined_variable,
tr_function_call_default, tr_array_as_ref,tr_numer]
</pre></div>

<p>Es la lista de variables que afectan la forma en que se obtiene la salida del código traducido. Esta información es útil para desarrolladores que pretendan corregir posibles fallos del traductor. Comparando el código traducido con el que se debería obtener bajo unas ciertas condiciones, es posible hacer el seguimiento de los fallos.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdeffn_002ftr_005fwarnings_005fget"></a><dl>
<dt><a name="index-tr_005fwarnings_005fget"></a>Función: <strong>tr_warnings_get</strong> <em>()</em></dt>
<dd>
<p>Devuelve una lista con los avisos dados por el traductor.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdefvr_002ftr_005fwarn_005fbad_005ffunction_005fcalls"></a><dl>
<dt><a name="index-tr_005fwarn_005fbad_005ffunction_005fcalls"></a>Variable opcional: <strong>tr_warn_bad_function_calls</strong></dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Devuelve un aviso cuando se hacen llamadas a funciones que quizás no sean correctas debido a declaraciones inapropiadas realizadas durante la traducción.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdefvr_002ftr_005fwarn_005ffexpr"></a><dl>
<dt><a name="index-tr_005fwarn_005ffexpr"></a>Variable opcional: <strong>tr_warn_fexpr</strong></dt>
<dd><p>Valor por defecto: <code>compfile</code>
</p>
<p>Devuelve un aviso si se encuentra con alguna FEXPR. Las FEXPR no deberían aparecer en el código traducido.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdefvr_002ftr_005fwarn_005fmeval"></a><dl>
<dt><a name="index-tr_005fwarn_005fmeval"></a>Variable opcional: <strong>tr_warn_meval</strong></dt>
<dd><p>Valor por defecto: <code>compfile</code>
</p>
<p>Devuelve un aviso si la función <code>meval</code> es llamada.  Si <code>meval</code> es invocada, es señal de la presencia de problemas en la traducción.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdefvr_002ftr_005fwarn_005fmode"></a><dl>
<dt><a name="index-tr_005fwarn_005fmode"></a>Variable opcional: <strong>tr_warn_mode</strong></dt>
<dd><p>Valor por defecto: <code>all</code>
</p>
<p>Devuelve un aviso cuando a las variables se les asignan valores incompatibles con su modo.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdefvr_002ftr_005fwarn_005fundeclared"></a><dl>
<dt><a name="index-tr_005fwarn_005fundeclared"></a>Variable opcional: <strong>tr_warn_undeclared</strong></dt>
<dd><p>Valor por defecto: <code>compile</code>
</p>
<p>Determina cuando enviar mensajes sobre variables no declaradas.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdefvr_002ftr_005fwarn_005fundefined_005fvariable"></a><dl>
<dt><a name="index-tr_005fwarn_005fundefined_005fvariable"></a>Variable opcional: <strong>tr_warn_undefined_variable</strong></dt>
<dd><p>Valor por defecto: <code>all</code>
</p>
<p>Devuelve un aviso cuando se detectan variables globales no definidas.
</p>
</dd></dl>

<a name="Item_003a-Function_002ees_002fdeffn_002fcompile_005ffile"></a><dl>
<dt><a name="index-compile_005ffile"></a>Función: <strong>compile_file</strong> <em>(<var>nombre_fich</var>)</em></dt>
<dt><a name="index-compile_005ffile-1"></a>Función: <strong>compile_file</strong> <em>(<var>nombre_fich</var>, <var>nombre_fich_compilado</var>)</em></dt>
<dt><a name="index-compile_005ffile-2"></a>Función: <strong>compile_file</strong> <em>(<var>nombre_fich</var>, <var>nombre_fich_compilado</var>, <var>nombre_fich_lisp</var>)</em></dt>
<dd>
<p>Traduce el fichero Maxima <var>nombre_fich</var> a Lisp, ejecuta el compilador de Lisp y, en caso de ser exitosa la compilación, carga el código compilado en Maxima.
</p>
<p>La función <code>compile_file</code> devuelve una lista con los nombres de tres ficheros: el fichero original en Maxima, la traducción Lisp, notas sobre la traducción y el código compilado. Si la compilación falla, el cuarto elemento es  <code>false</code>.
</p>
<p>Algunas declaraciones y definiciones entran en efecto tan pronto como el código Lisp es compilado (sin cargar el código compilado). Éstas incluyen funciones definidas con el operador <code>:=</code>, macros definidas con el operador <code>::=</code>, <code>alias</code>, <code>declare</code>, <code>define_variable</code>,  <code>mode_declare</code> y <code>infix</code>, <code>matchfix</code>,
<code>nofix</code>, <code>postfix</code>, <code>prefix</code> y <code>compfile</code>.
</p>
<p>Asignaciones y llamadas a funciones no se evalúan hasta que el código compilado es cargado. En particular, dentro del fichero Maxima, asignaciones a los controles (&quot;flags&quot;) de traducción (<code>tr_numer</code>, etc.) no tienen efecto durante la traducción.
</p>
<p>El <var>nombre_fich</var> no puede contener sentencias del tipo <code>:lisp</code>.
</p>
<p>La función <code>compile_file</code> evalúa sus argumentos.
</p>
</dd></dl>


<a name="Item_003a-Function_002ees_002fdeffn_002fdeclare_005ftranslated"></a><dl>
<dt><a name="index-declare_005ftranslated"></a>Función: <strong>declare_translated</strong> <em>(<var>f_1</var>, <var>f_2</var>, ...)</em></dt>
<dd>
<p>Cuando se traduce un fichero de código Maxima a Lisp, es importante para el traductor saber qué funciones de las que están en el fichero van a ser llamadas como traducidas o compiladas, y cuáles son simplemente funciones Maxima o que no están definidas. Se genera el código <code>(MFUNCTION-CALL fn arg1 arg2 ...)</code> cuando el traductor no sabe si <code>fn</code> va a ser una función lisp.
</p>
</dd></dl>


<hr>
<div class="header">
<p>
Previous: <a href="maxima_160.html#Macros" accesskey="p" rel="previous">Macros</a>, Subir: <a href="maxima_157.html#Definici_00f3n-de-Funciones" accesskey="u" rel="up">Definición de Funciones</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="&Iacute;ndice general" rel="contents">&Iacute;ndice general</a>][<a href="maxima_304.html#g_t_00cdndice-de-Funciones-y-Variables" title="&Iacute;ndice" rel="index">&Iacute;ndice</a>]</p>
</div>



</body>
</html>
