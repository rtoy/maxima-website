<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Manual de Maxima 5.46.0: Funciones y variables para simplificación</title>

<meta name="description" content="Manual de Maxima 5.46.0: Funciones y variables para simplificación">
<meta name="keywords" content="Manual de Maxima 5.46.0: Funciones y variables para simplificación">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="maxima_toc.html#Top" rel="start" title="Top">
<link href="maxima_304.html#g_t_00cdndice-de-Funciones-y-Variables" rel="index" title="Índice de Funciones y Variables">
<link href="maxima_toc.html#SEC_Contents" rel="contents" title="&Iacute;ndice General">
<link href="maxima_45.html#Simplificaci_00f3n" rel="up" title="Simplificación">
<link href="maxima_48.html#Funciones-matem_00e1ticas" rel="next" title="Funciones matemáticas">
<link href="maxima_46.html#Introducci_00f3n-a-la-simplificaci_00f3n" rel="previous" title="Introducción a la simplificación">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 1em; padding-bottom: 1em;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%; display: block; margin-left: auto; margin-right: auto}

-->
</style>

<link rel="icon" href="../figures/favicon.ico">

</head>

<body lang="es" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="Funciones-y-variables-para-simplificaci_00f3n"></a>
<div class="header">
<p>
Previous: <a href="maxima_46.html#Introducci_00f3n-a-la-simplificaci_00f3n" accesskey="p" rel="previous">Introducción a la simplificación</a>, Subir: <a href="maxima_45.html#Simplificaci_00f3n" accesskey="u" rel="up">Simplificación</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="&Iacute;ndice general" rel="contents">&Iacute;ndice general</a>][<a href="maxima_304.html#g_t_00cdndice-de-Funciones-y-Variables" title="&Iacute;ndice" rel="index">&Iacute;ndice</a>]</p>
</div>
<a name="Funciones-y-variables-para-simplificacion"></a>
<h3 class="section">9.2 Funciones y variables para simplificación</h3>


<a name="Item_003a-Simplification_002ees_002fdefvr_002fadditive"></a><dl>
<dt><a name="index-additive"></a>Propiedad: <strong>additive</strong></dt>
<dd><p>Si <code>declare(f,additive)</code> ha sido ejecutado, entonces: 
</p>
<p>(1) Si <code>f</code> es univariado, cada vez que el simplificador encuentre
<code>f</code> aplicada a una suma, <code>f</code> será distribuida bajo esta suma. Por ejemplo, <code>f(x+y)</code> se simplificará a <code>f(x)+f(y)</code>. 
</p>
<p>(2) Si <code>f</code> es una función de 2 o más argumentos, aditivamente es definida como aditiva en el primer argumento de <code>f</code>, como en el caso de <code>sum</code> o <code>integrate</code>. Por ejemplo, <code>f(h(x)+g(x),x)</code> se simplificará a <code>f(h(x),x)+f(g(x),x)</code>. Esta simplificación no ocurre cuando <code>f</code> se aplica a expresiones de la forma <code>sum(x[i],i,lower-limit,upper-limit)</code>.
</p>
<p>Ejemplo:
</p>
<div class="example">
<pre class="example">(%i1) F3 (a + b + c);
(%o1)                     F3(c + b + a)
(%i2) declare (F3, additive);
(%o2)                         done
(%i3) F3 (a + b + c);
(%o3)                 F3(c) + F3(b) + F3(a)
</pre></div>
</dd></dl>


<a name="Item_003a-Simplification_002ees_002fdefvr_002fantisymmetric"></a><dl>
<dt><a name="index-antisymmetric"></a>Propiedad: <strong>antisymmetric</strong></dt>
<dd><p>Si <code>declare(h,antisymmetric)</code> es ejecutado, esto dice al 
simplificador que <code>h</code> es antisimétrico. E.g. <code>h(x,z,y)</code> será 
simplificado a <code>-h(x,y,z)</code>. Que es, el producto de (-1)^n por el resultado 
dado por <code>symmetric</code> o <code>commutative</code>, donde n es el número de intercambios 
necesarios de dos argumentos para convertirle a esta forma.  
</p>
<p>Ejemplos:
</p>
<div class="example">
<pre class="example">(%i1) S (b, a);
(%o1)                        S(b, a)
(%i2) declare (S, symmetric);
(%o2)                         done
(%i3) S (b, a);
(%o3)                        S(a, b)
(%i4) S (a, c, e, d, b);
(%o4)                   S(a, b, c, d, e)
(%i5) T (b, a);
(%o5)                        T(b, a)
(%i6) declare (T, antisymmetric);
(%o6)                         done
(%i7) T (b, a);
(%o7)                       - T(a, b)
(%i8) T (a, c, e, d, b);
(%o8)                   T(a, b, c, d, e)
</pre></div>
</dd></dl>


<a name="Item_003a-Simplification_002ees_002fdeffn_002fcombine"></a><dl>
<dt><a name="index-combine"></a>Función: <strong>combine</strong> <em>(<var>expr</var>)</em></dt>
<dd><p>Simplifica la suma <var>expr</var> combinando términos de con igual denominador reduciéndolos a un único término.
</p>
</dd></dl>



<a name="Item_003a-Simplification_002ees_002fdefvr_002fcommutative"></a><dl>
<dt><a name="index-commutative"></a>Propiedad: <strong>commutative</strong></dt>
<dd><p>Si <code>declare(h,commutative)</code> es ejecutado, le dice al simplificador
que <code>h</code> es una función conmutaiva. Por ejemplo, <code>h(x,z,y)</code> se simplificará a <code>h(x,y,z)</code>. Esto es lo mismo que <code>symmetric</code>. 
</p>
</dd></dl>


<a name="Item_003a-Simplification_002ees_002fdeffn_002fdemoivre"></a><dl>
<dt><a name="index-demoivre"></a>Función: <strong>demoivre</strong> <em>(<var>expr</var>)</em></dt>
<dt><a name="index-demoivre-1"></a>Variable opcional: <strong>demoivre</strong></dt>
<dd>
<p>La función <code>demoivre (expr)</code> convierte una expresión sin modificar la variable global <code>demoivre</code>.
</p>
<p>Cuando <code>demoivre</code> vale <code>true</code>, los exponenciales complejos se convierten en expresiones equivalentes pero en términos de las funciones trigonométricas:
<code>exp (a + b*%i)</code> se reduce a <code>%e^a * (cos(b) + %i*sin(b))</code>
si <code>b</code> no contiene a <code>%i</code>. Las expresiones <code>a</code> y <code>b</code> no se expanden.
</p>
<p>El valor por defecto de <code>demoivre</code> es <code>false</code>.
</p>
<p>La función <code>exponentialize</code> convierte funciones trigonométricas e hiperbólicas a la forma exponencial, por lo que  <code>demoivre</code> y <code>exponentialize</code> no pueden valer <code>true</code> al mismo tiempo.
</p>
</dd></dl>


<a name="Item_003a-Simplification_002ees_002fdeffn_002fdistrib"></a><dl>
<dt><a name="index-distrib"></a>Función: <strong>distrib</strong> <em>(<var>expr</var>)</em></dt>
<dd><p>Distribuye sumas sobre productos. Difiere de <code>expand</code>
en que trabaja sólo al nivel superior de una expresión, siendo más rápida que <code>expand</code>.  Difiere de  <code>multthru</code> en que expande todas las sumas del nivel superior.
</p>
<p>Ejemplos:
</p>
<div class="example">
<pre class="example">(%i1) distrib ((a+b) * (c+d));
(%o1)                 b d + a d + b c + a c
(%i2) multthru ((a+b) * (c+d));
(%o2)                 (b + a) d + (b + a) c
(%i3) distrib (1/((a+b) * (c+d)));
                                1
(%o3)                    ---------------
                         (b + a) (d + c)
(%i4) expand (1/((a+b) * (c+d)), 1, 0);
                                1
(%o4)                 ---------------------
                      b d + a d + b c + a c
</pre></div>

</dd></dl>



<a name="Item_003a-Simplification_002ees_002fdefvr_002fdistribute_005fover"></a><dl>
<dt><a name="index-distribute_005fover"></a>Variable opcional: <strong>distribute_over</strong></dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p><code>distribute_over</code> controla la distribución de funciones sobre
estructuras como listas, matrices y ecuaciones. Actualmente, no todas
las funciones de Maxima tienen esta propiedad. Es posible consultar si
una función tiene esta propiedad con la instrucción <code>properties</code>.
</p>
<p>La propiedad distributiva se desactiva asignándole a <code>distribute_over</code>
el valor <code>false</code>.
</p>
<p>Ejemplos:
</p>
<p>La función <code>sin</code> se distribuye sobre una lista:
</p>
<div class="example">
<pre class="example">(%i1) sin([x,1,1.0]);
(%o1)                 [sin(x), sin(1), .8414709848078965]
</pre></div>

<p><code>mod</code> es una función de dos argumentos que se distribuye sobre listas.
La distribución sobre listas anidadas también es posible.
</p>
<div class="example">
<pre class="example">(%i2) mod([x,11,2*a],10);
(%o2)                    [mod(x, 10), 1, 2 mod(a, 5)]
(%i3) mod([[x,y,z],11,2*a],10);
(%o3)       [[mod(x, 10), mod(y, 10), mod(z, 10)], 1, 2 mod(a, 5)]
</pre></div>

<p>Distribución de la función <code>floor</code> sobre una matriz y una
ecuación.
</p>
<div class="example">
<pre class="example">(%i4) floor(matrix([a,b],[c,d]));
                            [ floor(a)  floor(b) ]
(%o4)                       [                    ]
                            [ floor(c)  floor(d) ]
(%i5) floor(a=b);
(%o5)                         floor(a) = floor(b)
</pre></div>

<p>Funciones con más de un argumento se distribuyen sobre cualquiera
de sus argumentos, o sobre todos ellos.
</p>
<div class="example">
<pre class="example">(%i6) expintegral_e([1,2],[x,y]);
(%o6) [[expintegral_e(1, x), expintegral_e(1, y)], 
       [expintegral_e(2, x), expintegral_e(2, y)]]
</pre></div>

<p>Comprueba si una función tiene la propiedad <code>distribute_over</code>:
</p>
<div class="example">
<pre class="example">(%i7) properties(abs);
(%o7) [integral, distributes over bags, noun, rule, gradef]
</pre></div>
</dd></dl>


<a name="Item_003a-Simplification_002ees_002fdefvr_002fdomain"></a><dl>
<dt><a name="index-domain"></a>Variable opcional: <strong>domain</strong></dt>
<dd><p>Valor por defecto: <code>real</code>
</p>
<p>Si <code>domain</code> vale <code>complex</code>, <code>sqrt (x^2)</code> permanecerá como
<code>sqrt (x^2)</code> en lugar de devolver <code>abs(x)</code>.
</p>

</dd></dl>


<a name="Item_003a-Simplification_002ees_002fdefvr_002fevenfun"></a><dl>
<dt><a name="index-evenfun"></a>Propiedad: <strong>evenfun</strong></dt>
<dd><a name="Item_003a-Simplification_002ees_002fdefvr_002foddfun"></a></dd><dt><a name="index-oddfun"></a>Propiedad: <strong>oddfun</strong></dt>
<dd>
<p><code>declare(f, evenfun</code> o <code>declare(f, oddfun)</code> indican a Maxima que reconozca
la función <code>f</code> como par o impar, respectivamente.
</p>
<p>Ejemplos:
</p>
<div class="example">
<pre class="example">(%i1) o (- x) + o (x);
(%o1)                     o(x) + o(- x)
(%i2) declare (o, oddfun);
(%o2)                         done
(%i3) o (- x) + o (x);
(%o3)                           0
(%i4) e (- x) - e (x);
(%o4)                     e(- x) - e(x)
(%i5) declare (e, evenfun);
(%o5)                         done
(%i6) e (- x) - e (x);
(%o6)                           0
</pre></div>
</dd></dl>




<a name="Item_003a-Simplification_002ees_002fdeffn_002fexpand"></a><dl>
<dt><a name="index-expand"></a>Función: <strong>expand</strong> <em>(<var>expr</var>)</em></dt>
<dt><a name="index-expand-1"></a>Función: <strong>expand</strong> <em>(<var>expr</var>, <var>p</var>, <var>n</var>)</em></dt>
<dd><p>Expande la expresión <var>expr</var>. Los productos de sumas y de sumas con exponentes se multiplican, los numeradores de las expresiones racionales que son sumas se separan en sus respectivos términos, y las multiplicaciones (tanto las que son conmutativas como las que no) se distribuyen sobre las sumas en todos los niveles de <var>expr</var>.
</p>
<p>En el caso de los polinomios es más aconsejable utilizar <code>ratexpand</code>, que utiliza un algoritmo más eficiente.
</p>
<p>Las variables <code>maxnegex</code> y <code>maxposex</code> controlan los máximos exponentes negativos y positivos que se van a expandir.
</p>
<p>La llamada <code>expand (<var>expr</var>, <var>p</var>, <var>n</var>)</code> expande <var>expr</var> asignando a <code>maxposex</code> el valor <var>p</var> y a <code>maxnegex</code> el <var>n</var>. Esto es útil para expandir sólo parte de la expresión.
</p>
<p>La variable <code>expon</code> guarda el mayor exponente negativo que será expandido automáticamente, independientemente de <code>expand</code>. Por ejemplo, si <code>expon</code> vale 4 entonces <code>(x+1)^(-5)</code> no se expandirá automáticamente.
</p>
<p>La variable <code>expop</code> guarda el mayor exponente positivo que será expandido automáticamente.  Así, <code>(x+1)^3</code> se expandirá automáticamente sólo si <code>expop</code> es mayor o igual que 3. Si se quiere expandir <code>(x+1)^n</code>, siendo <code>n</code> mayor que <code>expop</code>, entonces <code>expand ((x+1)^n)</code> se desarrollará sólo si <code>maxposex</code> no es menor que <code>n</code>.
</p>
<p><code>expand(expr, 0, 0)</code> provoca que se vuelva a simplificar <code>expr</code>.
<code>expr</code> no se vuelve a evaluar. A diferencia de <code>ev(expr, noeval)</code>,
se elimina la representación canónica de la expresión. 
Véase también <code>ev</code>.
</p>
<p>La variable <code>expand</code> utilizada con <code>ev</code> provocará una expansión.
</p>
<p>El fichero <samp>share/simplification/facexp.mac</samp>
contiene algunas funciones relacionadas con <code>expand</code> (en concreto, <code>facsum</code>, <code>factorfacsum</code>
y <code>collectterms</code>, que se cargan automáticamente) y variables (<code>nextlayerfactor</code>
y <code>facsum_combine</code>) que permiten al usuario estructurar las expresiones controlando la expansión.
En  <samp>simplification/facexp.usg</samp> se pueden encontrar breves descripciones de estas funciones.
Se accederá a una demostración con la instrucción <code>demo(&quot;facexp&quot;)</code>.
</p>
<p>Ejemplo:
</p>
<div class="example">
<pre class="example">(%i1) expr:(x+1)^2*(y+1)^3;
                                      2        3
(%o1)                          (x + 1)  (y + 1)
(%i2) expand(expr);
       2  3        3    3      2  2        2      2      2
(%o2) x  y  + 2 x y  + y  + 3 x  y  + 6 x y  + 3 y  + 3 x  y
                                                 2
                                + 6 x y + 3 y + x  + 2 x + 1

(%i3) expand(expr,2);
                      2        3              3          3
(%o3)                x  (y + 1)  + 2 x (y + 1)  + (y + 1)

(%i4) expr:(x+1)^-2*(y+1)^3;
                                          3
                                   (y + 1)
(%o4)                              --------
                                          2
                                   (x + 1)
(%i5) expand(expr);
                 3               2
                y             3 y            3 y             1
(%o5)      ------------ + ------------ + ------------ + ------------
            2              2              2              2
           x  + 2 x + 1   x  + 2 x + 1   x  + 2 x + 1   x  + 2 x + 1

(%i6) expand(expr,2,2);
                                          3
                                   (y + 1)
(%o6)                            ------------
                                  2
                                 x  + 2 x + 1
</pre></div>

<p>Vuelve a simplificar una expresión pero sin expansión:
</p>
<div class="example">
<pre class="example">(%i7) expr:(1+x)^2*sin(x);
                                       2
(%o7)                           (x + 1)  sin(x)
(%i8) exponentialize:true;
(%o8)                                true
(%i9) expand(expr,0,0);
                                   2    %i x     - %i x
                         %i (x + 1)  (%e     - %e      )
(%o9)                  - -------------------------------
                                        2
</pre></div>
</dd></dl>



<a name="Item_003a-Simplification_002ees_002fdeffn_002fexpandwrt"></a><dl>
<dt><a name="index-expandwrt"></a>Función: <strong>expandwrt</strong> <em>(<var>expr</var>, <var>x_1</var>, ..., <var>x_n</var>)</em></dt>
<dd><p>Expande la expresión <code>expr</code> con respecto a las variables <var>x_1</var>, ..., <var>x_n</var>.
Todos los productos que contengan a las variables aparecen explícitamente. El resultado que se obtenga no tendr&rsquo;a productos de sumas de expresiones que contengan a las variables. Los argumentos  <var>x_1</var>, ..., <var>x_n</var>
pueden ser variables, operadores o expresiones.
</p>
<p>Por defecto, no se expanden los denominadores, pero esto puede cambiarse mediante el uso de la variable <code>expandwrt_denom</code>.
</p>
<p>Esta función se carga automáticamente de <samp>simplification/stopex.mac</samp>.
</p>
</dd></dl>


<a name="Item_003a-Simplification_002ees_002fdefvr_002fexpandwrt_005fdenom"></a><dl>
<dt><a name="index-expandwrt_005fdenom"></a>Variable opcional: <strong>expandwrt_denom</strong></dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>La variable <code>expandwrt_denom</code> controla el tratamiento de las expresiones racinales por parte de <code>expandwrt</code>. Si vale <code>true</code>, se expandirán tanto el numerador como el denominador de la expresión respecto de los argumentos de <code>expandwrt</code>, pero si <code>expandwrt_denom</code> vale <code>false</code>, sólo se expandirá el numerador.
</p>
</dd></dl>


<a name="Item_003a-Simplification_002ees_002fdeffn_002fexpandwrt_005ffactored"></a><dl>
<dt><a name="index-expandwrt_005ffactored"></a>Función: <strong>expandwrt_factored</strong> <em>(<var>expr</var>, <var>x_1</var>, ..., <var>x_n</var>)</em></dt>
<dd><p>Es similar a <code>expandwrt</code>, pero trata a las expresiones que son productos de una forma algo diferente. La función
<code>expandwrt_factored</code> expande sólo aquellos factores de <code>expr</code> que contienen a las variables <var>x_1</var>, ..., <var>x_n</var>.
</p>
<p>Esta función se carga automáticamente de <samp>simplification/stopex.mac</samp>.
</p>
</dd></dl>


<a name="Item_003a-Simplification_002ees_002fdefvr_002fexpon"></a><dl>
<dt><a name="index-expon"></a>Variable opcional: <strong>expon</strong></dt>
<dd><p>Valor por defecto: 0
</p>
<p>La variable <code>expon</code> guarda el mayor exponente negativo que será expandido automáticamente, independientemente de <code>expand</code>. Por ejemplo, si <code>expon</code> vale 4 entonces <code>(x+1)^(-5)</code> no se expandirá automáticamente.
</p>
</dd></dl>



<a name="Item_003a-Simplification_002ees_002fdeffn_002fexponentialize"></a><dl>
<dt><a name="index-exponentialize"></a>Función: <strong>exponentialize</strong> <em>(<var>expr</var>)</em></dt>
<dt><a name="index-exponentialize-1"></a>Variable opcional: <strong>exponentialize</strong></dt>
<dd>
<p>La función <code>exponentialize (expr)</code> convierte las funciones trigonométricas e hiperbólicas de <var>expr</var> a exponenciales, sin alterar la variable global <code>exponentialize</code>.
</p>
<p>Cuando la variable <code>exponentialize</code> vale <code>true</code>, todas las funciones trigonométricas e hiperbólicas se convierten a forma exponencial. El valor por defecto es <code>false</code>.
</p>
<p>La función <code>demoivre</code> convierte funciones trigonométricas e hiperbólicas a la forma exponencial, por lo que  <code>demoivre</code> y <code>exponentialize</code> no pueden valer <code>true</code> al mismo tiempo.
</p>
</dd></dl>



<a name="Item_003a-Simplification_002ees_002fdefvr_002fexpop"></a><dl>
<dt><a name="index-expop"></a>Variable opcional: <strong>expop</strong></dt>
<dd><p>Valor por defecto: 0
</p>
<p>La variable <code>expop</code> guarda el mayor exponente positivo que será expandido automáticamente.  Así, <code>(x+1)^3</code> se expandirá automáticamente sólo si <code>expop</code> es mayor o igual que 3. Si se quiere expandir <code>(x+1)^n</code>, siendo <code>n</code> mayor que <code>expop</code>, entonces <code>expand ((x+1)^n)</code> se desarrollará sólo si <code>maxposex</code> no es menor que <code>n</code>.
</p>
</dd></dl>


<a name="Item_003a-Simplification_002ees_002fdefvr_002flassociative"></a><dl>
<dt><a name="index-lassociative"></a>Propiedad: <strong>lassociative</strong></dt>
<dd><p>La instrucción <code>declare (g, lassociative)</code> le indica al simplificador de Maxima que <code>g</code> es asociativo por la izquierda.  Por ejemplo, <code>g (g (a, b), g (c, d))</code>se reduce a <code>g (g (g (a, b), c), d)</code>.
</p>
</dd></dl>


<a name="Item_003a-Simplification_002ees_002fdefvr_002flinear"></a><dl>
<dt><a name="index-linear-1"></a>Propiedad: <strong>linear</strong></dt>
<dd><p>Es una de las propiedades de operadores de Maxima. Si la función 
univariante <code>f</code> se declara lineal, la expansión de  <code>f(x + y)</code> 
produce <code>f(x) + f(y)</code>, <code>f(a*x)</code> produce <code>a*f(x)</code> si <code>a</code> 
es una constante.  Si la función tiene dos o más argumentos, la linealidad 
se interpreta como la de <code>sum</code> o <code>integrate</code>, esto es, 
<code>f (a*x + b, x)</code> produce <code>a*f(x,x) + b*f(1,x)</code> si <code>a</code> y <code>b</code> 
no contienen a <code>x</code>.
</p>
<p><code>linear</code> equivale a <code>additive</code> y <code>outative</code>.
Véase también <code>opproperties</code>.
</p>
<p>Ejemplo:
</p>
<div class="example">
<pre class="example">(%i1) 'sum (F(k) + G(k), k, 1, inf);
                       inf
                       ====
                       \
(%o1)                   &gt;    (G(k) + F(k))
                       /
                       ====
                       k = 1
(%i2) declare (nounify (sum), linear);
(%o2)                         done
(%i3) 'sum (F(k) + G(k), k, 1, inf);
</pre><pre class="example">                     inf          inf
                     ====         ====
                     \            \
(%o3)                 &gt;    G(k) +  &gt;    F(k)
                     /            /
                     ====         ====
                     k = 1        k = 1
</pre></div>
</dd></dl>


<a name="Item_003a-Simplification_002ees_002fdefvr_002fmaxnegex"></a><dl>
<dt><a name="index-maxnegex"></a>Variable opcional: <strong>maxnegex</strong></dt>
<dd><p>Valor por defecto: 1000
</p>
<p>La variable <code>maxnegex</code> es el mayor exponente negativo que expandirá la función <code>expand</code>. Véase también <code>maxposex</code>.
</p>
</dd></dl>



<a name="Item_003a-Simplification_002ees_002fdefvr_002fmaxposex"></a><dl>
<dt><a name="index-maxposex"></a>Variable opcional: <strong>maxposex</strong></dt>
<dd><p>Valor por defecto: 1000
</p>
<p>La variable <code>maxposex</code> es el mayor exponenteque expandirá la función <code>expand</code>. Véase también <code>maxnegex</code>.
</p>
</dd></dl>



<a name="Item_003a-Simplification_002ees_002fdefvr_002fmultiplicative"></a><dl>
<dt><a name="index-multiplicative"></a>Propiedad: <strong>multiplicative</strong></dt>
<dd><p>La instrucción <code>declare (f, multiplicative)</code> indica al simplificador de Maxima que <code>f</code> is multiplicativa.
</p>
<ol>
<li> Si <code>f</code> es univariante, cada vez que el simplificador encuentre a <code>f</code> aplicad a un producto, <code>f</code> se distribuirá sobre ese producto.  Por ejemplo, <code>f(x*y)</code> se reduciría a <code>f(x)*f(y)</code>.
</li><li> Si <code>f</code> es una función de 2 o más argumentos, la multiplicabilidad se define como multiplicabilidad para el primer argumento de <code>f</code>, de modo que <code>f (g(x) * h(x), x)</code> se reduciría a <code>f (g(x) ,x) * f (h(x), x)</code>.
</li></ol>

<p>Esta transformación no se realiza cuando <code>f</code> se aplica a expresiones de la forma <code>product (x[i], i, m, n)</code>.
</p>
<p>Ejemplo:
</p>
<div class="example">
<pre class="example">(%i1) F2 (a * b * c);
(%o1)                       F2(a b c)
(%i2) declare (F2, multiplicative);
(%o2)                         done
(%i3) F2 (a * b * c);
(%o3)                   F2(a) F2(b) F2(c)
</pre></div>
</dd></dl>




<a name="Item_003a-Simplification_002ees_002fdeffn_002fmultthru"></a><dl>
<dt><a name="index-multthru"></a>Función: <strong>multthru</strong> <em>(<var>expr</var>)</em></dt>
<dt><a name="index-multthru-1"></a>Función: <strong>multthru</strong> <em>(<var>expr_1</var>, <var>expr_2</var>)</em></dt>
<dd><p>Multiplica un factor (que debería ser una suma) de <var>expr</var> por los otros factores de <var>expr</var>.  Esto es, <var>expr</var> es <code><var>f_1</var> <var>f_2</var> ... <var>f_n</var></code>, donde al menos un factor, por ejemplo <var>f_i</var>, es una suma de términos.  Cada término en esta suma se multiplica por los otros factores del producto, excepto el propio <var>f_i</var>. La función  <code>multthru</code> no expande sumas elevadas a exponentes, siendo el método más rápido para distribuir productos (sean o no conmutativos) sobre sumas. Puesto que los cocientes se representan como productos, puede utilizarse<code>multthru</code> para dividir sumas entre productos.
</p>
<p>La llamada <code>multthru (<var>expr_1</var>, <var>expr_2</var>)</code> multiplica cada término de <var>expr_2</var> (que debería ser una suma o una ecuación) por <var>expr_1</var>.  Si <var>expr_1</var> no es ella misma una suma, entonces la llamada es equivalente a <code>multthru (<var>expr_1</var>*<var>expr_2</var>)</code>.
</p>
<div class="example">
<pre class="example">(%i1) x/(x-y)^2 - 1/(x-y) - f(x)/(x-y)^3;
                      1        x         f(x)
(%o1)             - ----- + -------- - --------
                    x - y          2          3
                            (x - y)    (x - y)
(%i2) multthru ((x-y)^3, %);
                           2
(%o2)             - (x - y)  + x (x - y) - f(x)
(%i3) ratexpand (%);
                           2
(%o3)                   - y  + x y - f(x)
(%i4) ((a+b)^10*s^2 + 2*a*b*s + (a*b)^2)/(a*b*s^2);
                        10  2              2  2
                 (b + a)   s  + 2 a b s + a  b
(%o4)            ------------------------------
                                  2
                             a b s
(%i5) multthru (%);  /* note that this does not expand (b+a)^10 */
                                        10
                       2   a b   (b + a)
(%o5)                  - + --- + ---------
                       s    2       a b
                           s
(%i6) multthru (a.(b+c.(d+e)+f));
(%o6)            a . f + a . c . (e + d) + a . b
(%i7) expand (a.(b+c.(d+e)+f));
(%o7)         a . f + a . c . e + a . c . d + a . b
</pre></div>

</dd></dl>


<a name="Item_003a-Simplification_002ees_002fdefvr_002fnary"></a><dl>
<dt><a name="index-nary-2"></a>Propiedad: <strong>nary</strong></dt>
<dd>
<p><code>declare(f, nary)</code> le indica a Maxima que reconozca la función <code>f</code>
como n-aria.
</p>
<p>La declaración <code>nary</code> no equivale a invocar la función 
<code>function_nary, nary</code>. El único efecto de <code>declare(f, nary)</code> 
es indicar al simplificador de Maxima que aplane expresiones anidadas,
como simplificar <code>foo(x, foo(y, z))</code> a <code>foo(x, y, z)</code>.
Véase también <code>declare</code>.
</p>
<p>Ejemplo:
</p>
<div class="example">
<pre class="example">(%i1) H (H (a, b), H (c, H (d, e)));
(%o1)               H(H(a, b), H(c, H(d, e)))
(%i2) declare (H, nary);
(%o2)                         done
(%i3) H (H (a, b), H (c, H (d, e)));
(%o3)                   H(a, b, c, d, e)
</pre></div>
</dd></dl>



<a name="Item_003a-Simplification_002ees_002fdefvr_002fnegdistrib"></a><dl>
<dt><a name="index-negdistrib"></a>Variable opcional: <strong>negdistrib</strong></dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>negdistrib</code> vale <code>true</code>, -1 se distribuye sobre una expresión.  Por ejemplo, <code>-(x + y)</code> se transforma en <code>- y - x</code>.  Dándole el valor <code>false</code> se mostrará <code>- (x + y)</code> tal cual. Esto puede ser útil, pero también peligroso; al igual que el indicador <code>simp</code>, no conviene asignarle el valor <code>false</code>.
</p>
</dd></dl>


<a name="Item_003a-Simplification_002ees_002fdefvr_002fopproperties"></a><dl>
<dt><a name="index-opproperties"></a>Variable del sistema: <strong>opproperties</strong></dt>
<dd>
<p>La variable <code>opproperties</code> es la lista con las propiedades especiales de los operadores reconocidas por el simplificador de Maxima:
<code>linear</code>, <code>additive</code>, <code>multiplicative</code>, <code>outative</code>, <code>evenfun</code>,
<code>oddfun</code>, <code>commutative</code>, <code>symmetric</code>, <code>antisymmetric</code>, <code>nary</code>, 
<code>lassociative</code>, <code>rassociative</code>.
</p>
</dd></dl>



<a name="Item_003a-Simplification_002ees_002fdefvr_002foutative"></a><dl>
<dt><a name="index-outative"></a>Propiedad: <strong>outative</strong></dt>
<dd><p>La instrucción <code>declare (f, outative)</code> le indica al simplificador de Maxima 
que los factores constantes del argumento de la función <code>f</code> pueden ser 
extraídos.
</p>
<ol>
<li> Si <code>f</code> es univariante, cada vez que el simplificador se encuentra con <code>f</code> 
aplicada a un producto, éste será particionado en factores que son constantes y 
factores que no lo son, siendo entonces los constantes extraídos de la 
función.  Por ejemplo, <code>f(a*x)</code> se reducirá a <code>a*f(x)</code> siendo <code>a</code> 
una constante. Las constantes no atómicas no serán extraídas.
</li><li> Si <code>f</code> es una función de 2 o más argumentos, esta propiedad se define como 
en  <code>sum</code> o <code>integrate</code>, esto es, <code>f (a*g(x), x)</code> se reducirá a 
<code>a * f(g(x), x)</code> si <code>a</code> no contiene a <code>x</code>.
</li></ol>

<p>Las funciones <code>sum</code>, <code>integrate</code> y <code>limit</code> han sido todas declaradas 
con la propiedad <code>outative</code>.
</p>
<p>Ejemplo:
</p>
<div class="example">
<pre class="example">(%i1) F1 (100 * x);
(%o1)                       F1(100 x)
(%i2) declare (F1, outative);
(%o2)                         done
(%i3) F1 (100 * x);
(%o3)                       100 F1(x)
(%i4) declare (zz, constant);
(%o4)                         done
(%i5) F1 (zz * y);
(%o5)                       zz F1(y)
</pre></div>
</dd></dl>



<a name="Item_003a-Simplification_002ees_002fdeffn_002fradcan"></a><dl>
<dt><a name="index-radcan"></a>Función: <strong>radcan</strong> <em>(<var>expr</var>)</em></dt>
<dd><p>Simplifica la expresión <var>expr</var>, que puede contener logaritmos, exponenciales y
radicales, convirtiéndola a una forma canónica, lo que significa que todas las expresiones funcionalmente equivalentes
se reducen a una forma única.  Ciertas expresiones, sin embargo, son reducidas por <code>radcan</code> a una forma regular, lo que significa que dos expresiones equivalentes no tienen necesariamente el mismo aspecto, pero su diferencia puede ser reducida por <code>radcan</code> a cero.
</p>
<p>Con algunas expresiones <code>radcan</code> puede consunir mucho tiempo. Este es el coste por explorar ciertas relaciones entre las componentes de la expresión para simplificaciones basadas en factorizaciones y expansiones parciales de fracciones de exponentes.  
</p>
<p>Ejemplos:
</p>
<div class="example">
<pre class="example">(%i1) radcan((log(x+x^2)-log(x))^a/log(1+x)^(a/2));
                                           a/2
(%o1)                            log(x + 1)

(%i2) radcan((log(1+2*a^x+a^(2*x))/log(1+a^x)));
(%o2)                                  2

(%i3) radcan((%e^x-1)/(1+%e^(x/2)));
                                     x/2
(%o3)                              %e    - 1
</pre></div>

</dd></dl>



<a name="Item_003a-Simplification_002ees_002fdefvr_002fradexpand"></a><dl>
<dt><a name="index-radexpand"></a>Variable opcional: <strong>radexpand</strong></dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>La variable <code>radexpand</code> controla algunas simplificaciones de radicales.
</p>
<p>Si <code>radexpand</code> vale <code>all</code>, las raíces <var>n</var>-ésimas de los factores de un producto que sean potencias de <var>n</var> se extraen del símbolo radical. Por ejemplo, si <code>radexpand</code> vale <code>all</code>, <code>sqrt (16*x^2)</code> se reduce a <code>4*x</code>.
</p>
<p>Más concretamente, considérese <code>sqrt (x^2)</code>.
</p><ul>
<li> Si <code>radexpand</code> vale <code>all</code> o se ha ejecutado <code>assume (x &gt; 0)</code>, 
<code>sqrt(x^2)</code> se reduce a <code>x</code>.
</li><li> Si <code>radexpand</code> vale <code>true</code> y <code>domain</code> es <code>real</code> (su valor por defecto), 
<code>sqrt(x^2)</code> se reduce a <code>abs(x)</code>.
</li><li> Si <code>radexpand</code> vale <code>false</code> o <code>radexpand</code> vale <code>true</code> y <code>domain</code> es <code>complex</code>, 
<code>sqrt(x^2)</code> no se simplifica.
</li></ul>

<p>Nótese que  <code>domain</code> sólo se tiene en cuenta si <code>radexpand</code> vale <code>true</code>.
</p>
</dd></dl>



<a name="Item_003a-Simplification_002ees_002fdefvr_002frassociative"></a><dl>
<dt><a name="index-rassociative"></a>Propiedad: <strong>rassociative</strong></dt>
<dd><p>La instrucción <code>declare (g, rassociative)</code> le indica al simplificador de Maxima que <code>g</code> es asociativa por la derecha.  Por ejemplo, <code>g(g(a, b), g(c, d))</code> se reduce a <code>g(a, g(b, g(c, d)))</code>.
</p>
</dd></dl>


<a name="Item_003a-Simplification_002ees_002fdeffn_002fscsimp"></a><dl>
<dt><a name="index-scsimp"></a>Función: <strong>scsimp</strong> <em>(<var>expr</var>, <var>rule_1</var>, ..., <var>rule_n</var>)</em></dt>
<dd><p>Es el &quot;Sequential Comparative Simplification&quot; (método debido a Stoute).
La función <code>scsimp</code> intenta simplificar <var>expr</var> de acuerdo con las reglas <var>rule_1</var>, ..., <var>rule_n</var>.
Si se obtiene una expresión más pequeña, el proceso se repite. En caso contrario, después de que se hayan intentado todas las simplificaciones, devuelve la respuesta original.
</p>
<p>La instrucción <code>example (scsimp)</code> muestra algunos ejemplos.
</p>
</dd></dl>



<a name="Item_003a-Simplification_002ees_002fdefvr_002fsimp"></a><dl>
<dt><a name="index-simp"></a>Variable opcional: <strong>simp</strong></dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>La variable <code>simp</code> activa y desactiva la simplificación.
La simplificación está activada por defecto. La variable <code>simp</code>
también es reconocida por la función <code>ev</code> como variable de entorno.
Véase también <code>ev</code>.
</p>
<p>Cuando <code>simp</code> se utiliza en un entorno <code>ev</code> con el valor <code>false</code>,
la simplificación se evita sólo durante la fase de evaluación de una
expresión. La variable no evita la simplificación que sigue a la fase de
evaluación.
</p>
<p>Ejemplos:
</p>
<p>La simplificación se suspende globalmente. La expresión <code>sin(1.0)</code>
no se simplifica a su valor numérico. La variable de entorno <code>simp</code>
conmuta el estado de la simplificación.
</p>
<div class="example">
<pre class="example">(%i1) simp:false;
(%o1)                                false
(%i2) sin(1.0);
(%o2)                              sin(1.0)
(%i3) sin(1.0),simp;
(%o3)                          .8414709848078965
</pre></div>

<p>La simplificación se vuelve a activar. La variable de entorno <code>simp</code>
no puede suprimir totalmente la simplificación. El resultado muestra una
expresión simplificada, pero la variable <code>x</code> guarda como valor una
expresión sin simplificar, porque la asignación se realizó durante 
la fase de evaluación de la expresión.
</p>
<div class="example">
<pre class="example">(%i4) simp:true;
(%o4)                                true
(%i5) x:sin(1.0),simp:false;
(%o5)                          .8414709848078965
(%i6) :lisp $X
((%SIN) 1.0)
</pre></div>
</dd></dl>



<a name="Item_003a-Simplification_002ees_002fdefvr_002fsymmetric"></a><dl>
<dt><a name="index-symmetric"></a>Propiedad: <strong>symmetric</strong></dt>
<dd><p>La instrucción <code>declare (h, symmetric)</code> le indica al simplificador de  Maxima que <code>h</code> es una función simétrica.  Por ejemplo, <code>h (x, z, y)</code>  se reduce a <code>h (x, y, z)</code>.
</p>
<p>El nombre <code>commutative</code> es sinónimo de <code>symmetric</code>.
</p>
</dd></dl>



<a name="Item_003a-Simplification_002ees_002fdeffn_002fxthru"></a><dl>
<dt><a name="index-xthru"></a>Función: <strong>xthru</strong> <em>(<var>expr</var>)</em></dt>
<dd><p>Combina todos los términos de <var>expr</var> (la cual debe ser una suma) sobre un común denominador sin expandir productos ni sumas elevadas a exponentes al modo que lo hace <code>ratsimp</code>. La función <code>xthru</code> cancela factores comunes en el numerador y denominador de expresiones racionales, pero sólo si los factores son explícitos.
</p>
<p>En ocasiones puede ser útil el uso de <code>xthru</code> antes de la llamada a <code>ratsimp</code> a fin de cancelar factores explícitos del máximo común divisor del numerador y denominador y así simplificar la expresión a la que se va a aplicar <code>ratsimp</code>.
</p>
<div class="example">
<pre class="example">(%i1) ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
 xthru (%);
                                20
                 1       (x + 2)   - 2 y       x
(%o1)        --------- + --------------- - ---------
                    19             20             20
             (y + x)        (y + x)        (y + x)
</pre></div>

</dd></dl>



<hr>
<div class="header">
<p>
Previous: <a href="maxima_46.html#Introducci_00f3n-a-la-simplificaci_00f3n" accesskey="p" rel="previous">Introducción a la simplificación</a>, Subir: <a href="maxima_45.html#Simplificaci_00f3n" accesskey="u" rel="up">Simplificación</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="&Iacute;ndice general" rel="contents">&Iacute;ndice general</a>][<a href="maxima_304.html#g_t_00cdndice-de-Funciones-y-Variables" title="&Iacute;ndice" rel="index">&Iacute;ndice</a>]</p>
</div>



</body>
</html>
