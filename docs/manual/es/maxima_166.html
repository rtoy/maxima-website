<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Funciones y variables para la programación (Manual de Maxima 5.47.0)</title>

<meta name="description" content="Funciones y variables para la programación (Manual de Maxima 5.47.0)">
<meta name="keywords" content="Funciones y variables para la programación (Manual de Maxima 5.47.0)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="maxima_toc.html" rel="start" title="Top">
<link href="maxima_304.html" rel="index" title="Índice de Funciones y Variables">
<link href="maxima_toc.html#SEC_Contents" rel="contents" title="Índice general">
<link href="maxima_162.html" rel="up" title="Programación">
<link href="maxima_165.html" rel="prev" title="Introducción a la programación">
<style type="text/css">
<!--
a.copiable-anchor {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
span:hover a.copiable-anchor {visibility: visible}
ul.no-bullet {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 1em; padding-bottom: 1em;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%; display: block; margin-left: auto; margin-right: auto}

-->
</style>

<link rel="icon" href="figures/favicon.ico">
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6>"></script>
<script type='text/javascript'>
MathJax = {
  options: {
    skipHtmlTags: {'[-]': ['pre']},
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
};
</script><script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>
</head>

<body lang="es" class="tex2jax_ignore">
<div class="section" id="Funciones-y-variables-para-la-programaci_00f3n">
<div class="header">
<p>
Anterior: <a href="maxima_165.html" accesskey="p" rel="prev">Introducción a la programación</a>, Subir: <a href="maxima_162.html" accesskey="u" rel="up">Programación</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Índice general" rel="contents">Índice general</a>][<a href="maxima_304.html" title="Índice" rel="index">Índice</a>]</p>
</div>
<span id="Funciones-y-variables-para-la-programacion"></span><h3 class="section">37.4 Funciones y variables para la programación</h3>

<span id="Item_003a-Program_002ees_002fdeffn_002fbacktrace"></span><dl class="def">
<dt id="index-backtrace"><span class="category">Función: </span><span><strong>backtrace</strong> <em>()</em><a href='#index-backtrace' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-backtrace-1"><span class="category">Función: </span><span><strong>backtrace</strong> <em>(<var>n</var>)</em><a href='#index-backtrace-1' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Devuelve la pila de llamadas, esto es, la lista de funciones que han llamado a la función actualmente activa.
</p>
<p>La llamada a <code>backtrace()</code> devuelve la pila completa de llamadas.
</p>
<p>Ejemplos:
</p>
<div class="example">
<pre class="example">(%i1) h(x) := g(x/7)$
(%i2) g(x) := f(x-11)$
(%i3) f(x) := e(x^2)$
(%i4) e(x) := (backtrace(), 2*x + 13)$
(%i5) h(10);
#0: e(x=4489/49)
#1: f(x=-67/7)
#2: g(x=10/7)
#3: h(x=10)
                              9615
(%o5)                         ----
                               49
</pre></div>

<p>La llamada <code>backtrace (<var>n</var>)</code> devuelve las <var>n</var> funciones más recientes, incluyendo a la función actualmente activa.
</p>
<p>Ejemplos:
</p>
<div class="example">
<pre class="example">(%i1) h(x) := (backtrace(1), g(x/7))$
(%i2) g(x) := (backtrace(1), f(x-11))$
(%i3) f(x) := (backtrace(1), e(x^2))$
(%i4) e(x) := (backtrace(1), 2*x + 13)$
(%i5) h(10);
#0: h(x=10)
#0: g(x=10/7)
#0: f(x=-67/7)
#0: e(x=4489/49)
                              9615
(%o5)                         ----
                               49
</pre></div>

</dd></dl>

<span id="Item_003a-Program_002ees_002fdeffn_002fdo"></span><dl class="def">
<dt id="index-do"><span class="category">Operador especial: </span><span><strong>do</strong><a href='#index-do' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>La sentencia <code>do</code> se utiliza para realizar iteraciones.  Debido a su generalidad la sentencia <code>do</code> se describirá en dos partes. En primer lugar se mostrará su forma más usual, análoga a la de otros lenguajes de programación (Fortran, Algol, PL/I, etc.); después se mencionarán otras formas de uso.
</p>
<p>Hay tres variantes de esta sentencia que se diferencian entre sí únicamente por las condiciones de fin de bucle. Son las siguientes:
</p>
<ul>
<li> <code>for <var>variable</var>: <var>valor_inicial</var> step <var>incremento</var>
      thru <var>límite</var> do <var>cuerpo</var></code>
</li><li> <code>for <var>variable</var>: <var>valor_inicial</var> step <var>incremento</var>
      while <var>condición</var> do <var>cuerpo</var></code>
</li><li> <code>for <var>variable</var>: <var>valor_inicial</var> step <var>incremento</var>
      unless <var>condición</var> do <var>cuerpo</var></code>
</li></ul>

<p>El <var>valor_inicial</var>, el <var>incremento</var>, el <var>límite</var> y el <var>cuerpo</var> pueden ser cualquier tipo de expresión válida de Maxima. Si el incremento es igual a la unidad (1) entonces &quot;<code>step 1</code>&quot; puede omitirse.
</p>
<p>La ejecución de la sentencia <code>do</code> se realiza asignando el valor_inicial a la variable (llamada de aquí en adelante variable-control). A continuación: (1) si la variable-control ha excedido el límite de la especificación dada por un <code>thru</code>, o si la condición impuesta por <code>unless</code> es verdadera (<code>true</code>), o si la condición dada por <code>while</code> es falsa (<code>false</code>) entonces la iteración <code>do</code> termina. (2) El cuerpo se evalúa.  (3) El incremento es sumado a la variable-control. El proceso de (1) a (3) se repite hasta que la condición de fin de iteración se satisfaga. También es posible especificar varias condiciones de terminación del bucle, en cuyo caso <code>do</code> terminará cuando se satisfaga alguna de ellas.
</p>
<p>En general la condición <code>thru</code> se satisfará cuando la variable-control sea mayor que el límite si el incremento es no negativo, o cuando la variable-control sea menor que el límite cuando el incremento es negativo. El incremento y el límite pueden ser expresiones no numéricas, tanto en cuanto esta desigualdad pueda quedar determinada. Sin embargo, a menos que el incremento sea un número negativo en el momento de comenzar el cómputo de <code>do</code>, Maxima supondrá que se evaluará a una cantidad positiva. En caso de no ser efectivamente positivo, la sentencia <code>do</code> puede dar un resultado inesperado.
</p>
<p>Nótese que el límite, el incremento y la condición de terminación se evalúan en cada iteración del bucle. Así, si alguna de expresiones necesitan de muchos cálculos y devuelven un resultado que no va a cambiar durante toda la ejecución del cuerpo, será más eficiente dar este valor a una variable antes de comenzar la sentencia <code>do</code> y utilizarla luego durante su ejecución.
</p>
<p>El valor que habitualmente devuelva la sentencia <code>do</code> será el átomo <code>done</code>. Sin embargo, la función <code>return</code> puede usarse dentro del cuerpo para salir de <code>do</code> de forma prematura retornando un valor determinado.
Nótese no obstante que un <code>return</code> dentro de un <code>do</code> que está dentro de un bloque (<code>block</code>) provocará una salida de <code>do</code> pero no de <code>block</code>. Repárese también en que la función <code>go</code> no puede usarse para salir de <code>do</code> e ir a algún lugar de <code>block</code>.
</p>
<p>La variable-control es siempre local respecto de <code>do</code>, por lo que se puede utilizar cualquier nombre de variable sin afectar el valor de cualquier otra variable externa a <code>do</code> y que tenga el mismo nombre. La variable-control no tendrá asignado ningún valor una vez se haya concluido el <code>do</code>.
</p>
<div class="example">
<pre class="example">(%i1) for a:-3 thru 26 step 7 do display(a)$
                             a = - 3

                              a = 4

                             a = 11

                             a = 18

                             a = 25
</pre></div>

<div class="example">
<pre class="example">(%i1) s: 0$
(%i2) for i: 1 while i &lt;= 10 do s: s+i;
(%o2)                         done
(%i3) s;
(%o3)                          55
</pre></div>


<p>Nótese que la condición <code>while i &lt;= 10</code> es equivalente a <code>unless i &gt; 10</code> y a <code>thru 10</code>.
</p>
<div class="example">
<pre class="example">(%i1) series: 1$
(%i2) term: exp (sin (x))$
(%i3) for p: 1 unless p &gt; 7 do
          (term: diff (term, x)/p, 
           series: series + subst (x=0, term)*x^p)$
(%i4) series;
                  7    6     5    4    2
                 x    x     x    x    x
(%o4)            -- - --- - -- - -- + -- + x + 1
                 90   240   15   8    2
</pre></div>

<p>lo que da ocho términos del desarrollo de Taylor de la función <code>e^sin(x)</code>.
</p>
<div class="example">
<pre class="example">(%i1) poly: 0$
(%i2) for i: 1 thru 5 do
          for j: i step -1 thru 1 do
              poly: poly + i*x^j$
(%i3) poly;
                  5      4       3       2
(%o3)          5 x  + 9 x  + 12 x  + 14 x  + 15 x
(%i4) guess: -3.0$
(%i5) for i: 1 thru 10 do
          (guess: subst (guess, x, 0.5*(x + 10/x)),
           if abs (guess^2 - 10) &lt; 0.00005 then return (guess));
(%o5)                  - 3.162280701754386
</pre></div>

<p>Este ejemplo calcula la raíz cuadrada negativa de 10 haciendo 10 iteraciones del método de Newton-Raphson. De no haberse alcanzado el criterio de convergencia el valor devuelto hubiese sido <code>done</code>.
</p>
<p>En lugar de añadir siempre una cantidad a la variable-control a veces se puede querer que cambie en cada iteración siguiendo algún otro criterio. En tal caso se puede hacer uso de <code>next <var>expresión</var></code> en lugar de <code>step <var>incremento</var></code>. Esto hará que a la variable-control se le asigne el resultado de evaluar la expresión en cada iteración del bucle.
</p>
<div class="example">
<pre class="example">(%i6) for count: 2 next 3*count thru 20 do display (count)$
                            count = 2

                            count = 6

                           count = 18
</pre></div>

<p>En ocasiones puede interesar realizar una iteración en la que la variable-control no se utilice nunca. Se podrá entonces dar únicamente las condiciones de terminación del bucle omitiendo la inicialización y actualizando la información, tal como se hace en el siguiente ejemplo para calcular la raíz cuadrada de 5 utilizando un valor inicial alejado de la solución.
</p>
<div class="example">
<pre class="example">(%i1) x: 1000$
(%i2) thru 20 do x: 0.5*(x + 5.0/x)$
(%i3) x;
(%o3)                   2.23606797749979
(%i4) sqrt(5), numer;
(%o4)                   2.23606797749979
</pre></div>

<p>Si así se quiere, incluso es posible omitir las condiciones de terminación completamente y escribir únicamente <code>do <var>body</var></code>, lo que provocará entrar en un bucle infinito. En tal caso, debería usarse la función <code>return</code> a fin de terminar con la ejecución de <code>do</code>.
</p>
<div class="example">
<pre class="example">(%i1) newton (f, x):= ([y, df, dfx], df: diff (f ('x), 'x),
          do (y: ev(df), x: x - f(x)/y, 
              if abs (f (x)) &lt; 5e-6 then return (x)))$
(%i2) sqr (x) := x^2 - 5.0$
(%i3) newton (sqr, 1000);
(%o3)                   2.236068027062195
</pre></div>

<p>(En este ejemplo, cuando se ejecuta <code>return</code> obliga a que sea <code>x</code> el valor devuelto por <code>do</code>. Al salirse del bloque, <code>x</code> es también el valor que devuelve <code>block</code> por ser <code>do</code> la última sentencia del bloque.)
</p>
<p>Hay todavía otra forma de <code>do</code> en Maxima. Su sintaxis es:
</p>
<div class="example">
<pre class="example">for <var>variable</var> in <var>lista</var> <var>test_de_parada</var> do <var>cuerpo</var>
</pre></div>

<p>Los elementos de <var>list</var> son cualesquiera expresiones que se irán asignando sucesivamente a la variable en cada repetición del cuerpo. El test de parada <var>end_tests</var> (que es opcional) puede usarse para terminar la ejecución de <code>do</code>; de otro modo las iteraciones se pararán cuando la lista se haya agotado o cuando se ejecute un <code>return</code> dentro del cuerpo.  (De hecho, la lista puede ser cualquier expresión no atómica, de la cual se irán extrayendo de forma sucesiva sus diferentes partes.)
</p>
<div class="example">
<pre class="example">(%i1)  for f in [log, rho, atan] do ldisp(f(1))$
(%t1)                                  0
(%t2)                                rho(1)
                                     %pi
(%t3)                                 ---
                                      4
(%i4) ev(%t3,numer);
(%o4)                             0.78539816
</pre></div>

</dd></dl>



<span id="Item_003a-Program_002ees_002fdeffn_002ferrcatch"></span><dl class="def">
<dt id="index-errcatch"><span class="category">Función: </span><span><strong>errcatch</strong> <em>(<var>expr_1</var>, ..., <var>expr_n</var>)</em><a href='#index-errcatch' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Evalúa las expresiones <var>expr_1</var>, ..., <var>expr_n</var> una a una y devuelve <code>[<var>expr_n</var>]</code> (una lista) en caso de que no ocurra ningún error. En caso de aparecer algún error durante el cálculo de alguno de los argumentos, <code>errcatch</code> evita que el error se propague y devuelve la lista vacía <code>[]</code> sin evaluar más argumentos.
</p>
<p>La función <code>errcatch</code> es útil en ficheros <code>batch</code> donde se sospeche que pueda aparecer algún error, el cual provocaría la terminación de la ejecución del <code>batch</code> de no ser previamente detectado.
</p>
</dd></dl>

<span id="Item_003a-Program_002ees_002fdeffn_002ferror"></span><dl class="def">
<dt id="index-error"><span class="category">Función: </span><span><strong>error</strong> <em>(<var>expr_1</var>, ..., <var>expr_n</var>)</em><a href='#index-error' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-error-1"><span class="category">Variable del sistema: </span><span><strong>error</strong><a href='#index-error-1' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Calcula y devuelve <var>expr_1</var>, ..., <var>expr_n</var>, enviando posteriormente una seãl de error a Maxima o al <code>errcatch</code> más cercano. 
</p>
<p>A la variable <code>error</code> se le asigna una lista con la descripción del error. El primer elemento de <code>error</code> es una cadena de formato, la cual une todas las cadenas de los argumentos <var>expr_1</var>, ..., <var>expr_n</var>, siendo los demás elementos de la lista los valores de los argumentos que no son cadenas.
</p>
<p>La llamada a <code>errormsg()</code> formatea e imprime <code>error</code>. Se reimprime así el mensaje de error más reciente.
</p>
</dd></dl>



<span id="Item_003a-Program_002ees_002fdefvr_002ferror_005fsize"></span><dl class="def">
<dt id="index-error_005fsize"><span class="category">Variable opcional: </span><span><strong>error_size</strong><a href='#index-error_005fsize' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Valor por defecto: 10
</p>
<p>La variable <code>error_size</code> modifica los mensajes de error de acuerdo con el tamaño de las expresiones que aparecen en él. Si el tamaño de una expresión (tal como lo determina la función Lisp <code>ERROR-SIZE</code>)
es mayor que <code>error_size</code>, la expresión se reemplaza en el mensaje por un símbolo, asignándole a éste una expresión. Los símbolos se toman de la lista <code>error_syms</code>.
</p>
<p>En caso contrario, si la expresión es menor que <code>error_size</code>, la expresión se muestra en el propio mensaje.
</p>
<p>Véanse también <code>error</code> y <code>error_syms</code>.
</p>
<p>Ejemplo:
</p>
<p>El tamaño de <code>U</code>, tal como lo determina <code>ERROR-SIZE</code>, es 24.
</p>
<div class="example">
<pre class="example">(%i1) U: (C^D^E + B + A)/(cos(X-1) + 1)$

(%i2) error_size: 20$

(%i3) error (&quot;Example expression is&quot;, U);

Example expression is errexp1
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) errexp1;
                            E
                           D
                          C   + B + A
(%o4)                    --------------
                         cos(X - 1) + 1
(%i5) error_size: 30$

(%i6) error (&quot;Example expression is&quot;, U);

                         E
                        D
                       C   + B + A
Example expression is --------------
                      cos(X - 1) + 1
 -- an error.  Quitting.  To debug this try debugmode(true);
</pre></div>

</dd></dl>



<span id="Item_003a-Program_002ees_002fdefvr_002ferror_005fsyms"></span><dl class="def">
<dt id="index-error_005fsyms"><span class="category">Variable opcional: </span><span><strong>error_syms</strong><a href='#index-error_005fsyms' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Valor por defecto: <code>[errexp1, errexp2, errexp3]</code>
</p>
<p>En los mensajes de error, las expresiones mayores que <code>error_size</code> son reemplazadas por símbolos a los cuales se les asignas estas expresiones.  Los símbolos se toman de la lista <code>error_syms</code>. La primera expresión que resulte ser demasiado larga se reemplaza por <code>error_syms[1]</code>, la segunda por <code>error_syms[2]</code> y así sucesivamente.
</p>
<p>Si hay más expresiones largas que elementos en <code>error_syms</code>, los símbolos se construyen automáticamente, siendo el <var>n</var>-ésimo símbolo equivalente a <code>concat ('errexp, <var>n</var>)</code>.
</p>
<p>Véanse también <code>error</code> y <code>error_size</code>.
</p>
</dd></dl>



<span id="Item_003a-Program_002ees_002fdeffn_002ferrormsg"></span><dl class="def">
<dt id="index-errormsg"><span class="category">Función: </span><span><strong>errormsg</strong> <em>()</em><a href='#index-errormsg' class='copiable-anchor'> &para;</a></span></dt>
<dd>
<p>Reimprime el mensaje de error más reciente. La variable <code>error</code> guarda el mensaje y <code>errormsg</code> lo formatea e imprime.
</p>
</dd></dl>



<span id="Item_003a-Program_002ees_002fdefvr_002ferrormsg"></span><dl class="def">
<dt id="index-errormsg-1"><span class="category">Variable opcional: </span><span><strong>errormsg</strong><a href='#index-errormsg-1' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Cuando <code>errormsg</code> vale <code>false</code> se suprimen los contenidos
de los mensajes de error.
</p>
<p>La variable <code>errormsg</code> no se puede asignar a un valor local dentro
de un bloque. El valor global de <code>errormsg</code> está siempre presente.
</p>
<p>Ejemplos:
</p>
<div class="example">
<pre class="example">(%i1) errormsg;
(%o1)                                true
(%i2) sin(a,b);
Wrong number of arguments to sin
 -- an error. To debug this try: debugmode(true);
(%i3) errormsg:false;
(%o3)                                false
(%i4) sin(a,b);

 -- an error. To debug this try: debugmode(true);
</pre></div>

<p>La variable <code>errormsg</code> no se puede asignar a un valor local dentro
de un bloque.
</p>
<div class="example">
<pre class="example">(%i1) f(bool):=block([errormsg:bool], 
                     print (&quot;value of errormsg is&quot;,errormsg))$
(%i2) errormsg:true;
(%o2)                                true
(%i3) f(false);
value of errormsg is true 
(%o3)                                true
(%i4) errormsg:false;
(%o4)                                false
(%i5) f(true);
value of errormsg is false 
(%o5)                                false
</pre></div>
</dd></dl>



<span id="Item_003a-Program_002ees_002fdeffn_002ffor"></span><dl class="def">
<dt id="index-for"><span class="category">Operador especial: </span><span><strong>for</strong><a href='#index-for' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Utilizado en las iteraciones. Véase <code>do</code> para una descripción de las técnicas de iteración en Maxima.
</p>
</dd></dl>

<span id="Item_003a-Program_002ees_002fdeffn_002fgo"></span><dl class="def">
<dt id="index-go"><span class="category">Función: </span><span><strong>go</strong> <em>(<var>etiqueta</var>)</em><a href='#index-go' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Se utiliza dentro de un bloque (<code>block</code>) para transferir el control a la sentencia del bloque que esté etiquetada con el argumento de <code>go</code>. Una sentencia queda etiquetada cuando está precedida por un argumento de tipo átomo como cualquier otra sentencia de <code>block</code>.  Por ejemplo:
</p>
<div class="example">
<pre class="example">block ([x], x:1, tururu, x+1, ..., go(tururu), ...)
</pre></div>

<p>El argumento de <code>go</code> debe ser el nombre de una etiqueta que aparezca en el mismo bloque (<code>block</code>). No se puede utilizar <code>go</code> para transferir el control a un bloque que no sea aquel que contenga la sentencia <code>go</code>.
</p>
</dd></dl>

<span id="Item_003a-Program_002ees_002fdeffn_002fif"></span><dl class="def">
<dt id="index-if"><span class="category">Operador especial: </span><span><strong>if</strong><a href='#index-if' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Evaluación condicionada. Se reconocen varias formas de expresiones <code>if</code>.
</p>
<p>La expresión <code>if <var>cond_1</var> then <var>expr_1</var> else <var>expr_0</var></code>
devuelve <var>expr_1</var> si <var>cond_1</var> vale <code>true</code>,
en caso contrario la respuesta es <code>expr_0</code>.
</p>
<p>La expresión <code>if <var>cond_1</var> then <var>expr_1</var> elseif <var>cond_2</var>
then <var>expr_2</var> elseif ... else <var>expr_0</var></code>
devuelve <var>expr_k</var> si <var>cond_k</var> vale <code>true</code> y todas las
condiciones anteriores toman el valor <code>false</code>.
Si ninguna de las condiciones vale <code>true</code>, la respuesta es <code>expr_0</code>.
</p>
<p>La falta de un <code>else</code> final se interpreta como un <code>else false</code>;
esto es, la expresión <code>if <var>cond_1</var> then <var>expr_1</var></code>
equivale a <code>if <var>cond_1</var> then <var>expr_1</var> else false</code>,
y <code>if <var>cond_1</var> then <var>expr_1</var> elseif ... elseif <var>cond_n</var> then <var>expr_n</var></code>
equivale a su vez a
<code>if <var>cond_1</var> then <var>expr_1</var> elseif ... elseif <var>cond_n</var> then <var>expr_n</var> else false</code>.
</p>
<p>Las alternativas <var>expr_0</var>, ..., <var>expr_n</var> pueden ser expresiones
válidas de Maxima, incluidas expresiones <code>if</code> anidadas.
Las alternativas ni se simplifican ni se evalúan, a menos que su
condición asociada valga <code>true</code>.
</p>
<p>Las condiciones <var>cond_1</var>, ..., <var>cond_n</var> deben ser expresiones 
capaces de dar como resultado <code>true</code> o <code>false</code> al ser
evaluadas. Si en un momento dado una condición no da como resultado 
un valor de verdad (<code>true</code> o <code>false</code>), el comportamiento de <code>if</code> se controla
con la variable global <code>prederror</code>. Si <code>prederror</code> vale <code>true</code>,
se considera un error que la condición evaluada no dé como resultado
un valor de verdad; en caso contrario, las condiciones que no
den como resultado un valor de verdad se aceptan, dándose el
resultado como una expresión condicional.
</p>
<p>Las condiciones pueden contener operadores lógicos y relacionales, 
así como otros elementos, tal como se indica a continuación:
</p>

<div class="example">
<pre class="example">Operación               Símbolo     Tipo
 
menor que               &lt;           operador relacional infijo
menor o igual que       &lt;=          operador relacional infijo
igualdad (sintáctica)   =           operador relacional infijo
negación de =           #           operador relacional infijo
igualdad (por valor)    equal       operador relacional infijo
negación de equal       notequal    operador relacional infijo
mayor o igual que       &gt;=          operador relacional infijo
mayor que               &gt;           operador relacional infijo
y                       and         operador lógico infijo
o                       or          operador lógico infijo
no                      not         operador lógico prefijo
</pre></div>

</dd></dl>

<span id="Item_003a-Program_002ees_002fdeffn_002fmap"></span><dl class="def">
<dt id="index-map"><span class="category">Función: </span><span><strong>map</strong> <em>(<var>f</var>, <var>expr_1</var>, ..., <var>expr_n</var>)</em><a href='#index-map' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Devuelve una expresión cuyo operador principal es el mismo 
que aparece en las expresiones <var>expr_1</var>, ..., <var>expr_n</var> 
pero cuyas subpartes son los resultados de aplicar <var>f</var> 
a cada una de las subpartes de las expresiones;  <var>f</var> puede ser 
tanto el nombre de una función de <em class='tex2jax_process'>\(n\)</em> argumentos como
una expresión <code>lambda</code> de <em class='tex2jax_process'>\(n\)</em> argumentos.
</p>
<p>Uno de los usos que tiene <code>map</code> es la de aplicar (o mapear)
una función (por ejemplo, <code>partfrac</code>) sobre cada término
de una expresión extensa en la que normalmente no se 
podría utilizar la función debido a insuficiencias 
en el espacio de almacenamiento durante el curso de un cálculo.
</p>
<div class="example">
<pre class="example">(%i1) map(f,x+a*y+b*z);
(%o1)                        f(b z) + f(a y) + f(x)
(%i2) map(lambda([u],partfrac(u,x)),x+1/(x^3+4*x^2+5*x+2));
                           1       1        1
(%o2)                     ----- - ----- + -------- + x
                         x + 2   x + 1          2
                                         (x + 1)
(%i3) map(ratsimp, x/(x^2+x)+(y^2+y)/y);
                                      1
(%o3)                            y + ----- + 1
                                    x + 1
(%i4) map(&quot;=&quot;,[a,b],[-0.5,3]);
(%o4)                          [a = - 0.5, b = 3]
</pre></div>

<p>Véase también <code>maperror</code> .
</p></dd></dl>

<span id="Item_003a-Program_002ees_002fdeffn_002fmapatom"></span><dl class="def">
<dt id="index-mapatom"><span class="category">Función: </span><span><strong>mapatom</strong> <em>(<var>expr</var>)</em><a href='#index-mapatom' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Devuelve <code>true</code> si y sólo <var>expr</var> es tratado por las rutinas de mapeo como un átomo.
</p></dd></dl>

<span id="Item_003a-Program_002ees_002fdefvr_002fmaperror"></span><dl class="def">
<dt id="index-maperror"><span class="category">Variable opcional: </span><span><strong>maperror</strong><a href='#index-maperror' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Cuando <code>maperror</code> toma el valor <code>false</code>, 
hace que todas las funciones de mapeo, como por ejemplo
</p>
<div class="example">
<pre class="example">map (f, <var>expr_1</var>, <var>expr_2</var>, ...)
</pre></div>

<p>(1) paren cuando hayan terminado de procesar la <var>expr_i</var> más corta,
a menos que todas ellas sean del mismo tamaño y (2) apliquen  <code>f</code>
a <code>[expr_1, expr_2, ...]</code> si es el caso que las <code>expr_i</code>
no son todas del mismo tipo de objeto.
</p>
<p>Cuando <code>maperror</code> toma el valor <code>true</code> entonces se emite un mensaje de error cuando se presenta cualquiera de los dos casos anteriores.
</p>
</dd></dl>



<span id="Item_003a-Program_002ees_002fdefvr_002fmapprint"></span><dl class="def">
<dt id="index-mapprint"><span class="category">Variable opcional: </span><span><strong>mapprint</strong><a href='#index-mapprint' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>mapprint</code> vale <code>true</code>, se producirán ciertos mensajes
por parte de las funciones <code>map</code>, <code>mapl</code> y <code>fullmap</code>
en determinadas situaciones, como cuando <code>map</code> hace uso de
<code>apply</code>.
</p>
<p>Si <code>mapprint</code> vale <code>false</code>, no se emitirán tales mensajes.
</p></dd></dl>



<span id="Item_003a-Program_002ees_002fdeffn_002fmaplist"></span><dl class="def">
<dt id="index-maplist"><span class="category">Función: </span><span><strong>maplist</strong> <em>(<var>f</var>, <var>expr_1</var>, ..., <var>expr_n</var>)</em><a href='#index-maplist' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Devuelve una lista con las aplicaciones de <var>f</var> a las partes de las expresiones <var>expr_1</var>, ..., <var>expr_n</var>; <var>f</var> es el nombre de una función ou una expresión lambda.
</p>
<p>La función <code>maplist</code> difiere de <code>map (<var>f</var>, <var>expr_1</var>, ..., <var>expr_n</var>)</code>, la cual devuelve una expresión con el mismo operador principal que tenga <var>expr_i</var>, excepto en simplificaciones y en el caso en el que <code>map</code> hace un <code>apply</code>.
</p>
</dd></dl>

<span id="Item_003a-Program_002ees_002fdefvr_002fprederror"></span><dl class="def">
<dt id="index-prederror"><span class="category">Variable opcional: </span><span><strong>prederror</strong><a href='#index-prederror' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Cuando <code>prederror</code> toma el valor <code>true</code>, se emite un mensaje de error siempre que el predicado de una sentencia  <code>if</code> o de una función <code>is</code> no se pueda evaluar ni a verdadero (<code>true</code>) ni  a falso (<code>false</code>).
</p>
<p>Si toma el valor <code>false</code>, se devuelve bajo las mismas circunstancias anteriores el valor <code>unknown</code>. El modo <code>prederror: false</code> no está soportado en el código traducido; sin embargo, <code>maybe</code> está soportado en código traducido.
</p>
<p>Véanse también <code>is</code> y <code>maybe</code>.
</p>
</dd></dl>

<span id="Item_003a-Program_002ees_002fdeffn_002freturn"></span><dl class="def">
<dt id="index-return"><span class="category">Función: </span><span><strong>return</strong> <em>(valor)</em><a href='#index-return' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Puede utilizarse para salir de un bloque, devolviendo su argumento.
Véase <code>block</code> para más información.
</p>
</dd></dl>

<span id="Item_003a-Program_002ees_002fdeffn_002fscanmap"></span><dl class="def">
<dt id="index-scanmap"><span class="category">Función: </span><span><strong>scanmap</strong> <em>(<var>f</var>, <var>expr</var>)</em><a href='#index-scanmap' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-scanmap-1"><span class="category">Función: </span><span><strong>scanmap</strong> <em>(<var>f</var>, <var>expr</var>, bottomup)</em><a href='#index-scanmap-1' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Aplica recursivamente <var>f</var> sobre <var>expr</var>, de arriba hacia abajo. Esto es más útil cuando se busca una factorización completa, por ejemplo:
</p>
<div class="example">
<pre class="example">(%i1) exp:(a^2+2*a+1)*y + x^2$
(%i2) scanmap(factor,exp);
                                    2      2
(%o2)                         (a + 1)  y + x
</pre></div>

<p>Nótese que cómo <code>scanmap</code> aplica la función dada <code>factor</code> a las subexpresiones que forman a <var>expr</var>; si se presenta otra forma de <var>expr</var> a <code>scanmap</code> entonces el resultado puede ser diferente. Así, <code>%o2</code> no se restaura cuando <code>scanmap</code> se aplica a la forma expandida de exp:
</p>
<div class="example">
<pre class="example">(%i3) scanmap(factor,expand(exp));
                           2                  2
(%o3)                      a  y + 2 a y + y + x
</pre></div>

<p>Aquí hay otro ejemplo de la forma en que <code>scanmap</code> aplica recursivamente una función dada a todas las subexpresiones, incluyendo exponentes:
</p>
<div class="example">
<pre class="example">(%i4) expr : u*v^(a*x+b) + c$
(%i5) scanmap('f, expr);
                    f(f(f(a) f(x)) + f(b))
(%o5) f(f(f(u) f(f(v)                      )) + f(c))
</pre></div>

<p><code>scanmap (<var>f</var>, <var>expr</var>, bottomup)</code> aplica <var>f</var> a <var>expr</var> de abajo hacia arriba. Por ejemplo, para <code>f</code> no definida,
</p>
<div class="example">
<pre class="example">scanmap(f,a*x+b) -&gt;
   f(a*x+b) -&gt; f(f(a*x)+f(b)) -&gt; f(f(f(a)*f(x))+f(b))
scanmap(f,a*x+b,bottomup) -&gt; f(a)*f(x)+f(b)
    -&gt; f(f(a)*f(x))+f(b) -&gt;
     f(f(f(a)*f(x))+f(b))
</pre></div>

<p>En este caso se obtiene la misma respuesta por cualquiera de los dos métodos.
</p>
</dd></dl>

<span id="Item_003a-Program_002ees_002fdeffn_002fthrow"></span><dl class="def">
<dt id="index-throw"><span class="category">Función: </span><span><strong>throw</strong> <em>(<var>expr</var>)</em><a href='#index-throw' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Evalúa <var>expr</var> y devuelve el valor del <code>catch</code> más reciente. La función <code>throw</code> se utiliza junto con <code>catch</code> como un mecanismo de retorno no local.
</p>
</dd></dl>


<span id="Item_003a-Program_002ees_002fdeffn_002fwhile"></span><dl class="def">
<dt id="index-while"><span class="category">Operador especial: </span><span><strong>while</strong><a href='#index-while' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="Item_003a-Program_002ees_002fdeffn_002funless"></span></dd><dt id="index-unless"><span class="category">Operador especial: </span><span><strong>unless</strong><a href='#index-unless' class='copiable-anchor'> &para;</a></span></dt>
<dd>
<p>Véase <code>do</code>.
</p>
</dd></dl>


<span id="Item_003a-Program_002ees_002fdeffn_002foutermap"></span><dl class="def">
<dt id="index-outermap"><span class="category">Función: </span><span><strong>outermap</strong> <em>(<var>f</var>, <var>a_1</var>, ..., <var>a_n</var>)</em><a href='#index-outermap' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Aplica la función <var>f</var> a cada uno de los elementos del producto vectorial <var>a_1</var> por <var>a_2</var> ... por <var>a_n</var>.
</p>
<p>El argumento <var>f</var> debe ser el nombre de una función de <em class='tex2jax_process'>\(n\)</em> argumentos,
o una expresión lambda de <em class='tex2jax_process'>\(n\)</em> argumentos.
Cada uno de los argumentos <var>a_k</var> puede ser una lista, una lista anidada, 
una matriz o cualquier otro tipo de expresión.
</p>
<p>El valor devuelto por <code>outermap</code> es una estructura anidada. Si <var>x</var> es la
respuesta dada por <code>outermap</code>, entonces tiene la misma estructura que la primera lista,
lista anidada o matriz, <code><var>x</var>[i_1]...[i_m]</code> tiene la misma estructura que la
segunda lista, lista anidada o matriz, <code><var>x</var>[i_1]...[i_m][j_1]...[j_n]</code> tiene 
la misma estructura que la tercera lista, lista anidada o matriz, y así
sucesivamente, siendo <var>m</var>, <var>n</var>, ... los números índice
necesarios para acceder a los elementos de cada argumento: uno para las listas,
dos para las matrices y uno o más para las listas anidadas. 
Aquellos argumentos que no sean listas ni matrices no tienen efecto alguno sobre
la estructura del valor retornado.
</p>
<p>Nótese que el efecto producido por <code>outermap</code> es diferente del que
se obtiene al aplicar <var>f</var> a cada uno de los elementos del producto
devuelto por <code>cartesian_product</code>. La función <code>outermap</code>
mantiene la estructura de los argumentos en la respuesta, miemtras que
<code>cartesian_product</code> no lo hace.
</p>
<p>La función <code>outermap</code> evalúa sus argumentos.
</p>
<p>Véanse también <code>map</code>, <code>maplist</code> y <code>apply</code>.
</p>
<p>Ejemplos:
</p>
<p>Ejemplos elementales de uso de <code>outermap</code>.
Con el fin de mostrar con mayor claridad las combinaciones del argumento,
se mantiene sin definir <code>F</code>.
</p>

<div class="example">
<pre class="example">(%i1) outermap (F, [a, b, c], [1, 2, 3]);
(%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)], 
                                     [F(c, 1), F(c, 2), F(c, 3)]]
(%i2) outermap (F, matrix ([a, b], [c, d]), matrix ([1, 2], [3, 4]));
         [ [ F(a, 1)  F(a, 2) ]  [ F(b, 1)  F(b, 2) ] ]
         [ [                  ]  [                  ] ]
         [ [ F(a, 3)  F(a, 4) ]  [ F(b, 3)  F(b, 4) ] ]
(%o2)    [                                            ]
         [ [ F(c, 1)  F(c, 2) ]  [ F(d, 1)  F(d, 2) ] ]
         [ [                  ]  [                  ] ]
         [ [ F(c, 3)  F(c, 4) ]  [ F(d, 3)  F(d, 4) ] ]
(%i3) outermap (F, [a, b], x, matrix ([1, 2], [3, 4]));
       [ F(a, x, 1)  F(a, x, 2) ]  [ F(b, x, 1)  F(b, x, 2) ]
(%o3) [[                        ], [                        ]]
       [ F(a, x, 3)  F(a, x, 4) ]  [ F(b, x, 3)  F(b, x, 4) ]
(%i4) outermap (F, [a, b], matrix ([1, 2]), matrix ([x], [y]));
       [ [ F(a, 1, x) ]  [ F(a, 2, x) ] ]
(%o4) [[ [            ]  [            ] ], 
       [ [ F(a, 1, y) ]  [ F(a, 2, y) ] ]
                              [ [ F(b, 1, x) ]  [ F(b, 2, x) ] ]
                              [ [            ]  [            ] ]]
                              [ [ F(b, 1, y) ]  [ F(b, 2, y) ] ]
(%i5) outermap (&quot;+&quot;, [a, b, c], [1, 2, 3]);
(%o5) [[a + 1, a + 2, a + 3], [b + 1, b + 2, b + 3], 
                                           [c + 1, c + 2, c + 3]]
</pre></div>

<p>El siguiente ejemplo permite hacer un análisis más profundo del valor
retornado por <code>outermap</code>.
Los tres primeros argumentos son una matriz, una lista y otra matriz, en este
orden. El valor devuelto es una matriz, cuyos elementos son listas y
cada elemento de cada una de estas listas es a su vez una matriz.
</p>
<div class="example">
<pre class="example">(%i1) arg_1 :  matrix ([a, b], [c, d]);
                            [ a  b ]
(%o1)                       [      ]
                            [ c  d ]
(%i2) arg_2 : [11, 22];
(%o2)                       [11, 22]
(%i3) arg_3 : matrix ([xx, yy]);
(%o3)                      [ xx  yy ]
(%i4) xx_0 : outermap(lambda([x, y, z], x / y + z), arg_1,
                                                   arg_2, arg_3);
               [  [      a        a  ]  [      a        a  ]  ]
               [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
               [  [      11       11 ]  [      22       22 ]  ]
(%o4)  Col 1 = [                                              ]
               [  [      c        c  ]  [      c        c  ]  ]
               [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
               [  [      11       11 ]  [      22       22 ]  ]
                 [  [      b        b  ]  [      b        b  ]  ]
                 [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                 [  [      11       11 ]  [      22       22 ]  ]
         Col 2 = [                                              ]
                 [  [      d        d  ]  [      d        d  ]  ]
                 [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                 [  [      11       11 ]  [      22       22 ]  ]
(%i5) xx_1 : xx_0 [1][1];
           [      a        a  ]  [      a        a  ]
(%o5)     [[ xx + --  yy + -- ], [ xx + --  yy + -- ]]
           [      11       11 ]  [      22       22 ]
(%i6) xx_2 : xx_0 [1][1] [1];
                      [      a        a  ]
(%o6)                 [ xx + --  yy + -- ]
                      [      11       11 ]
(%i7) xx_3 : xx_0 [1][1] [1] [1][1];
                                  a
(%o7)                        xx + --
                                  11
(%i8) [op (arg_1), op (arg_2), op (arg_3)];
(%o8)                  [matrix, [, matrix]
(%i9) [op (xx_0), op (xx_1), op (xx_2)];
(%o9)                  [matrix, [, matrix]
</pre></div>

<p>La función <code>outermap</code> mantiene la estructura de los argumentos en su respuesta,
mientras que <code>cartesian_product</code> no lo hace.
</p>
<div class="example">
<pre class="example">(%i1) outermap (F, [a, b, c], [1, 2, 3]);
(%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)], 
                                     [F(c, 1), F(c, 2), F(c, 3)]]
(%i2) setify (flatten (%));
(%o2) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3), 
                                       F(c, 1), F(c, 2), F(c, 3)}
(%i3) map (lambda ([L], apply (F, L)), cartesian_product ({a, b, c}, {1, 2, 3}));
(%o3) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3), 
                                       F(c, 1), F(c, 2), F(c, 3)}
(%i4) is (equal (%, %th (2)));
(%o4)                         true
</pre></div>

</dd></dl>




</div>
<hr>
<div class="header">
<p>
Anterior: <a href="maxima_165.html" accesskey="p" rel="prev">Introducción a la programación</a>, Subir: <a href="maxima_162.html" accesskey="u" rel="up">Programación</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Índice general" rel="contents">Índice general</a>][<a href="maxima_304.html" title="Índice" rel="index">Índice</a>]</p>
</div>


<a href='js_licenses.html' rel='jslicense'><small>Información de licencia de JavaScript</small></a>
</body>
</html>
