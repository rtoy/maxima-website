<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Manual de Maxima 5.46.0: Introducción a polinomios ortogonales</title>

<meta name="description" content="Manual de Maxima 5.46.0: Introducción a polinomios ortogonales">
<meta name="keywords" content="Manual de Maxima 5.46.0: Introducción a polinomios ortogonales">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="maxima_toc.html#Top" rel="start" title="Top">
<link href="maxima_304.html#g_t_00cdndice-de-Funciones-y-Variables" rel="index" title="Índice de Funciones y Variables">
<link href="maxima_toc.html#SEC_Contents" rel="contents" title="&Iacute;ndice General">
<link href="maxima_264.html#orthopoly" rel="up" title="orthopoly">
<link href="maxima_266.html#Funciones-y-variables-para-polinomios-ortogonales" rel="next" title="Funciones y variables para polinomios ortogonales">
<link href="maxima_264.html#orthopoly" rel="previous" title="orthopoly">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 1em; padding-bottom: 1em;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%; display: block; margin-left: auto; margin-right: auto}

-->
</style>

<link rel="icon" href="figures/favicon.ico">

</head>

<body lang="es" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="Introducci_00f3n-a-polinomios-ortogonales"></a>
<div class="header">
<p>
Siguiente: <a href="maxima_266.html#Funciones-y-variables-para-polinomios-ortogonales" accesskey="n" rel="next">Funciones y variables para polinomios ortogonales</a>, Previous: <a href="maxima_264.html#orthopoly" accesskey="p" rel="previous">orthopoly</a>, Subir: <a href="maxima_264.html#orthopoly" accesskey="u" rel="up">orthopoly</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="&Iacute;ndice general" rel="contents">&Iacute;ndice general</a>][<a href="maxima_304.html#g_t_00cdndice-de-Funciones-y-Variables" title="&Iacute;ndice" rel="index">&Iacute;ndice</a>]</p>
</div>
<a name="Introduccion-a-polinomios-ortogonales"></a>
<h3 class="section">69.1 Introducción a polinomios ortogonales</h3>

<p>El paquete <code>orthopoly</code> contiene funciones para la evaluación
simbólica y numérica de diversos tipos de polinomios ortogonales, como
los de Chebyshev, Laguerre, Hermite, Jacobi, Legendre y ultraesféricos 
(Gegenbauer). Además, <code>orthopoly</code> soporta las funciones esféricas
de Bessel, Hankel y armónicas.
</p>
<p>Referencias:
</p><ul>
<li> Abramowitz y Stegun, <i>Handbook of Mathematical Functions</i>,
(1972, décima reimpresión, capítulo 22)

</li><li> Gradshteyn y Ryzhik, <i>Table of Integrals, Series y  Products</i>, (1980, edición
corregida y ampliada)

</li><li> Eugen Merzbacher, <i>Quantum Mechanics</i>, (1970, segunda edición)

</li></ul>

<p>El paquete <code>orthopoly</code>, junto con su documentación, fue escrito por 
Barton Willis de la Universidad de Nebraska en Kearney. El paquete se
distribuye con la licencia GNU General Public License (GPL).
</p>

<a name="Iniciandose-con-orthopoly"></a>
<h4 class="subsection">69.1.1 Iniciándose con orthopoly</h4>

<p><code>load (&quot;orthopoly&quot;)</code> carga el paquete <code>orthopoly</code>.
</p>
<p>Para obtener el polinomio de Legendre de tercer orden,
</p>
<div class="example">
<pre class="example">(%i1) legendre_p (3, x);
                      3             2
             5 (1 - x)    15 (1 - x)
(%o1)      - ---------- + ----------- - 6 (1 - x) + 1
                 2             2
</pre></div>

<p>Para expresarlo como una suma de potencias de <var>x</var>, aplíquese
<var>ratsimp</var> o <var>rat</var> al resultado.
</p>
<div class="example">
<pre class="example">(%i2) [ratsimp (%), rat (%)];
                        3           3
                     5 x  - 3 x  5 x  - 3 x
(%o2)/R/            [----------, ----------]
                         2           2
</pre></div>

<p>De forma alternativa, conviértase el segundo argumento de to <code>legendre_p</code>
(su variable  &ldquo;principal&rdquo;) a una expresión racional canónica 
(canonical rational expression, CRE)).
</p>
<div class="example">
<pre class="example">(%i1) legendre_p (3, rat (x));
                              3
                           5 x  - 3 x
(%o1)/R/                   ----------
                               2
</pre></div>

<p>Para la evaluación numérica,  <code>orthopoly</code> hace uso del análisis
de error de ejecución para estimar una cota superior del error. Por ejemplo,
</p>
<div class="example">
<pre class="example">(%i1) jacobi_p (150, 2, 3, 0.2);
(%o1) interval(- 0.062017037936715, 1.533267919277521E-11)
</pre></div>

<p>Los intervalos tienen la forma <code>interval (<var>c</var>, <var>r</var>)</code>, donde
<var>c</var> es el centro y <var>r</var> el radio del intervalo. Puesto que Maxima
no soporta aritmética de intervalos, en algunas situaciones, como en los 
gráficos, puede ser necesario ignorar el error y utilizar el centro del
intervalo. Para conseguirlo conviene asignar a la variable 
<code>orthopoly_returns_intervals</code> el valor <code>false</code>.
</p>
<div class="example">
<pre class="example">(%i1) orthopoly_returns_intervals : false;
(%o1)                         false
(%i2) jacobi_p (150, 2, 3, 0.2);
(%o2)                  - 0.062017037936715
</pre></div>

<p>Véase la sección <i>Evaluación numérica</i> para más información.
</p>
<p>La mayor parte de las funciones de <code>orthopoly</code> tienen una propiedad
<code>gradef</code>; así,
</p>
<div class="example">
<pre class="example">(%i1) diff (hermite (n, x), x);
(%o1)                     2 n H     (x)
                               n - 1
(%i2) diff (gen_laguerre (n, a, x), x);
              (a)               (a)
           n L   (x) - (n + a) L     (x) unit_step(n)
              n                 n - 1
(%o2)      ------------------------------------------
                               x
</pre></div>

<p>La función <code>unit_step</code> del segundo ejemplo evita el error que
aparecería al evaluar la expresión con <var>n</var> igual a 0.
</p>
<div class="example">
<pre class="example">(%i3) ev (%, n = 0);
(%o3)                           0
</pre></div>

<p>La propiedad &quot;gradef&quot; sólo se aplica a la variable principal; derivadas 
respecto de las otras variables darán lugar normalmente a mensajes de 
error; por ejemplo,
</p>
<div class="example">
<pre class="example">(%i1) diff (hermite (n, x), x);
(%o1)                     2 n H     (x)
                               n - 1
(%i2) diff (hermite (n, x), n);

Maxima doesn't know the derivative of hermite with 
respect the first argument
 -- an error.  Quitting.  To debug this try debugmode(true);
</pre></div>

<p>Generalmente, las funciones de <code>orthopoly</code> se distribuyen sobre listas y
matrices. Al objeto de que la evaluación se realice completamente, las variables
opcionales <code>doallmxops</code> y <code>listarith</code> deben valer ambas <code>true</code>,
que es el valor por defecto. Para ilustrar la distribución sobre matrices 
sirve el siguiente ejemplo
</p>
<div class="example">
<pre class="example">(%i1) hermite (2, x);
                                     2
(%o1)                    - 2 (1 - 2 x )
(%i2) m : matrix ([0, x], [y, 0]);
                            [ 0  x ]
(%o2)                       [      ]
                            [ y  0 ]
(%i3) hermite (2, m);
               [                             2  ]
               [      - 2        - 2 (1 - 2 x ) ]
(%o3)          [                                ]
               [             2                  ]
               [ - 2 (1 - 2 y )       - 2       ]
</pre></div>

<p>En el segundo ejemplo, el elemento <code>i, j</code>-ésimo es
<code>hermite (2, m[i,j])</code>, que no es lo mismo que calcular
<code>-2 + 4 m . m</code>, según se ve en el siguiente ejemplo.
</p>
<div class="example">
<pre class="example">(%i4) -2 * matrix ([1, 0], [0, 1]) + 4 * m . m;
                    [ 4 x y - 2      0     ]
(%o4)               [                      ]
                    [     0      4 x y - 2 ]
</pre></div>

<p>Si se evalúa una función en un punto fuera de su dominio de definición,
generalmente <code>orthopoly</code> devolverá la función sin evaluar. Por ejemplo,
</p>
<div class="example">
<pre class="example">(%i1) legendre_p (2/3, x);
(%o1)                        P   (x)
                              2/3
</pre></div>

<p><code>orthopoly</code> da soporte a la traducción de expresiones al formato TeX y
la representación bidimensional en el terminal.
</p>
<div class="example">
<pre class="example">(%i1) spherical_harmonic (l, m, theta, phi);
                          m
(%o1)                    Y (theta, phi)
                          l
(%i2) tex (%);
$$Y_{l}^{m}\left(\vartheta,\varphi\right)$$
(%o2)                         false
(%i3) jacobi_p (n, a, a - b, x/2);
                          (a, a - b) x
(%o3)                    P          (-)
                          n          2
(%i4) tex (%);
$$P_{n}^{\left(a,a-b\right)}\left({{x}\over{2}}\right)$$
(%o4)                         false
</pre></div>

<a name="Limitaciones"></a>
<h4 class="subsection">69.1.2 Limitaciones</h4>

<p>Cuando una expresión contenga varios polinomios ortogonales
con órdenes simbólicos, es posible que aunque la expresión sea
nula, Maxima sea incapaz de simplificarla a cero, por lo que si se
divide por esta cantidad, aparecerán problemas. Por ejemplo, la
siguiente expressión se anula para enteros <var>n</var> mayores que
1, no pudiendo Maxima reducirla a cero.
</p>
<div class="example">
<pre class="example">(%i1) (2*n - 1) * legendre_p (n - 1, x) * x - n * legendre_p (n, x)
                + (1 - n) * legendre_p (n - 2, x);
(%o1)  (2 n - 1) P     (x) x - n P (x) + (1 - n) P     (x)
                  n - 1           n               n - 2
</pre></div>

<p>Para un valor específico de <var>n</var> se puede
reducir la expresión a cero.
</p>
<div class="example">
<pre class="example">(%i2) ev (% ,n = 10, ratsimp);
(%o2)                           0
</pre></div>

<p>Generalmente, la forma polinomial de un polinomio ortogonal no es la más
apropiada para su evaluación numérica. Aquí un ejemplo.
</p>
<div class="example">
<pre class="example">(%i1) p : jacobi_p (100, 2, 3, x)$
(%i2) subst (0.2, x, p);
(%o2)                3.4442767023833592E+35
(%i3) jacobi_p (100, 2, 3, 0.2);
(%o3)  interval(0.18413609135169, 6.8990300925815987E-12)
(%i4) float(jacobi_p (100, 2, 3, 2/10));
(%o4)                   0.18413609135169
</pre></div>

<p>Este resultado se puede mejorar expandiendo el polinomio y evaluando
a continuación, lo que da una aproximación mejor.
</p><div class="example">
<pre class="example">(%i5) p : expand(p)$
(%i6) subst (0.2, x, p);
(%o6) 0.18413609766122982
</pre></div>

<p>Sin embargo esto no vale como regla general; la expansión del
polinomio no siempre da como resultado una expresión más fácil
de evaluar numéricamente. Sin duda, la mejor manera de hacer la
evaluación numérica consiste en hacer que uno o más de los argumentos
de la función sean decimales en coma flotante; de esta forma se utilizarán
algoritmos decimales especializados para hacer la evaluación.
</p>
<p>La función <code>float</code> de Maxima trabaja de forma indiscriminada; si se aplica
<code>float</code> a una expresión que contenga un polinomio ortogonal con el grado u orden
simbólico, éstos se pueden transformar en decimales y la expresión no ser
evaluada de forma completa. Considérese
</p>
<div class="example">
<pre class="example">(%i1) assoc_legendre_p (n, 1, x);
                               1
(%o1)                         P (x)
                               n
(%i2) float (%);
                              1.0
(%o2)                        P   (x)
                              n
(%i3) ev (%, n=2, x=0.9);
                             1.0
(%o3)                       P   (0.9)
                             2
</pre></div>

<p>La expresión en <code>(%o3)</code> no da como resultado un decimal en coma flotante; 
<code>orthopoly</code> no reconoce decimales donde espera que haya enteros. De forma semejante,
la evaluación numérica de la función <code>pochhammer</code> para órdenes que
excedan <code>pochhammer_max_index</code> puede ser problemática; considérese
</p>
<div class="example">
<pre class="example">(%i1) x :  pochhammer (1, 10), pochhammer_max_index : 5;
(%o1)                         (1)
                                 10
</pre></div>

<p>Aplicando <code>float</code> no da para <var>x</var> un valor decimal
</p>
<div class="example">
<pre class="example">(%i2) float (x);
(%o2)                       (1.0)
                                 10.0
</pre></div>

<p>A fin de evaluar <var>x</var> como decimal, es necesario asignar a 
<code>pochhammer_max_index</code> en valor 11 o mayor y aplicar 
<code>float</code> a <var>x</var>.
</p>
<div class="example">
<pre class="example">(%i3) float (x), pochhammer_max_index : 11;
(%o3)                       3628800.0
</pre></div>

<p>El valor por defecto de <code>pochhammer_max_index</code> es 100;
cámbiese este valor tras cargar el paquete <code>orthopoly</code>.
</p>
<p>Por último, téngase en cuenta que las referencias bibliográficas
no coinciden a la hora de definir los polinomios ortogonales; en 
<code>orthopoly</code> se han utilizado normalmente las convenciones seguidas
por Abramowitz y Stegun.
</p>
<p>Cuando se sospeche de un fallo en <code>orthopoly</code>, compruébense algunos
casos especiales a fin de determinar si las definiciones de las que el
usuario parte coinciden con las utilizadas por el paquete <code>orthopoly</code>.
A veces las definiciones difieren por un factor de normalización; algunos
autores utilizan versiones que hacen que las familias sean ortogonales
en otros intervalos diferentes de <em>(-1, 1)</em>. Así por
ejemplo, para definir un polinomio de Legendre ortogonal en <em>(0, 1)</em>
defínase
</p>
<div class="example">
<pre class="example">(%i1) shifted_legendre_p (n, x) := legendre_p (n, 2*x - 1)$

(%i2) shifted_legendre_p (2, rat (x));
                            2
(%o2)/R/                 6 x  - 6 x + 1
(%i3) legendre_p (2, rat (x));
                               2
                            3 x  - 1
(%o3)/R/                    --------
                               2
</pre></div>

<a name="Evaluaci_00f3n-num_00e9rica"></a><a name="Evaluacion-numerica"></a>
<h4 class="subsection">69.1.3 Evaluación numérica</h4>

<p>La mayor parte de las funciones de <code>orthopoly</code> realizan análisis de
errores en tiempo de ejecución para estimar el error en la evaluación
decimal, a excepción de las funciones esféricas de Bessel y los 
polinomios asociados de Legendre de segunda especie. Para la 
evaluación numérica, las funciones esféricas de Bessel hacen uso
de funciones SLATEC. No se lleva a cabo ningún método especial de
evaluación numérica para los polinomios asociados de Legendre de 
segunda especie.
</p>
<p>Es posible, aunque improbable, que el error obtenido en las evaluaciones 
numéricas exceda al error estimado.
</p>

<p>Los intervalos tienen la forma <code>interval (<var>c</var>, <var>r</var>)</code>,
siendo <var>c</var> el centro del intervalo y <var>r</var> su radio. El
centro del intervalo puede ser un número complejo, pero el radio
será siempre un número real positivo.
</p>
<p>He aquí un ejemplo:
</p>
<div class="example">
<pre class="example">(%i1) fpprec : 50$
(%i2) y0 : jacobi_p (100, 2, 3, 0.2);
(%o2) interval(0.1841360913516871, 6.8990300925815987E-12)
(%i3) y1 : bfloat (jacobi_p (100, 2, 3, 1/5));
(%o3) 1.8413609135168563091370224958913493690868904463668b-1
</pre></div>

<p>Se comprueba que el error es menor que el estimado
</p>
<div class="example">
<pre class="example">(%i4) is (abs (part (y0, 1) - y1) &lt; part (y0, 2));
(%o4)                         true
</pre></div>

<p>En este ejemplo el error estimado es una cota superior para el error
verdadero.
</p>
<p>Maxima no da soporte a la aritmética de intervalos.
</p>
<div class="example">
<pre class="example">(%i1) legendre_p (7, 0.1) + legendre_p (8, 0.1);
(%o1) interval(0.18032072148437508, 3.1477135311021797E-15)
        + interval(- 0.19949294375000004, 3.3769353084291579E-15)
</pre></div>

<p>El usuario puede definir operadores aritméticos para los intervalos.
Para definir la suma de intervalos se puede hacer
</p>
<div class="example">
<pre class="example">(%i1) infix (&quot;@+&quot;)$

(%i2) &quot;@+&quot;(x,y) := interval (part (x, 1) + part (y, 1), 
                              part (x, 2) + part (y, 2))$
(%i3) legendre_p (7, 0.1) @+ legendre_p (8, 0.1);
(%o3) interval(- 0.019172222265624955, 6.5246488395313372E-15)
</pre></div>

<p>Las rutinas especiales para cálculo numérico son llamadas cuando
los argumentos son complejos. Por ejemplo,
</p>
<div class="example">
<pre class="example">(%i1) legendre_p (10, 2 + 3.0*%i);
(%o1) interval(- 3.876378825E+7 %i - 6.0787748E+7, 
                                           1.2089173052721777E-6)
</pre></div>

<p>Compárese con el valor verdadero.
</p>
<div class="example">
<pre class="example">(%i1) float (expand (legendre_p (10, 2 + 3*%i)));
(%o1)          - 3.876378825E+7 %i - 6.0787748E+7
</pre></div>

<p>Además, cuando los argumentos son números decimales grandes 
(<i>big floats</i>), se realizan llamadas a las rutinas numéricas 
especiales; sin embargo, los decimales grandes se convierten 
previamente a doble precisión y de este tipo serán también
los resultados.
</p>
<div class="example">
<pre class="example">(%i1) ultraspherical (150, 0.5b0, 0.9b0);
(%o1) interval(- 0.043009481257265, 3.3750051301228864E-14)
</pre></div>

<a name="Graficos-y-orthopoly"></a>
<h4 class="subsection">69.1.4 Gráficos y orthopoly</h4>

<p>Para representar gráficamente expresiones que contengan polinomios
ortogonales se deben hacer dos cosas:
</p><ol>
<li> Asignar a la variable opcional <code>orthopoly_returns_intervals</code> el valor <code>false</code>,
</li><li> Comentar (con apóstrofo) las llamadas a las funciones de <code>orthopoly</code>.
</li></ol>
<p>Si las llamadas a las funciones no se comentan, Maxima las evalúa a 
polinomios antes de hacer el gráfico, por lo que el código especializado
en el cálculo numérico no es llamado. Aquí hay un ejemplo 
de cómo se debe hacer para representar gráficamente una expresión que
contiene un polinomio de Legendre:
</p>
<div class="example">
<pre class="example">(%i1) plot2d ('(legendre_p (5, x)), [x, 0, 1]),
      orthopoly_returns_intervals : false;
(%o1)
</pre></div>

<img src="./figures/orthopoly1.png" alt="./figures/orthopoly1">

<p>La expresión <code>legendre_p (5, x)</code> se comenta <i>completamente</i>, que no es 
lo mismo que comentar el nombre de la función, como en
<code>'legendre_p (5, <var>x</var>)</code>.
</p>
<a name="Miscelanea-de-funciones"></a>
<h4 class="subsection">69.1.5 Miscelánea de funciones</h4>

<p>El paquete <code>orthopoly</code> define el símbolo de Pochhammer y
la función de escalón unidad en sentencias gradef.
</p>
<p>Para convertir los símbolos de Pochhammer en cocientes o
funciones gamma, hágase uso de <code>makegamma</code>.
</p>
<div class="example">
<pre class="example">(%i1) makegamma (pochhammer (x, n));
                          gamma(x + n)
(%o1)                     ------------
                            gamma(x)
(%i2) makegamma (pochhammer (1/2, 1/2));
                                1
(%o2)                       ---------
                            sqrt(%pi)
</pre></div>

<p>Las derivadas del símbolo de Pochhammer se dan en
términos de la función <code>psi</code>.
</p>
<div class="example">
<pre class="example">(%i1) diff (pochhammer (x, n), x);
(%o1)             (x)  (psi (x + n) - psi (x))
                     n     0             0
(%i2) diff (pochhammer (x, n), n);
(%o2)                   (x)  psi (x + n)
                           n    0
</pre></div>

<p>Es necesario tener cuidado con la expresión en <code>(%o1)</code>, pues la diferencia
de las funciones <code>psi</code> tiene polos cuando <code><var>x</var> = -1, -2, .., -<var>n</var></code>.
Estos polos se cancelan con factores de <code>pochhammer (<var>x</var>, <var>n</var>)</code>
haciendo que la derivada sea un polinomio de grado <code><var>n</var> - 1</code> si <var>n</var>
es entero positivo.
</p>
<p>El símbolo de Pochhammer se define para órdenes negativos a
través de su representación como cociente de funciones gamma. Considérese
</p>
<div class="example">
<pre class="example">(%i1) q : makegamma (pochhammer (x, n));
                          gamma(x + n)
(%o1)                     ------------
                            gamma(x)
(%i2) sublis ([x=11/3, n= -6], q);
                               729
(%o2)                        - ----
                               2240
</pre></div>

<p>De forma alternativa, es posible llegar a este resultado directamente.
</p>
<div class="example">
<pre class="example">(%i1) pochhammer (11/3, -6);
                               729
(%o1)                        - ----
                               2240
</pre></div>

<p>La función de escalón unidad es continua por la izquierda; así,
</p>
<div class="example">
<pre class="example">(%i1) [unit_step (-1/10), unit_step (0), unit_step (1/10)];
(%o1)                       [0, 0, 1]
</pre></div>

<p>En caso de ser necesaria una función escalón unidad que no sea
continua ni por la izquierda ni por la derecha en el origen, se puede definir
haciendo uso de <code>signum</code>; por ejemplo,
</p>
<div class="example">
<pre class="example">(%i1) xunit_step (x) := (1 + signum (x))/2$

(%i2) [xunit_step (-1/10), xunit_step (0), xunit_step (1/10)];
                                1
(%o2)                       [0, -, 1]
                                2
</pre></div>

<p>No se debe redefinir la función <code>unit_step</code>, ya que parte del
código de <code>orthopoly</code> requiere que la función escalón sea
continua por la izquierda.
</p>
<a name="Algoritmos"></a>
<h4 class="subsection">69.1.6 Algoritmos</h4>

<p>En general, el paquete <code>orthopoly</code> gestiona la evaluación
simbólica a través de la representación hipergeométrica de 
los polinomios ortogonales. Las funciones hipergeométricas se
evalúan utilizando las funciones (no documentadas) <code>hypergeo11</code> 
y <code>hypergeo21</code>. Excepciones son las funciones de Bessel de
índice semi-entero y las funciones asociadas de 
Legendre de segunda especie; las funciones de Bessel de índice
semi-entero se evalúan 
utilizando una representación explícita, mientras que
la función asociada de Legendre de segunda especie se evalúa 
recursivamente.
</p>
<p>En cuanto a la evaluación numérica, la mayor parte de las funciones
se convierten a su forma hipergeométrica, evaluándolas mediante recursión.
Además, las excepciones son las funciones de Bessel de índice
semi-entero y las funciones asociadas de Legendre de segunda especie.
Las funciones de Bessel de índice semi-entero se evalúan 
numéricamente con código SLATEC.
</p>

<a name="Item_003a-orthopoly_002fnode_002fFunciones-y-variables-para-polinomios-ortogonales"></a><hr>
<div class="header">
<p>
Siguiente: <a href="maxima_266.html#Funciones-y-variables-para-polinomios-ortogonales" accesskey="n" rel="next">Funciones y variables para polinomios ortogonales</a>, Previous: <a href="maxima_264.html#orthopoly" accesskey="p" rel="previous">orthopoly</a>, Subir: <a href="maxima_264.html#orthopoly" accesskey="u" rel="up">orthopoly</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="&Iacute;ndice general" rel="contents">&Iacute;ndice general</a>][<a href="maxima_304.html#g_t_00cdndice-de-Funciones-y-Variables" title="&Iacute;ndice" rel="index">&Iacute;ndice</a>]</p>
</div>



</body>
</html>
