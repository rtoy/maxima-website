<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Manual de Maxima 5.46.0: Funciones y variables para ctensor</title>

<meta name="description" content="Manual de Maxima 5.46.0: Funciones y variables para ctensor">
<meta name="keywords" content="Manual de Maxima 5.46.0: Funciones y variables para ctensor">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="maxima_toc.html#Top" rel="start" title="Top">
<link href="maxima_304.html#g_t_00cdndice-de-Funciones-y-Variables" rel="index" title="Índice de Funciones y Variables">
<link href="maxima_toc.html#SEC_Contents" rel="contents" title="&Iacute;ndice General">
<link href="maxima_124.html#ctensor" rel="up" title="ctensor">
<link href="maxima_127.html#atensor" rel="next" title="atensor">
<link href="maxima_125.html#Introducci_00f3n-a-ctensor" rel="previous" title="Introducción a ctensor">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 1em; padding-bottom: 1em;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%; display: block; margin-left: auto; margin-right: auto}

-->
</style>

<link rel="icon" href="../figures/favicon.ico">

</head>

<body lang="es" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="Funciones-y-variables-para-ctensor"></a>
<div class="header">
<p>
Previous: <a href="maxima_125.html#Introducci_00f3n-a-ctensor" accesskey="p" rel="previous">Introducción a ctensor</a>, Subir: <a href="maxima_124.html#ctensor" accesskey="u" rel="up">ctensor</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="&Iacute;ndice general" rel="contents">&Iacute;ndice general</a>][<a href="maxima_304.html#g_t_00cdndice-de-Funciones-y-Variables" title="&Iacute;ndice" rel="index">&Iacute;ndice</a>]</p>
</div>
<a name="Funciones-y-variables-para-ctensor-1"></a>
<h3 class="section">26.2 Funciones y variables para ctensor</h3>

<a name="Inicializacion-y-preparacion"></a>
<h4 class="subsection">26.2.1 Inicialización y preparación</h4>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002fcsetup"></a><dl>
<dt><a name="index-csetup"></a>Función: <strong>csetup</strong> <em>()</em></dt>
<dd><p>Es la función del paquete <code>ctensor</code> que inicializa el paquete y permite al usuario introducir una métrica de forma interactiva. Véase <code>ctensor</code> para más detalles.
</p></dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002fcmetric"></a><dl>
<dt><a name="index-cmetric"></a>Función: <strong>cmetric</strong> <em>(<var>dis</var>)</em></dt>
<dt><a name="index-cmetric-1"></a>Función: <strong>cmetric</strong> <em>()</em></dt>
<dd><p>Es la función del paquete <code>ctensor</code> que calcula la métrica inversa y prepara el paquete para cálculos ulteriores.
</p>
<p>Si <code>cframe_flag</code> vale <code>false</code>, la función calcula la métrica inversa <code>ug</code> a partir de la matriz <code>lg</code> definida por el usuario. Se calcula también la métrica determinante y se almacena en la variable <code>gdet</code>. Además, el paquete determina si la métrica es diagonal y ajusta el valor de <code>diagmetric</code> de la forma apropiada. Si el argumento opcional <var>dis</var> está presente y no es igual a <code>false</code>, el usuario podrá ver la métrica inversa.
</p>
<p>Si <code>cframe_flag</code> vale <code>true</code>, la función espera que los valores de <code>fri</code> (la matriz del sistema de referencia inverso) y <code>lfg</code> (la matriz del sistema de referencia) estén definidos. A partir de ellos, se calculan la matriz del sistema de referencia <code>fr</code> y su métrica <code>ufg</code>.
</p>
</dd></dl>


<a name="Item_003a-Ctensor_002ees_002fdeffn_002fct_005fcoordsys"></a><dl>
<dt><a name="index-ct_005fcoordsys"></a>Función: <strong>ct_coordsys</strong> <em>(<var>sistema_coordenadas</var>, <var>extra_arg</var>)</em></dt>
<dt><a name="index-ct_005fcoordsys-1"></a>Función: <strong>ct_coordsys</strong> <em>(<var>sistema_coordenadas</var>)</em></dt>
<dd>
<p>Prepara un sistema de coordenadas predefinido y una métrica. El argumento <var>sistema_coordenadas</var> puede ser cualquiera de los siguientes símbolos:
</p>
<div class="example">
<pre class="example">
  Símbolo              Dim Coordenadas       Descripción/comentarios
  --------------------------------------------------------------------------------
  cartesian2d           2  [x,y]             Sistema de coordenadas cartesianas en 2D
  polar                 2  [r,phi]           Sistema de coordenadas polares
  elliptic              2  [u,v]             Sistema de coordenadas elípticas
  confocalelliptic      2  [u,v]             Coordenadas elípticas confocales
  bipolar               2  [u,v]             Sistema de coordenas bipolares
  parabolic             2  [u,v]             Sistema de coordenadas parabólicas
  cartesian3d           3  [x,y,z]           Sistema de coordenadas cartesianas en 3D
  polarcylindrical      3  [r,theta,z]       Polares en 2D con cilíndrica z
  ellipticcylindrical   3  [u,v,z]           Elípticas en 2D con cilíndrica z
  confocalellipsoidal   3  [u,v,w]           Elipsoidales confocales
  bipolarcylindrical    3  [u,v,z]           Bipolares en 2D con cilíndrica z
  paraboliccylindrical  3  [u,v,z]           Parabólicas en 2D con cilíndrica z
  paraboloidal          3  [u,v,phi]         Coordenadas paraboloidales
  conical               3  [u,v,w]           Coordenadas cónicas
  toroidal              3  [u,v,phi]         Coordenadas toroidales
  spherical             3  [r,theta,phi]     Sistema de coordenadas esféricas
  oblatespheroidal      3  [u,v,phi]         Coordenadas esferoidales obleadas
  oblatespheroidalsqrt  3  [u,v,phi]
  prolatespheroidal     3  [u,v,phi]         Coordenadas esferoidales prolatas
  prolatespheroidalsqrt 3  [u,v,phi]
  ellipsoidal           3  [r,theta,phi]     Coordenadas elipsoidales
  cartesian4d           4  [x,y,z,t]         Sistema de coordenadas cartesianas en 4D
  spherical4d           4  [r,theta,eta,phi] Sistema de coordenadas esféricas en 4D
  exteriorschwarzschild 4  [t,r,theta,phi]   Métrica de Schwarzschild
  interiorschwarzschild 4  [t,z,u,v]         Métrica interior de Schwarzschild
  kerr_newman           4  [t,r,theta,phi]   Métrica simétrica con carga axial

</pre></div>

<p>El argumento <code>sistema_coordenadas</code> puede ser también una lista de funciones de transformación, seguida de una lista que contenga los nombres de las coordenadas. Por ejemplo, se puede especificar una métrica esférica como se indica a continuación:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;ctensor&quot;);
(%o1)       /share/tensor/ctensor.mac
(%i2) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
      r*sin(theta),[r,theta,phi]]);
(%o2)                                done
(%i3) lg:trigsimp(lg);
                           [ 1  0         0        ]
                           [                       ]
                           [     2                 ]
(%o3)                      [ 0  r         0        ]
                           [                       ]
                           [         2    2        ]
                           [ 0  0   r  cos (theta) ]
(%i4) ct_coords;
(%o4)                           [r, theta, phi]
(%i5) dim;
(%o5)                                  3

</pre></div>

<p>Las funciones de transformación se pueden utilizar también si <code>cframe_flag</code> vale <code>true</code>:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;ctensor&quot;);
(%o1)       /share/tensor/ctensor.mac
(%i2) cframe_flag:true;
(%o2)                                true
(%i3) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
      r*sin(theta),[r,theta,phi]]);
(%o3)                                done
(%i4) fri;
      [ cos(phi) cos(theta)  - cos(phi) r sin(theta)  - sin(phi) r cos(theta) ]
      [                                                                       ]
(%o4) [ sin(phi) cos(theta)  - sin(phi) r sin(theta)   cos(phi) r cos(theta)  ]
      [                                                                       ]
      [     sin(theta)            r cos(theta)                   0            ]
(%i5) cmetric();
(%o5)                                false
(%i6) lg:trigsimp(lg);
                           [ 1  0         0        ]
                           [                       ]
                           [     2                 ]
(%o6)                      [ 0  r         0        ]
                           [                       ]
                           [         2    2        ]
                           [ 0  0   r  cos (theta) ]

</pre></div>

<p>El argumento opcional <var>extra_arg</var> puede ser cualquiera de los siguientes:
</p>
<p><code>cylindrical</code> indica a <code>ct_coordsys</code> que añada una coordenada cilíndrica más.
</p>
<p><code>minkowski</code> indica a  <code>ct_coordsys</code> que añada una coordenada más con signatura métrica negativa.
</p>
<p><code>all</code> indica a  <code>ct_coordsys</code> que llame a  <code>cmetric</code> y a <code>christof(false)</code> tras activar la métrica.
</p>
<p>Si la variable global <code>verbose</code> vale <code>true</code>, <code>ct_coordsys</code> muestra los valores de <code>dim</code>, <code>ct_coords</code>, junto con <code>lg</code> o <code>lfg</code> y <code>fri</code>, dependiendo del valor de <code>cframe_flag</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002finit_005fctensor"></a><dl>
<dt><a name="index-init_005fctensor"></a>Función: <strong>init_ctensor</strong> <em>()</em></dt>
<dd><p>Inicializa el paquete <code>ctensor</code>.
</p>
<p>La función <code>init_ctensor</code> reinicializa el paquete <code>ctensor</code>. Borra todos los arreglos (&quot;arrays&quot;) y matrices utilizados por <code>ctensor</code> y reinicializa todas las variables, asignando a <code>dim</code> el valor 4 y la métrica del sistema de referencia a la de Lorentz.
</p>
</dd></dl>

<a name="Los-tensores-del-espacio-curvo"></a>
<h4 class="subsection">26.2.2 Los tensores del espacio curvo</h4>

<p>El propósito principal del paquete <code>ctensor</code> es calcular los tensores del espacio (-tiempo) curvo, en especial los tensores utilizados en relatividad general.
</p>
<p>Cuando se utiliza una métrica, <code>ctensor</code> puede calcular los siguientes tensores:
</p>
<div class="example">
<pre class="example">
 lg  -- ug
   \      \
    lcs -- mcs -- ric -- uric 
              \      \       \
               \      tracer - ein -- lein
                \
                 riem -- lriem -- weyl
                     \
                      uriem


</pre></div>

<p>El paquete <code>ctensor</code> también puede trabajar con sistemas de referencia móviles. Si <code>cframe_flag</code> vale <code>true</code>, se pueden calcular los siguientes tensores:
</p>
<div class="example">
<pre class="example">
 lfg -- ufg
     \
 fri -- fr -- lcs -- mcs -- lriem -- ric -- uric
      \                       |  \      \       \
       lg -- ug               |   weyl   tracer - ein -- lein
                              |\
                              | riem
                              |
                              \uriem

</pre></div>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002fchristof"></a><dl>
<dt><a name="index-christof"></a>Función: <strong>christof</strong> <em>(<var>dis</var>)</em></dt>
<dd><p>Es una función del paquete <code>ctensor</code>. Calcula los símbolos de Christoffel de ambos tipos. El argumento <var>dis</var> determina qué resultados se mostrarán de forma inmediata. Los símbolos de Christoffel de primer y segundo tipo se almacenan en los arreglos  <code>lcs[i,j,k]</code> y <code>mcs[i,j,k]</code>, respectivamente, y se definen simétricos en sus dos primeros índices. Si el argumento de <code>christof</code> es <code>lcs</code> o <code>mcs</code> entonces serán mostrados únicamente los valores no nulos de <code>lcs[i,j,k]</code> o <code>mcs[i,j,k]</code>, respectivamente. Si el argumento es <code>all</code> entonces se mostrarán los valores no nulos de <code>lcs[i,j,k]</code> y <code>mcs[i,j,k]</code>.  Si el argumento vale <code>false</code> entonces no se mostrarán los elementos. El arreglo <code>mcs[i,j,k]</code> está definido de tal modo que el último índice es contravariante.
</p></dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002fricci"></a><dl>
<dt><a name="index-ricci"></a>Función: <strong>ricci</strong> <em>(<var>dis</var>)</em></dt>
<dd><p>Es una función del paquete <code>ctensor</code>. La función <code>ricci</code> calcula las componentes covariantes (simétricas) 
<code>ric[i,j]</code> del tensor de Ricci. Si el argumento <var>dis</var> vale <code>true</code>, entonces se muestran las componentes no nulas.
</p></dd></dl>


<a name="Item_003a-Ctensor_002ees_002fdeffn_002furicci"></a><dl>
<dt><a name="index-uricci"></a>Función: <strong>uricci</strong> <em>(<var>dis</var>)</em></dt>
<dd><p>Esta función calcula en primer lugar las componentes covariantes  <code>ric[i,j]</code> del tensor de Ricci. Después se calcula el tensor de Ricci utilizando la métrica contravariante. Si el valor del argumento <var>dis</var> vale <code>true</code>, entonces se mostrarán directamente las componentes <code>uric[i,j]</code> (el índice <var>i</var> es covariante y el <var>j</var> contravariante). En otro caso,  <code>ricci(false)</code> simplemente calculará las entradas del arreglo <code>uric[i,j]</code> sin mostrar los resultados.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002fscurvature"></a><dl>
<dt><a name="index-scurvature"></a>Función: <strong>scurvature</strong> <em>()</em></dt>
<dd>
<p>Devuelve la curvatura escalar (obtenida por contracción del tensor de Ricci) de la variedad de Riemannian con la métrica dada.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002feinstein"></a><dl>
<dt><a name="index-einstein"></a>Función: <strong>einstein</strong> <em>(<var>dis</var>)</em></dt>
<dd><p>Es una función del paquete <code>ctensor</code>. La función  <code>einstein</code> calcula el tensor de Einstein después de que los símbolos de  Christoffel y el tensor de Ricci hayan sido calculados (con las funciones <code>christof</code> y <code>ricci</code>).  Si el argumento <var>dis</var> vale <code>true</code>, entonces se mostrarán los valores no nulos del tensor de Einstein <code>ein[i,j]</code>, donde <code>j</code> es el índice contravariante. La variable <code>rateinstein</code> causará la simplificación racional de estas componentes. Si <code>ratfac</code> vale <code>true</code> entonces las componentes también se factorizarán.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002fleinstein"></a><dl>
<dt><a name="index-leinstein"></a>Función: <strong>leinstein</strong> <em>(<var>dis</var>)</em></dt>
<dd><p>Es el tensor covariante de Einstein. La función <code>leinstein</code> almacena los valores del tensor covariante de Einstein en el arreglo <code>lein</code>. El tensor covariante de Einstein se calcula a partir del tensor de Einstein <code>ein</code> multiplicándolo por el tensor métrico. Si el argumento  <var>dis</var> vale <code>true</code>, entonces se mostrarán los valores no nulos del tensor covariante de Einstein.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002friemann"></a><dl>
<dt><a name="index-riemann"></a>Función: <strong>riemann</strong> <em>(<var>dis</var>)</em></dt>
<dd><p>Es una función del paquete <code>ctensor</code>. La función <code>riemann</code> calcula el tensor de curvatura de Riemann a partir de la métrica dada y de los símbolos de Christoffel correspondientes. Se utiliza el siguiente convenio sobre los índices:
</p>
<div class="example">
<pre class="example">                l      _l       _l       _l   _m    _l   _m
 R[i,j,k,l] =  R    = |      - |      + |    |   - |    |
                ijk     ij,k     ik,j     mk   ij    mj   ik
</pre></div>

<p>Esta notación es consistente con la notación utilizada por el paquete <code>itensor</code> y su función <code>icurvature</code>. Si el argumento opcional <var>dis</var> vale <code>true</code>, se muestran las componentes no nulas únicas de <code>riem[i,j,k,l]</code>. Como en el caso del tensor de Einstein, ciertas variables permiten controlar al usuario la simplificación de las componentes del tensor de Riemann. Si  <code>ratriemann</code> vale <code>true</code>, entonces se hará la simplificación racional. Si <code>ratfac</code> vale <code>true</code>, entonces se factorizarán todas las componentes.
</p>
<p>Si la variable <code>cframe_flag</code> vale <code>false</code>, el tensor de Riemann se calcula directamente a partir de los símbolos de Christoffel. Si <code>cframe_flag</code> vale <code>true</code>, el tensor covariante de Riemann se calcula a partir de los coeficientes del campo.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002flriemann"></a><dl>
<dt><a name="index-lriemann"></a>Función: <strong>lriemann</strong> <em>(<var>dis</var>)</em></dt>
<dd><p>Es el tensor covariante de Riemann (<code>lriem[]</code>).
</p>
<p>Calcula el tensor covariante de Riemann como un arreglo <code>lriem</code>. Si el argumento <var>dis</var> vale <code>true</code>, sólo se muestran los valores no nulos.
</p>
<p>Si la variable <code>cframe_flag</code> vale <code>true</code>, el tensor covariante de Riemann se calcula directamente de los coeficientes del campo. En otro caso, el tensor de Riemann (3,1) se calcula en primer lugar.
</p>
<p>Para más información sobre la ordenación de los índices, véase <code>riemann</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002furiemann"></a><dl>
<dt><a name="index-uriemann"></a>Función: <strong>uriemann</strong> <em>(<var>dis</var>)</em></dt>
<dd><p>Calcula las componentes contravariantes del tensor de curvatura de Riemann como un arreglo <code>uriem[i,j,k,l]</code>.  Éstos se muestran si <var>dis</var> vale <code>true</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002frinvariant"></a><dl>
<dt><a name="index-rinvariant"></a>Función: <strong>rinvariant</strong> <em>()</em></dt>
<dd><p>Calcula la invariante de Kretchmann (<code>kinvariant</code>) obtenida por contracción de los tensores.
</p>
<div class="example">
<pre class="example">lriem[i,j,k,l]*uriem[i,j,k,l].
</pre></div>

<p>Este objeto no se simplifica automáticamente al ser en ocasiones muy grande.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002fweyl"></a><dl>
<dt><a name="index-weyl"></a>Función: <strong>weyl</strong> <em>(<var>dis</var>)</em></dt>
<dd><p>Calcula el tensor conforme de Weyl. Si el argumento <var>dis</var> vale <code>true</code>, se le mostrarán al usuario las componentes no nulas <code>weyl[i,j,k,l]</code>. En otro caso, estas componentes serán únicamente calculadas y almacenadas. Si la variable <code>ratweyl</code> vale <code>true</code>, entonces las componentes se simplifican racionalmente; si <code>ratfac</code> vale <code>true</code> los resultados también se simplificarán.
</p>
</dd></dl>

<a name="Desarrollo-de-Taylor"></a>
<h4 class="subsection">26.2.3 Desarrollo de Taylor</h4>

<p>El paquete <code>ctensor</code> puede truncar resultados e interpretarlos como aproximaciones de Taylor. Este comportamiento se controla con lavariable <code>ctayswitch</code>; cuando vale <code>true</code>, <code>ctensor</code> utiliza internamente la función <code>ctaylor</code> cuando simplifica resultados.
</p>
<p>La función <code>ctaylor</code> es llamada desde las siguientes funciones del paquete <code>ctensor</code>:
</p>
<div class="example">
<pre class="example">
    Función      Comentarios
    ---------------------------------
    christof()   Sólo para mcs
    ricci()
    uricci()
    einstein()
    riemann()
    weyl()
    checkdiv()
</pre></div>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002fctaylor"></a><dl>
<dt><a name="index-ctaylor"></a>Función: <strong>ctaylor</strong> <em>()</em></dt>
<dd>
<p>La función <code>ctaylor</code> trunca su argumento convirtiéndolo en un desarrollo de Taylor por medio de la función <code>taylor</code> e invocando después a <code>ratdisrep</code>. Esto tiene el efecto de eliminar términos de orden alto en la variable de expansión <code>ctayvar</code>. El orden de los términos que deben ser eliminados se define <code>ctaypov</code>; el punto alrededor del cual se desarrolla la serie se especifica en <code>ctaypt</code>.
</p>
<p>Como ejemplo, considérese una sencilla métrica que es una perturbación de la de Minkowski. Sin añadir restricciones, incluso una métrica diagonal produce expansiones del tensor de Einstein que pueden llegar a ser muy complejas:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;ctensor&quot;);
(%o1)       /share/tensor/ctensor.mac
(%i2) ratfac:true;
(%o2)                                true
(%i3) derivabbrev:true;
(%o3)                                true
(%i4) ct_coords:[t,r,theta,phi];
(%o4)                         [t, r, theta, phi]
(%i5) lg:matrix([-1,0,0,0],[0,1,0,0],[0,0,r^2,0],[0,0,0,r^2*sin(theta)^2]);
                        [ - 1  0  0         0        ]
                        [                            ]
                        [  0   1  0         0        ]
                        [                            ]
(%o5)                   [          2                 ]
                        [  0   0  r         0        ]
                        [                            ]
                        [              2    2        ]
                        [  0   0  0   r  sin (theta) ]
(%i6) h:matrix([h11,0,0,0],[0,h22,0,0],[0,0,h33,0],[0,0,0,h44]);
                            [ h11   0    0    0  ]
                            [                    ]
                            [  0   h22   0    0  ]
(%o6)                       [                    ]
                            [  0    0   h33   0  ]
                            [                    ]
                            [  0    0    0   h44 ]
(%i7) depends(l,r);
(%o7)                               [l(r)]
(%i8) lg:lg+l*h;
         [ h11 l - 1      0          0                 0            ]
         [                                                          ]
         [     0      h22 l + 1      0                 0            ]
         [                                                          ]
(%o8)    [                        2                                 ]
         [     0          0      r  + h33 l            0            ]
         [                                                          ]
         [                                    2    2                ]
         [     0          0          0       r  sin (theta) + h44 l ]
(%i9) cmetric(false);
(%o9)                                done
(%i10) einstein(false);
(%o10)                               done
(%i11) ntermst(ein);
[[1, 1], 62] 
[[1, 2], 0] 
[[1, 3], 0] 
[[1, 4], 0] 
[[2, 1], 0] 
[[2, 2], 24] 
[[2, 3], 0] 
[[2, 4], 0] 
[[3, 1], 0] 
[[3, 2], 0] 
[[3, 3], 46] 
[[3, 4], 0] 
[[4, 1], 0] 
[[4, 2], 0] 
[[4, 3], 0] 
[[4, 4], 46] 
(%o12)                               done

</pre></div>

<p>Sin embargo, si se recalcula este ejemplo como una aproximación lineal en la variable <code>l</code>, se obtienen expresiones más sencillas:
</p>
<div class="example">
<pre class="example">
(%i14) ctayswitch:true;
(%o14)                               true
(%i15) ctayvar:l;
(%o15)                                 l
(%i16) ctaypov:1;
(%o16)                                 1
(%i17) ctaypt:0;
(%o17)                                 0
(%i18) christof(false);
(%o18)                               done
(%i19) ricci(false);
(%o19)                               done
(%i20) einstein(false);
(%o20)                               done
(%i21) ntermst(ein);
[[1, 1], 6] 
[[1, 2], 0] 
[[1, 3], 0] 
[[1, 4], 0] 
[[2, 1], 0] 
[[2, 2], 13] 
[[2, 3], 2] 
[[2, 4], 0] 
[[3, 1], 0] 
[[3, 2], 2] 
[[3, 3], 9] 
[[3, 4], 0] 
[[4, 1], 0] 
[[4, 2], 0] 
[[4, 3], 0] 
[[4, 4], 9] 
(%o21)                               done
(%i22) ratsimp(ein[1,1]);
                         2      2  4               2     2
(%o22) - (((h11 h22 - h11 ) (l )  r  - 2 h33 l    r ) sin (theta)
                              r               r r

                                2               2      4    2
                  - 2 h44 l    r  - h33 h44 (l ) )/(4 r  sin (theta))
                           r r                r



</pre></div>

<p>Esta capacidad del paquete <code>ctensor</code> puede ser muy útil; por ejemplo, cuando se trabaja en zonas del campo gravitatorio alejadas del origen de éste.
</p>
</dd></dl>

<a name="Campos-del-sistema-de-referencia"></a>
<h4 class="subsection">26.2.4 Campos del sistema de referencia</h4>

<p>Cuando la variable <code>cframe_flag</code> vale <code>true</code>, el paquete <code>ctensor</code> realiza sus cálculos utilizando un sistema de referencia móvil.
</p>
<a name="Item_003a-Ctensor_002ees_002fdeffn_002fframe_005fbracket"></a><dl>
<dt><a name="index-frame_005fbracket"></a>Función: <strong>frame_bracket</strong> <em>(<var>fr</var>, <var>fri</var>, <var>diagframe</var>)</em></dt>
<dd><p>Es el sistema de referencia soporte (<code>fb[]</code>).
</p>
<p>Calcula el soporte del sistema de referencia de acuerdo con la siguiente definición:
</p>
<div class="example">
<pre class="example">   c          c         c        d     e
ifb   = ( ifri    - ifri    ) ifr   ifr
   ab         d,e       e,d      a     b
</pre></div>

</dd></dl>

<a name="Clasificacion-algebraica"></a>
<h4 class="subsection">26.2.5 Clasificación algebraica</h4>

<p>Una nueva funcionalidad (Noviembre de 2004) de <code>ctensor</code> es su capacidad de obtener la clasificación de Petrov de una métrica espaciotemporal de dimensión 4. Para una demostración de esto véase el fichero 
<code>share/tensor/petrov.dem</code>.
</p>
<a name="Item_003a-Ctensor_002ees_002fdeffn_002fnptetrad"></a><dl>
<dt><a name="index-nptetrad"></a>Función: <strong>nptetrad</strong> <em>()</em></dt>
<dd><p>Calcula la cuaterna nula de Newman-Penrose (<code>np</code>). Véase <code>petrov</code> para un ejemplo.
</p>
<p>La cuaterna nula se construye bajo la suposición de que se está utilizando una métrica tetradimensional ortonormal con signatura métrica (-,+,+,+). Los componentes de la cuaterna nula se relacionan con la inversa de la matriz del sistema de referencia de la siguiente manera:
</p>
<div class="example">
<pre class="example">
np  = (fri  + fri ) / sqrt(2)
  1       1      2

np  = (fri  - fri ) / sqrt(2)
  2       1      2

np  = (fri  + %i fri ) / sqrt(2)
  3       3         4

np  = (fri  - %i fri ) / sqrt(2)
  4       3         4

</pre></div>

</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002fpsi"></a><dl>
<dt><a name="index-psi-1"></a>Función: <strong>psi</strong> <em>(<var>dis</var>)</em></dt>
<dd><p>Calcula los cinco coeficientes de Newman-Penrose <code>psi[0]</code>...<code>psi[4]</code>.
Si <code>dis</code> vale <code>true</code>, se muestran estos coeficientes. 
Véase <code>petrov</code> para un ejemplo.
</p>
<p>Estos coeficientes se calculan a partir del tensor de Weyl.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002fpetrov"></a><dl>
<dt><a name="index-petrov"></a>Función: <strong>petrov</strong> <em>()</em></dt>
<dd><p>Calcula la clasificación de  Petrov de la métrica caracterizada por <code>psi[0]</code>...<code>psi[4]</code>.
</p>
<p>Por ejemplo, lo que sigue demuestra cómo obtener la clasificación de Petrov para la métrica de Kerr:
</p>
<div class="example">
<pre class="example">(%i1) load(&quot;ctensor&quot;);
(%o1)       /share/tensor/ctensor.mac
(%i2) (cframe_flag:true,gcd:spmod,ctrgsimp:true,ratfac:true);
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) ug:invert(lg)$
(%i5) weyl(false);
(%o5)                                done
(%i6) nptetrad(true);
(%t6) np = 

       [  sqrt(r - 2 m)           sqrt(r)                                     ]
       [ ---------------   ---------------------      0             0         ]
       [ sqrt(2) sqrt(r)   sqrt(2) sqrt(r - 2 m)                              ]
       [                                                                      ]
       [  sqrt(r - 2 m)            sqrt(r)                                    ]
       [ ---------------  - ---------------------     0             0         ]
       [ sqrt(2) sqrt(r)    sqrt(2) sqrt(r - 2 m)                             ]
       [                                                                      ]
       [                                              r      %i r sin(theta)  ]
       [        0                    0             -------   ---------------  ]
       [                                           sqrt(2)       sqrt(2)      ]
       [                                                                      ]
       [                                              r       %i r sin(theta) ]
       [        0                    0             -------  - --------------- ]
       [                                           sqrt(2)        sqrt(2)     ]

                             sqrt(r)          sqrt(r - 2 m)
(%t7) npi = matrix([- ---------------------, ---------------, 0, 0], 
                      sqrt(2) sqrt(r - 2 m)  sqrt(2) sqrt(r)

          sqrt(r)            sqrt(r - 2 m)
[- ---------------------, - ---------------, 0, 0], 
   sqrt(2) sqrt(r - 2 m)    sqrt(2) sqrt(r)

           1               %i
[0, 0, ---------, --------------------], 
       sqrt(2) r  sqrt(2) r sin(theta)

           1                 %i
[0, 0, ---------, - --------------------])
       sqrt(2) r    sqrt(2) r sin(theta)

(%o7)                                done
(%i7) psi(true);
(%t8)                              psi  = 0
                                      0

(%t9)                              psi  = 0
                                      1

                                          m
(%t10)                             psi  = --
                                      2    3
                                          r

(%t11)                             psi  = 0
                                      3

(%t12)                             psi  = 0
                                      4
(%o12)                               done
(%i12) petrov();
(%o12)                                 D

</pre></div>

<p>La función de clasificación de Petrov se basa en el algoritmo publicado en &quot;Classifying geometries in general relativity: III Classification in practice&quot; de Pollney, Skea, and d&rsquo;Inverno, Class. Quant. Grav. 17 2885-2902 (2000).
Excepto para algunos ejemplos sencillos, esta implementación no ha sido exhaustivamente probada, por lo que puede contener errores.
</p>
</dd></dl>

<a name="Torsion-y-no-metricidad-1"></a>
<h4 class="subsection">26.2.6 Torsión y no metricidad</h4>

<p>El paquete <code>ctensor</code> es capaz de calcular e incluir coeficientes de torsión y no metricidad en los coeficientes de conexión.
</p>
<p>Los coeficientes de torsión se calculan a partir de un tensor suministrado por el usuario, <code>tr</code>, el cual debe ser de rango (2,1). A partir de ahí, los coeficientes de torsión <code>kt</code> se calculan de acuerdo con las siguientes fórmulas:
</p>
<div class="example">
<pre class="example">
              m          m      m
       - g  tr   - g   tr   - tr   g
          im  kj    jm   ki     ij  km
kt   = -------------------------------
  ijk                 2


  k     km
kt   = g   kt
  ij         ijm

</pre></div>


<p>Los coeficientes de no metricidad se calculan a partir de un vector de no metricidad, <code>nm</code>, suministrado por el usuario. A partir de ahí, los coeficientes de no metricidad, <code>nmc</code>, se calculan como se indica a continuación:
</p>
<div class="example">
<pre class="example">
             k    k        km
       -nm  D  - D  nm  + g   nm  g
   k      i  j    i   j         m  ij
nmc  = ------------------------------
   ij                2

</pre></div>

<p>donde D es la delta de Kronecker.
</p>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002fcontortion"></a><dl>
<dt><a name="index-contortion"></a>Función: <strong>contortion</strong> <em>(<var>tr</var>)</em></dt>
<dd>
<p>Calcula los coeficientes (2,1) de contorsión del tensor de torsión <var>tr</var>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002fnonmetricity"></a><dl>
<dt><a name="index-nonmetricity"></a>Función: <strong>nonmetricity</strong> <em>(<var>nm</var>)</em></dt>
<dd>
<p>Calcula los coeficientes (2,1) de no metricidad del vector de no metricidad <var>nm</var>.
</p>
</dd></dl>

<a name="Otras-funcionalidades"></a>
<h4 class="subsection">26.2.7 Otras funcionalidades</h4>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002fctransform"></a><dl>
<dt><a name="index-ctransform"></a>Función: <strong>ctransform</strong> <em>(<var>M</var>)</em></dt>
<dd><p>Es una función del paquete <code>ctensor</code>.  Realiza una transformación de coordenadas a partir de una matriz cuadrada simétrica <var>M</var> arbitraria. El usuario debe introducir las funciones que definen la transformación.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002ffindde"></a><dl>
<dt><a name="index-findde"></a>Función: <strong>findde</strong> <em>(<var>A</var>, <var>n</var>)</em></dt>
<dd>
<p>Devuelve la lista de las ecuaciones diferenciales que corresponden a los elementos del arreglo cuadrado <var>n</var>-dimensional. El argumento <var>n</var> puede ser 2 ó 3; <code>deindex</code> es una lista global que contiene los índices de <var>A</var> que corresponden a estas ecuaciones diferenciales. Para el tensor de Einstein (<code>ein</code>), que es un arreglo bidimensional, si se calcula para la métrica del ejemplo de más abajo, <code>findde</code> devuelve las siguientes ecuaciones diferenciales independientes:
</p>
<div class="example">
<pre class="example">(%i1) load(&quot;ctensor&quot;);
(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;
(%o2)                                true
(%i3) dim:4;
(%o3)                                  4
(%i4) lg:matrix([a,0,0,0],[0,x^2,0,0],[0,0,x^2*sin(y)^2,0],[0,0,0,-d]);
                          [ a  0       0        0  ]
                          [                        ]
                          [     2                  ]
                          [ 0  x       0        0  ]
(%o4)                     [                        ]
                          [         2    2         ]
                          [ 0  0   x  sin (y)   0  ]
                          [                        ]
                          [ 0  0       0       - d ]
(%i5) depends([a,d],x);
(%o5)                            [a(x), d(x)]
(%i6) ct_coords:[x,y,z,t];
(%o6)                            [x, y, z, t]
(%i7) cmetric();
(%o7)                                done
(%i8) einstein(false);
(%o8)                                done
(%i9) findde(ein,2);
                                            2
(%o9) [d  x - a d + d, 2 a d d    x - a (d )  x - a  d d  x + 2 a d d
        x                     x x         x        x    x            x

                                                        2          2
                                                - 2 a  d , a  x + a  - a]
                                                     x      x
(%i10) deindex;
(%o10)                     [[1, 1], [2, 2], [4, 4]]

</pre></div>

</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002fcograd"></a><dl>
<dt><a name="index-cograd"></a>Función: <strong>cograd</strong> <em>()</em></dt>
<dd><p>Calcula el gradiente covariante de una función escalar permitiendo al usuario
elegir el nombre del vector correspondiente, tal como ilustra el ejemplo que acompaña
a la definición de la función <code>contragrad</code>.
</p></dd></dl>


<a name="Item_003a-Ctensor_002ees_002fdeffn_002fcontragrad"></a><dl>
<dt><a name="index-contragrad"></a>Function: <strong>contragrad</strong> <em>()</em></dt>
<dd>
<p>Calcula el gradiente contravariante de una función escalar permitiendo al usuario elegir el nombre del vector correspondiente, tal como muestra el siguiente ejemplo para la métrica de Schwarzschild:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;ctensor&quot;);
(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) depends(f,r);
(%o4)                               [f(r)]
(%i5) cograd(f,g1);
(%o5)                                done
(%i6) listarray(g1);
(%o6)                            [0, f , 0, 0]
                                      r
(%i7) contragrad(f,g2);
(%o7)                                done
(%i8) listarray(g2);
                               f  r - 2 f  m
                                r        r
(%o8)                      [0, -------------, 0, 0]
                                     r

</pre></div>

</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002fdscalar"></a><dl>
<dt><a name="index-dscalar"></a>Función: <strong>dscalar</strong> <em>()</em></dt>
<dd><p>Calcula el tensor de d&rsquo;Alembertian de la función escalar una vez se han declarado las dependencias. Por ejemplo:
</p>
<div class="example">
<pre class="example">(%i1) load(&quot;ctensor&quot;);
(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) depends(p,r);
(%o4)                               [p(r)]
(%i5) factor(dscalar(p));
                          2
                    p    r  - 2 m p    r + 2 p  r - 2 m p
                     r r           r r        r          r
(%o5)               --------------------------------------
                                       2
                                      r
</pre></div>

</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002fcheckdiv"></a><dl>
<dt><a name="index-checkdiv"></a>Función: <strong>checkdiv</strong> <em>()</em></dt>
<dd>
<p>Calcula la divergencia covariante del tensor de segundo rango (mixed second rank tensor), cuyo primer índice debe ser covariante, devolviendo las <code>n</code> componentes correspondientes del campo vectorial (la divergencia), siendo <code>n = dim</code>. </p></dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002fcgeodesic"></a><dl>
<dt><a name="index-cgeodesic"></a>Función: <strong>cgeodesic</strong> <em>(<var>dis</var>)</em></dt>
<dd><p>Es una función del paquete <code>ctensor</code> que calcula las ecuaciones geodésicas del movimiento para una métrica dada, las cuales se almacenan en el arreglo <code>geod[i]</code>. Si el argumento  <var>dis</var> vale <code>true</code> entonces se muestran estas ecuaciones.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002fbdvac"></a><dl>
<dt><a name="index-bdvac"></a>Función: <strong>bdvac</strong> <em>(<var>f</var>)</em></dt>
<dd>
<p>Genera las componentes covariantes de las ecuaciones del campo vacío de la teoría gravitacional de Brans- Dicke gravitational. El campo escalar se especifica con el argumento  <var>f</var>, el cual debe ser el nombre de una función no evaluada (precedida de apóstrofo) con dependencias funcionales, por ejemplo,  <code>'p(x)</code>.
</p>
<p>Las componentes del tensor covariante (second rank covariant field tensor) se almacenan en el arreglo <code>bd</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002finvariant1"></a><dl>
<dt><a name="index-invariant1"></a>Función: <strong>invariant1</strong> <em>()</em></dt>
<dd>
<p>Genera el tensor de Euler-Lagrange (ecuaciones de campo) para la densidad invariante de  R^2. Las ecuaciones de campo son las componentes del arreglo <code>inv1</code>.
</p>
</dd></dl>

<a name="Utilidades"></a>
<h4 class="subsection">26.2.8 Utilidades</h4>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002fdiagmatrixp"></a><dl>
<dt><a name="index-diagmatrixp"></a>Función: <strong>diagmatrixp</strong> <em>(<var>M</var>)</em></dt>
<dd>
<p>Devuelve <code>true</code> si <var>M</var> es una matriz diagonal o un arreglo bidimensional.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002fsymmetricp"></a><dl>
<dt><a name="index-symmetricp"></a>Función: <strong>symmetricp</strong> <em>(<var>M</var>)</em></dt>
<dd>
<p>Devuelve <code>true</code> si <var>M</var> es una matriz simétrica o un arreglo bidimensional.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002fntermst"></a><dl>
<dt><a name="index-ntermst"></a>Función: <strong>ntermst</strong> <em>(<var>f</var>)</em></dt>
<dd><p>Permite hacerse una idea del tamaño del tensor <var>f</var>. </p>
</dd></dl>


<a name="Item_003a-Ctensor_002ees_002fdeffn_002fcdisplay"></a><dl>
<dt><a name="index-cdisplay"></a>Función: <strong>cdisplay</strong> <em>(<var>ten</var>)</em></dt>
<dd><p>Muestra todos los elementos del tensor <var>ten</var> como arreglo multidimensional. Tensors de rango 0 y 1, así como otros tipos de variables, se muestran como en <code>ldisplay</code>. Tensors de rango 2 se muestran como matrices bidimensionales, mientras que tensores de mayor rango se muestran como listas de matrices bidimensionales. Por ejemplo, el tensor de Riemann de la métrica de Schwarzschild se puede ver como:
</p>
<div class="example">
<pre class="example">(%i1) load(&quot;ctensor&quot;);
(%o1)       /share/tensor/ctensor.mac
(%i2) ratfac:true;
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) riemann(false);
(%o4)                                done
(%i5) cdisplay(riem);
               [ 0               0                    0            0      ]
               [                                                          ]
               [                              2                           ]
               [      3 m (r - 2 m)   m    2 m                            ]
               [ 0  - ------------- + -- - ----       0            0      ]
               [            4          3     4                            ]
               [           r          r     r                             ]
               [                                                          ]
    riem     = [                                 m (r - 2 m)              ]
        1, 1   [ 0               0               -----------       0      ]
               [                                      4                   ]
               [                                     r                    ]
               [                                                          ]
               [                                              m (r - 2 m) ]
               [ 0               0                    0       ----------- ]
               [                                                   4      ]
               [                                                  r       ]

                                [    2 m (r - 2 m)       ]
                                [ 0  -------------  0  0 ]
                                [          4             ]
                                [         r              ]
                     riem     = [                        ]
                         1, 2   [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]

                                [         m (r - 2 m)    ]
                                [ 0  0  - -----------  0 ]
                                [              4         ]
                                [             r          ]
                     riem     = [                        ]
                         1, 3   [ 0  0        0        0 ]
                                [                        ]
                                [ 0  0        0        0 ]
                                [                        ]
                                [ 0  0        0        0 ]

                                [            m (r - 2 m) ]
                                [ 0  0  0  - ----------- ]
                                [                 4      ]
                                [                r       ]
                     riem     = [                        ]
                         1, 4   [ 0  0  0        0       ]
                                [                        ]
                                [ 0  0  0        0       ]
                                [                        ]
                                [ 0  0  0        0       ]

                               [       0         0  0  0 ]
                               [                         ]
                               [       2 m               ]
                               [ - ------------  0  0  0 ]
                    riem     = [    2                    ]
                        2, 1   [   r  (r - 2 m)          ]
                               [                         ]
                               [       0         0  0  0 ]
                               [                         ]
                               [       0         0  0  0 ]

                   [     2 m                                         ]
                   [ ------------  0        0               0        ]
                   [  2                                              ]
                   [ r  (r - 2 m)                                    ]
                   [                                                 ]
                   [      0        0        0               0        ]
                   [                                                 ]
        riem     = [                         m                       ]
            2, 2   [      0        0  - ------------        0        ]
                   [                     2                           ]
                   [                    r  (r - 2 m)                 ]
                   [                                                 ]
                   [                                         m       ]
                   [      0        0        0         - ------------ ]
                   [                                     2           ]
                   [                                    r  (r - 2 m) ]

                                [ 0  0       0        0 ]
                                [                       ]
                                [            m          ]
                                [ 0  0  ------------  0 ]
                     riem     = [        2              ]
                         2, 3   [       r  (r - 2 m)    ]
                                [                       ]
                                [ 0  0       0        0 ]
                                [                       ]
                                [ 0  0       0        0 ]

                                [ 0  0  0       0       ]
                                [                       ]
                                [               m       ]
                                [ 0  0  0  ------------ ]
                     riem     = [           2           ]
                         2, 4   [          r  (r - 2 m) ]
                                [                       ]
                                [ 0  0  0       0       ]
                                [                       ]
                                [ 0  0  0       0       ]

                                      [ 0  0  0  0 ]
                                      [            ]
                                      [ 0  0  0  0 ]
                                      [            ]
                           riem     = [ m          ]
                               3, 1   [ -  0  0  0 ]
                                      [ r          ]
                                      [            ]
                                      [ 0  0  0  0 ]

                                      [ 0  0  0  0 ]
                                      [            ]
                                      [ 0  0  0  0 ]
                                      [            ]
                           riem     = [    m       ]
                               3, 2   [ 0  -  0  0 ]
                                      [    r       ]
                                      [            ]
                                      [ 0  0  0  0 ]

                               [   m                      ]
                               [ - -   0   0       0      ]
                               [   r                      ]
                               [                          ]
                               [        m                 ]
                               [  0   - -  0       0      ]
                    riem     = [        r                 ]
                        3, 3   [                          ]
                               [  0    0   0       0      ]
                               [                          ]
                               [              2 m - r     ]
                               [  0    0   0  ------- + 1 ]
                               [                 r        ]

                                    [ 0  0  0    0   ]
                                    [                ]
                                    [ 0  0  0    0   ]
                                    [                ]
                         riem     = [            2 m ]
                             3, 4   [ 0  0  0  - --- ]
                                    [             r  ]
                                    [                ]
                                    [ 0  0  0    0   ]

                                [       0        0  0  0 ]
                                [                        ]
                                [       0        0  0  0 ]
                                [                        ]
                     riem     = [       0        0  0  0 ]
                         4, 1   [                        ]
                                [      2                 ]
                                [ m sin (theta)          ]
                                [ -------------  0  0  0 ]
                                [       r                ]

                                [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]
                                [                        ]
                     riem     = [ 0        0        0  0 ]
                         4, 2   [                        ]
                                [         2              ]
                                [    m sin (theta)       ]
                                [ 0  -------------  0  0 ]
                                [          r             ]

                              [ 0  0          0          0 ]
                              [                            ]
                              [ 0  0          0          0 ]
                              [                            ]
                   riem     = [ 0  0          0          0 ]
                       4, 3   [                            ]
                              [                2           ]
                              [         2 m sin (theta)    ]
                              [ 0  0  - ---------------  0 ]
                              [                r           ]

                 [        2                                             ]
                 [   m sin (theta)                                      ]
                 [ - -------------         0                0         0 ]
                 [         r                                            ]
                 [                                                      ]
                 [                         2                            ]
                 [                    m sin (theta)                     ]
      riem     = [        0         - -------------         0         0 ]
          4, 4   [                          r                           ]
                 [                                                      ]
                 [                                          2           ]
                 [                                   2 m sin (theta)    ]
                 [        0                0         ---------------  0 ]
                 [                                          r           ]
                 [                                                      ]
                 [        0                0                0         0 ]

(%o5)                                done

</pre></div>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdeffn_002fdeleten"></a><dl>
<dt><a name="index-deleten"></a>Función: <strong>deleten</strong> <em>(<var>L</var>, <var>n</var>)</em></dt>
<dd><p>Devuelve una nueva lista consistente en <var>L</var> sin su <var>n</var>-ésimo elemento.
</p></dd></dl>

<a name="Variables-utilizadas-por-ctensor"></a>
<h4 class="subsection">26.2.9 Variables utilizadas por <code>ctensor</code></h4>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002fdim"></a><dl>
<dt><a name="index-dim"></a>Variable opcional: <strong>dim</strong></dt>
<dd><p>Valor por defecto: 4
</p>
<p>Es la dimensión de la variedad, que por defecto será 4. La instrucción <code>dim: n</code> establecerá la dimensión a cualquier otro valor <code>n</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002fdiagmetric"></a><dl>
<dt><a name="index-diagmetric"></a>Variable opcional: <strong>diagmetric</strong></dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>diagmetric</code> vale <code>true</code> se utilizarán rutinas especiales para calcular todos los objetos geométricos teniendo en cuenta la diagonalidad de la métrica, lo que redundará en una reducción del tiempo de cálculo. Esta opción se fija automáticamente por <code>csetup</code> si se especifica una métrica diagonal.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002fctrgsimp"></a><dl>
<dt><a name="index-ctrgsimp"></a>Variable opcional: <strong>ctrgsimp</strong></dt>
<dd>
<p>Provoca que se realicen simplificaciones trigonométricas cuando se calculan tensores. La variable <code>ctrgsimp</code> afecta únicamente a aquellos cálculos que utilicen un sistema de referencia móvil.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002fcframe_005fflag"></a><dl>
<dt><a name="index-cframe_005fflag"></a>Variable opcional: <strong>cframe_flag</strong></dt>
<dd>
<p>Provoca que los cálculos se realicen respecto de un sistema de referencia móvil. </p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002fctorsion_005fflag"></a><dl>
<dt><a name="index-ctorsion_005fflag"></a>Variable opcional: <strong>ctorsion_flag</strong></dt>
<dd>
<p>Obliga a que se calcule también el tensor de contorsión junto con los coeficientes de conexión. El propio tensor de contorsión se calcula con la función <code>contortion</code> a partir del tensor <code>tr</code> suministrado por el usuario.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002fcnonmet_005fflag"></a><dl>
<dt><a name="index-cnonmet_005fflag"></a>Variable opcional: <strong>cnonmet_flag</strong></dt>
<dd>
<p>Obliga a que se calculen también los coeficientes de no metricidad junto con los coeficientes de conexión. Los coeficientes de no metricidad se calculan con la función <code>nonmetricity</code> a partir del vector de no metricidad<code>nm</code> suministrado por el usuario.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002fctayswitch"></a><dl>
<dt><a name="index-ctayswitch"></a>Variable opcional: <strong>ctayswitch</strong></dt>
<dd>
<p>Si vale <code>true</code>, obliga a que ciertos cálculos de <code>ctensor</code> se lleven a cabo utilizando desarrollos de series de 
Taylor. Estos cálculos hacen referencia a las funciones <code>christof</code>, <code>ricci</code>, <code>uricci</code>, <code>einstein</code> y <code>weyl</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002fctayvar"></a><dl>
<dt><a name="index-ctayvar"></a>Variable opcional: <strong>ctayvar</strong></dt>
<dd>
<p>Variable utilizada para desarrollos de Taylor cuando la variable <code>ctayswitch</code> vale <code>true</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002fctaypov"></a><dl>
<dt><a name="index-ctaypov"></a>Variable opcional: <strong>ctaypov</strong></dt>
<dd>
<p>Máximo exponente utilizado en los desarrollos de Taylor cuando <code>ctayswitch</code> vale <code>true</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002fctaypt"></a><dl>
<dt><a name="index-ctaypt"></a>Variable opcional: <strong>ctaypt</strong></dt>
<dd>
<p>Punto alrededor del cual se realiza un desarrollo de Taylor cuando <code>ctayswitch</code> vale <code>true</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002fgdet"></a><dl>
<dt><a name="index-gdet"></a>Variable opcional: <strong>gdet</strong></dt>
<dd>
<p>Es el determinante del tensor métrico <code>lg</code>, calculado por  <code>cmetric</code> cuando <code>cframe_flag</code> vale <code>false</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002fratchristof"></a><dl>
<dt><a name="index-ratchristof"></a>Variable opcional: <strong>ratchristof</strong></dt>
<dd>
<p>Obliga a que la función <code>christof</code> aplique la simplificación racional.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002frateinstein"></a><dl>
<dt><a name="index-rateinstein"></a>Variable opcional: <strong>rateinstein</strong></dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si vale <code>true</code> entonces se hará la simplificación racional en los componentes no nulos de los tensores de Einstein; si <code>ratfac</code> vale <code>true</code> entonces las componentes también serán factorizadas.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002fratriemann"></a><dl>
<dt><a name="index-ratriemann"></a>Variable opcional: <strong>ratriemann</strong></dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Es una de las variables que controlan la simplificación de los tensores de Riemann; si vale <code>true</code>, entonces se llevará a cabo la simplificación racional; si <code>ratfac</code> vale <code>true</code> entonces las componentes también serán factorizadas.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002fratweyl"></a><dl>
<dt><a name="index-ratweyl"></a>Variable opcional: <strong>ratweyl</strong></dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si vale <code>true</code>, entonces la función <code>weyl</code> llevará a cabo la simplificación racional de los valores del tensor de Weyl. si <code>ratfac</code> vale <code>true</code> entonces las componentes también serán factorizadas.
</p></dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002flfg"></a><dl>
<dt><a name="index-lfg"></a>Variable: <strong>lfg</strong></dt>
<dd><p>Es la covariante de la métrica del sistema de referencia. Por defecto, está inicializada al sistema de referencia tetradimensional de Lorentz con signatura  (+,+,+,-). Se utiliza cuando <code>cframe_flag</code> vale <code>true</code>.
</p></dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002fufg"></a><dl>
<dt><a name="index-ufg"></a>Variable: <strong>ufg</strong></dt>
<dd><p>Es la métrica del sistema de referencia inverso. La calcula <code>lfg</code> cuando <code>cmetric</code> es invocada tomando  <code>cframe_flag</code> el valor  <code>true</code>.
</p></dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002friem"></a><dl>
<dt><a name="index-riem"></a>Variable: <strong>riem</strong></dt>
<dd><p>Es el tensor (3,1) de Riemann. Se calcula cuando se invoca la función <code>riemann</code>. Para información sobre el indexado, véase la descripción de  <code>riemann</code>.
</p>
<p>Si <code>cframe_flag</code> vale <code>true</code>, <code>riem</code> se calcula a partir del tensor covariante de Riemann <code>lriem</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002flriem"></a><dl>
<dt><a name="index-lriem"></a>Variable: <strong>lriem</strong></dt>
<dd>
<p>Es el tensor covariante de Riemann. Lo calcula la función <code>lriemann</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002furiem"></a><dl>
<dt><a name="index-uriem"></a>Variable: <strong>uriem</strong></dt>
<dd>
<p>Es el tensor contravariante de Riemann. Lo calcula la función <code>uriemann</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002fric"></a><dl>
<dt><a name="index-ric"></a>Variable: <strong>ric</strong></dt>
<dd>
<p>Es el tensor de Ricci. Lo calcula la función <code>ricci</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002furic"></a><dl>
<dt><a name="index-uric"></a>Variable: <strong>uric</strong></dt>
<dd>
<p>Es el tensor contravariante de Ricci. Lo calcula la función <code>uricci</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002flg"></a><dl>
<dt><a name="index-lg"></a>Variable: <strong>lg</strong></dt>
<dd>
<p>Es el tensor métrico. Este tensor se debe especificar (como matriz cuadrada de orden <code>dim</code>) antes de que se hagan otros cálculos.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002fug"></a><dl>
<dt><a name="index-ug"></a>Variable: <strong>ug</strong></dt>
<dd>
<p>Es la inversa del tensor métrico. Lo calcula la función <code>cmetric</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002fweyl"></a><dl>
<dt><a name="index-weyl-1"></a>Variable: <strong>weyl</strong></dt>
<dd>
<p>Es el tensor de Weyl. Lo calcula la función <code>weyl</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002ffb"></a><dl>
<dt><a name="index-fb"></a>Variable: <strong>fb</strong></dt>
<dd>
<p>Son los coeficientes del sistema de referencia soporte, tal como los calcula <code>frame_bracket</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002fkinvariant"></a><dl>
<dt><a name="index-kinvariant"></a>Variable: <strong>kinvariant</strong></dt>
<dd>
<p>Es la invariante de Kretchmann, tal como la calcula la función <code>rinvariant</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002fnp"></a><dl>
<dt><a name="index-np"></a>Variable: <strong>np</strong></dt>
<dd>
<p>Es la cuaterna nula de Newman-Penrose, tal como la calcula la función <code>nptetrad</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002fnpi"></a><dl>
<dt><a name="index-npi"></a>Variable: <strong>npi</strong></dt>
<dd>
<p>Es la cuaterna nula &quot;raised-index Newman-Penrose&quot;. Lo calcula la función <code>nptetrad</code>.
Se define como <code>ug.np</code>. El producto <code>np.transpose(npi)</code> es constante:
</p>
<div class="example">
<pre class="example">(%i39) trigsimp(np.transpose(npi));
                              [  0   - 1  0  0 ]
                              [                ]
                              [ - 1   0   0  0 ]
(%o39)                        [                ]
                              [  0    0   0  1 ]
                              [                ]
                              [  0    0   1  0 ]
</pre></div>

</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002ftr"></a><dl>
<dt><a name="index-tr"></a>Variable: <strong>tr</strong></dt>
<dd>
<p>Tensor de rango 3 suministrado por el usuario y que representa una torsión. Lo utiliza la función <code>contortion</code>.
</p></dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002fkt"></a><dl>
<dt><a name="index-kt"></a>Variable: <strong>kt</strong></dt>
<dd>
<p>Es el tensor de contorsión, calculado a partir de <code>tr</code> por la función <code>contortion</code>.
</p></dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002fnm"></a><dl>
<dt><a name="index-nm"></a>Variable: <strong>nm</strong></dt>
<dd>
<p>Vector de no metricidad suministrado por el usuario. Lo utiliza la función <code>nonmetricity</code>.
</p></dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002fnmc"></a><dl>
<dt><a name="index-nmc"></a>Variable: <strong>nmc</strong></dt>
<dd>
<p>Son los coeficientes de no metricidad, calculados a partir de <code>nm</code> por la función <code>nonmetricity</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002ftensorkill"></a><dl>
<dt><a name="index-tensorkill"></a>Variable del sistema: <strong>tensorkill</strong></dt>
<dd>
<p>Variable que indica si el paquete de tensores se ha inicializado. Utilizada por <code>csetup</code> y reinicializada por <code>init_ctensor</code>.
</p>
</dd></dl>

<a name="Item_003a-Ctensor_002ees_002fdefvr_002fct_005fcoords"></a><dl>
<dt><a name="index-ct_005fcoords"></a>Variable opcional: <strong>ct_coords</strong></dt>
<dd><p>Valor por defecto: <code>[]</code>
</p>
<p>La variable <code>ct_coords</code> contiene una lista de coordenadas. Aunque se define normalmente cuando se llama a la función <code>csetup</code>, también se pueden redefinir las coordenadas con la asignación <code>ct_coords: [j1, j2, ..., jn]</code> donde  <code>j</code> es el nuevo nombre de las coordenadas. Véase también <code>csetup</code>.
</p>
</dd></dl>

<a name="Nombres-reservados"></a>
<h4 class="subsection">26.2.10 Nombres reservados</h4>

<p>Los siguientes nombres se utilizan internamente en el paquete <code>ctensor</code> y no deberían redefinirse:
</p>
<div class="example">
<pre class="example">  Nombre       Descripción
  ---------------------------------------
  _lg()        Toma el valor <code>lfg</code> si se utiliza métrica del sistema de referencia,
               <code>lg</code> en otro caso
  _ug()        Toma el valor <code>ufg</code> si se utiliza métrica del sistema de referencia,
               <code>ug</code> en otro caso
  cleanup()    Elimina elementos de la lista <code>deindex</code>
  contract4()  Utilizada por <code>psi()</code>
  filemet()    Utilizada por <code>csetup()</code> cuando se lee la métrica desde un fichero
  findde1()    Utilizada por <code>findde()</code>
  findde2()    Utilizada por <code>findde()</code>
  findde3()    Utilizada por <code>findde()</code>
  kdelt()      Delta de Kronecker (no generalizada)
  newmet()     Utilizada por <code>csetup()</code> para establecer una métrica interactivamente
  setflags()   Utilizada por <code>init_ctensor()</code>
  readvalue()
  resimp()
  sermet()     Utilizada por <code>csetup()</code> para definir una métrica como serie de Taylor
  txyzsum()
  tmetric()    Métrica del sistema de referencia, utilizada por <code>cmetric()</code>
               cuando <code>cframe_flag:true</code>
  triemann()   Tensor de Riemann en la base del sistema de referencia, se utiliza cuando
               <code>cframe_flag:true</code>
  tricci()     Tensor de Ricci en la base del sistema de referencia, se utiliza cuando
               <code>cframe_flag:true</code>
  trrc()       Coeficientes de rotación de Ricci, utilizada por <code>christof()</code>
  yesp()
</pre></div>



<hr>
<div class="header">
<p>
Previous: <a href="maxima_125.html#Introducci_00f3n-a-ctensor" accesskey="p" rel="previous">Introducción a ctensor</a>, Subir: <a href="maxima_124.html#ctensor" accesskey="u" rel="up">ctensor</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="&Iacute;ndice general" rel="contents">&Iacute;ndice general</a>][<a href="maxima_304.html#g_t_00cdndice-de-Funciones-y-Variables" title="&Iacute;ndice" rel="index">&Iacute;ndice</a>]</p>
</div>



</body>
</html>
