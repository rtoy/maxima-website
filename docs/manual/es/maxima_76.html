<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on octubre, 13 2014 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual de Maxima: 76. stringproc</title>

<meta name="description" content="Manual de Maxima: 76. stringproc">
<meta name="keywords" content="Manual de Maxima: 76. stringproc">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body
{
    color: black;
    background: white; 
    margin-left: 8%;
    margin-right: 13%;
}

h1
{
    margin-left: +8%;
    font-size: 150%;
    font-family: sans-serif
}

h2
{
    font-size: 125%;
    font-family: sans-serif
}

h3
{
    font-size: 100%;
    font-family: sans-serif
}

h2,h3,h4,h5,h6 { margin-left: +4%; }

div.textbox
{
    border: solid;
    border-width: thin;
    /* width: 100%; */
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em
}

div.titlebox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
    background: rgb(200,255,255);
    font-family: sans-serif
}

div.synopsisbox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
     background: rgb(255,220,255);
    /*background: rgb(200,255,255); */
    /* font-family: fixed */
}

pre.example
{
    border: 1px solid gray;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 1em;
    padding-right: 1em;
    /* background: rgb(247,242,180); */ /* kind of sandy */
    /* background: rgb(200,255,255); */ /* sky blue */
    background-color: #F1F5F9; /* light blue-gray */
    /* font-family: "Lucida Console", monospace */
}

div.spacerbox
{
    border: none;
    padding-top: 2em;
    padding-bottom: 2em
}

div.image
{
    margin: 0;
    padding: 1em;
    text-align: center;
}

div.categorybox
{
    border: 1px solid gray;
    padding-top: 0px;
    padding-bottom: 0px;
    padding-left: 1em;
    padding-right: 1em;
    background: rgb(247,242,220);
}


-->
</style>

<link rel="icon" href="figures/favicon.ico"/>
</head>

<body lang="es" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="stringproc"></a>
<a name="SEC359"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_75.html#SEC358" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC360" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_75.html#SEC357" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC364" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_81.html#SEC376" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 76. stringproc </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC360">76.1 Introducci&oacute;n al procesamiento de cadenas</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC361">76.2 Funciones y variables para entrada y salida</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC362">76.3 Funciones y variables para caracteres</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC363">76.4 Funciones y variables para cadenas</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Introducci_00f3n-al-procesamiento-de-cadenas"></a>
<a name="SEC360"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC359" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC361" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC359" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC359" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC364" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_81.html#SEC376" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 76.1 Introducci&oacute;n al procesamiento de cadenas </h2>

<p>El paquete <code>stringproc</code> ampl&iacute;a las capacidades de 
Maxima para manipular cadenas de caracteres, al tiempo que a&ntilde;ade algunas
funciones &uacute;tiles para la lectura y escritura de ficheros.
</p>
<p>Para dudas y fallos, por favor cont&aacute;ctese con <code>volkervannek at gmail dot com</code>.
</p>
<p>En Maxima, una cadena de caracteres se construye f&aacute;cilmente 
escribi&eacute;ndola entre comillas dobles, como en <code>&quot;texto&quot;</code>.
La funci&oacute;n <code>stringp</code> comprueba si el argumento es una cadena.
</p>
<pre class="example">(%i1) m: &quot;text&quot;;
(%o1)                         text
(%i2) stringp(m);
(%o2)                         true
</pre>
<p>Los caracteres se representan como cadenas de longitud unidad.
No se tratan como caracteres Lisp. Se pueden chequear con la
funci&oacute;n <code>charp</code> (o con <code>lcharp</code> para los caracteres Lisp).
La conversi&oacute;n de caracteres Lisp a caracteres Maxima se realiza con
la funci&oacute;n <code>cunlisp</code>.
</p>
<pre class="example">(%i1) c: &quot;e&quot;;
(%o1)                           e
(%i2) [charp(c),lcharp(c)];
(%o2)                     [true, false]
(%i3) supcase(c);
(%o3)                           E
(%i4) charp(%);
(%o4)                         true
</pre>
<p>Todos los caracteres devueltos por las funciones de <code>stringproc</code> son caracteres
de Maxima. Puesto que los caracteres introducidos son cadenas de longitud igual a
la unidad, se pueden utilizar las funciones de cadenas tambi&eacute;n para los 
caracteres, como se ha hecho con <code>supcase</code> en el anterior ejemplo.
</p>
<p>Es importante tener en cuenta que el primer car&aacute;cter en una cadena de Maxima
ocupa la posici&oacute;n 1. Esto se ha dise&ntilde;ado as&iacute; para mantener
la compatibilidad con las listas de Maxima. V&eacute;anse las definiciones de 
<code>charat</code> y <code>charlist</code> para ver ejemplos.
</p>
<p>Las funciones de cadena se utilizan frecuentemente cuando se trabaja con
ficheros. El siguiente ejemplo muestra algunas de estas funciones en acci&oacute;n.
</p>
<p>Ejemplo: 
</p>
<p>La funci&oacute;n <code>openw</code> env&iacute;a un flujo de salida hacia
un fichero, entonces <code>printf</code> permitir&aacute; formatera la escritura en
este fichero. V&eacute;ase <code>printf</code> para m&aacute;s detalles.
</p>
<pre class="example">(%i1) s: openw(&quot;E:/file.txt&quot;);
(%o1)                    #&lt;output stream E:/file.txt&gt;
(%i2) for n:0 thru 10 do printf( s, &quot;~d &quot;, fib(n) );
(%o2)                                done
(%i3) printf( s, &quot;~%~d ~f ~a ~a ~f ~e ~a~%&quot;, 
              42,1.234,sqrt(2),%pi,1.0e-2,1.0e-2,1.0b-2 );
(%o3)                                false
(%i4) close(s);
(%o4)                                true
</pre>
<p>Una vez cerrado el flujo, se podr&aacute; abrir nuevamente. La funci&oacute;n <code>readline</code>
devuelve el rengl&oacute;n entero como una &uacute;nica cadena. El paquete <code>stringproc</code>
dispone de muchas funciones para manipular cadenas. La separaci&oacute;n de palabras se
puede hacer con <code>split</code> o <code>tokens</code>.
</p>
<pre class="example">(%i5) s: openr(&quot;E:/file.txt&quot;);
(%o5)                     #&lt;input stream E:/file.txt&gt;
(%i6) readline(s);
(%o6)                     0 1 1 2 3 5 8 13 21 34 55 
(%i7) line: readline(s);
(%o7)               42 1.234 sqrt(2) %pi 0.01 1.0E-2 1.0b-2
(%i8) list: tokens(line);
(%o8)           [42, 1.234, sqrt(2), %pi, 0.01, 1.0E-2, 1.0b-2]
(%i9) map( parsetoken, list );
(%o9)           [42, 1.234, false, false, 0.01, 0.01, false]
</pre>
<p>La funci&oacute;n <code>parsetoken</code> s&oacute;lo analiza sint&aacute;cticamente n&uacute;meros
enteros y decimales. El an&aacute;lisis de s&iacute;mbolos y n&uacute;meros
decimales grandes (<i>big floats</i>) necesita <code>parse_string</code>, que se
cargar autom&aacute;ticamente desde <code>eval_string.lisp</code>.
</p>
<pre class="example">(%i5) s: openr(&quot;E:/file.txt&quot;);
(%o5)                     #&lt;input stream E:/file.txt&gt;
(%i6) readline(s);
(%o6)                     0 1 1 2 3 5 8 13 21 34 55 
(%i7) line: readline(s);
(%o7)               42 1.234 sqrt(2) %pi 0.01 1.0E-2 1.0b-2
(%i8) list: tokens(line);
(%o8)           [42, 1.234, sqrt(2), %pi, 0.01, 1.0E-2, 1.0b-2]
(%i9) map( parse_string, list );
(%o9)            [42, 1.234, sqrt(2), %pi, 0.01, 0.01, 1.0b-2]
(%i10) float(%);
(%o10) [42.0, 1.234, 1.414213562373095, 3.141592653589793, 0.01,
                                                     0.01, 0.01]
(%i11) readline(s);
(%o11)                               false
(%i12) close(s)$
</pre>
<p>La funci&oacute;n <code>readline</code> devuelve <code>false</code> cuando se alcanza el
final del fichero.
</p>

<hr size="6">
<a name="Funciones-y-variables-para-entrada-y-salida"></a>
<a name="SEC361"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC360" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC362" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC359" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC359" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC364" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_81.html#SEC376" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 76.2 Funciones y variables para entrada y salida </h2>

<p>Ejemplo: 
</p>
<pre class="example">(%i1) s: openw(&quot;E:/file.txt&quot;);
(%o1)                     #&lt;output stream E:/file.txt&gt;
(%i2) control: 
&quot;~2tAn atom: ~20t~a~%~2tand a list: ~20t~{~r ~}~%~2t\
           and an integer: ~20t~d~%&quot;$
(%i3) printf( s,control, 'true,[1,2,3],42 )$
(%o3)                                false
(%i4) close(s);
(%o4)                                true
(%i5) s: openr(&quot;E:/file.txt&quot;);
(%o5)                     #&lt;input stream E:/file.txt&gt;
(%i6) while stringp( tmp:readline(s) ) do print(tmp)$
  An atom:          true 
  and a list:       one two three  
  and an integer:   42 
(%i7) close(s)$
</pre>
<dl>
<dt><u>Funci&oacute;n:</u> <b>close</b><i> (<var>stream</var>) </i>
<a name="IDX2671"></a>
</dt>
<dd><p>Cierra el flujo de datos <var>stream</var> y devuelve <code>true</code> si <var>stream</var> hab&iacute;a
sido abierto. 
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>flength</b><i> (<var>stream</var>)</i>
<a name="IDX2672"></a>
</dt>
<dd><p>Devuelve el n&uacute;mero de elementos en <var>stream</var>,
el cual debe ser un flujo de datos desde o hacia un fichero.
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>fposition</b><i> (<var>stream</var>)</i>
<a name="IDX2673"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>fposition</b><i> (<var>stream</var>, <var>pos</var>)</i>
<a name="IDX2674"></a>
</dt>
<dd><p>Devuelve la posici&oacute;n actual en el flujo de datos <var>stream</var> si no se utiliza <var>pos</var>.
Si se utiliza <var>pos</var>, <code>fposition</code> fija la posici&oacute;n en <var>stream</var>.
<var>stream</var> debe ser un flujo de datos desde o hacia un fichero y <var>pos</var> 
debe ser un entero positivo que hace corresponder al primer elemento de
<var>stream</var> la posici&oacute;n 1.
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>freshline</b><i> () </i>
<a name="IDX2675"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>freshline</b><i> (<var>stream</var>) </i>
<a name="IDX2676"></a>
</dt>
<dd><p>Escribe una nueva l&iacute;nea (en el flujo de datos <var>stream</var>)
si la posici&oacute;n actual no corresponde al inicio de la l&iacute;nea.
</p>
<p>V&eacute;ase tambi&eacute;n <code>newline</code>.
</p></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>get_output_stream_string</b><i> (<var>stream</var>)</i>
<a name="IDX2677"></a>
</dt>
<dd><p>Devuelve una cadena con todos los caracteres presentes en <var>stream</var>,
que debe ser un flujo de datos de salida abiero.
Los caracteres devueltos son eliminados de <var>stream</var>.
</p>
<p>Para un ejemplo, v&eacute;ase <code>make_string_output_stream</code> .
</p></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>make_string_input_stream</b><i> (<var>string</var>)</i>
<a name="IDX2678"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>make_string_input_stream</b><i> (<var>string</var>, <var>start</var>)</i>
<a name="IDX2679"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>make_string_input_stream</b><i> (<var>string</var>, <var>start</var>, <var>end</var>)</i>
<a name="IDX2680"></a>
</dt>
<dd><p>Devuelve un flujo de entrada que contiene partes de <var>string</var> junto con
el car&aacute;cter de final de fichero. Sin argumentos opcionales, el flujo contiene
la cadena entera y se posiciona frente al primer car&aacute;cter.
Los argumentos <var>start</var> y <var>end</var> definen la subcadena contenida en el
flujo. El primer car&aacute;cter est&aacute; disponible en la posici&oacute;n 1.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) istream : make_string_input_stream(&quot;text&quot;, 1, 4);
(%o1)              #&lt;string-input stream from &quot;text&quot;&gt;
(%i2) (while (c : readchar(istream)) # false do sprint(c), newline())$
t e x 
(%i3) close(istream)$
</pre></dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>make_string_output_stream</b><i> ()</i>
<a name="IDX2681"></a>
</dt>
<dd><p>Devuelve un flujo de salida que acepta caracteres. Los caracteres de
este flujo podr&aacute;n obtenerse con <code>get_output_stream_string</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) ostream : make_string_output_stream();
(%o1)               #&lt;string-output stream 09622ea0&gt;
(%i2) printf(ostream, &quot;foo&quot;)$

(%i3) printf(ostream, &quot;bar&quot;)$

(%i4) string : get_output_stream_string(ostream);
(%o4)                            foobar
(%i5) printf(ostream, &quot;baz&quot;)$

(%i6) string : get_output_stream_string(ostream);
(%o6)                              baz
(%i7) close(ostream)$
</pre></dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>newline</b><i> () </i>
<a name="IDX2682"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>newline</b><i> (<var>stream</var>) </i>
<a name="IDX2683"></a>
</dt>
<dd><p>Escribe una nueva l&iacute;nea (en el flujo de datos  <var>stream</var>).
</p>
<p>V&eacute;ase <code>sprint</code> para un ejemplo de uso de <code>newline()</code>.
</p>
<p>N&oacute;tese que hay algunos casos en los que <code>newline</code> no trabaja
seg&uacute;n lo esperado.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>opena</b><i> (<var>file</var>) </i>
<a name="IDX2684"></a>
</dt>
<dd><p>Devuelve un flujo de datos al fichero <var>file</var>.
Si se abre un fichero ya existente, <code>opena</code> a&ntilde;ade elementos al final
del fichero.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>openr</b><i> (<var>file</var>) </i>
<a name="IDX2685"></a>
</dt>
<dd><p>Devuelve un flujo de datos de entrada al fichero <var>file</var>.
Si <var>file</var> no existe, ser&aacute; creado.
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>openw</b><i> (<var>file</var>) </i>
<a name="IDX2686"></a>
</dt>
<dd><p>Devuelve un flujo de datos de salida al fichero <var>file</var>.
Si <var>file</var> no existe, ser&aacute; creado.
Si se abre un fichero ya existente, <code>openw</code> lo modifica 
borrando el contenido anterior.
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>printf</b><i> (<var>dest</var>, <var>string</var>)</i>
<a name="IDX2687"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>printf</b><i> (<var>dest</var>, <var>string</var>, <var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX2688"></a>
</dt>
<dd><p>Genera una cadena de caracteres a partir de la cadena de control <var>string</var>,
teniendo en cuenta que las tildes introducen directivas. El car&aacute;cter que
va despu&eacute;s de la tilde, posiblemente precedido por par&aacute;metros y modificadores,
especifica el tipo de formato que se desea. La mayor parte de las directivas usan
uno o m&aacute;s elementos de los argumentos <var>expr_1</var>, ..., <var>expr_n</var>
para crear la salida.
</p>
<p>Si <var>dest</var> es un flujo o vale <code>true</code>, entonces <code>printf</code> devuelve <code>false</code>.
En otro caso, <code>printf</code> devuelve una cadena conteniendo la salida.
</p>
<p><code>printf</code> da acceso a la funci&oacute;n <code>format</code> de Common Lisp.
El siguiente ejemplo muestra la relaci&oacute;n entre estas dos funciones.
</p>
<pre class="example">(%i1) printf(true, &quot;R~dD~d~%&quot;, 2, 2);
R2D2
(%o1)                                false
(%i2) :lisp (format t &quot;R~dD~d~%&quot; 2 2)
R2D2
NIL
</pre>
<p>La siguiente descripci&oacute;n es un simple resumen de las posibilidades de <code>printf</code>.
La funci&oacute;n <code>format</code> de Common Lisp se encuentra descrita en detalle en muchas
referencias, como el manual libre &quot;Common Lisp the Language&quot; de Guy L. Steele; en
particular, el cap&iacute;tulo 22.3.3.
</p>
<pre class="example">   ~%       nueva l&iacute;nea
   ~&amp;       l&iacute;nea de refresco
   ~t       tabulaci&oacute;n
   ~$       moneda
   ~d       entero en base decimal
   ~b       entero en base binaria
   ~o       entero en base octal
   ~x       entero en base hexadecimal
   ~br      entero en base b
   ~r       deletrea un entero
   ~p       plural
   ~f       decimal en coma flotante
   ~e       notaci&oacute;n cient&iacute;fica
   ~g       ~f o ~e, dependiendo de la magnitud
   ~h       n&uacute;mero decimal grande (<i>bigfloat</i>)
   ~a       utiliza la funci&oacute;n <code>string</code> de Maxima
   ~s       como ~a, pero las cadenas se devuelven entre &quot;comillas dobles&quot;
   ~~       ~
   ~&lt;       justificaci&oacute;n, ~&gt; termina
   ~(       conversor may&uacute;scula/min&uacute;scula, ~) termina 
   ~[       selecci&oacute;n, ~] termina 
   ~{       iteraci&oacute;n, ~} termina
</pre>
<p>La directiva <code>~h</code> para n&uacute;meros decimales grandes no pertenece al est&aacute;ndar
de Lisp, por lo que se ilustra m&aacute;s abajo.
</p>
<p>La directiva <code>~*</code> no est&aacute; soportada.
</p>
<p>Ejemplos:
</p>
<p>Si <var>dest</var> es un flujo o vale <code>true</code>, entonces <code>printf</code> devuelve <code>false</code>.
En otro caso, <code>printf</code> devuelve una cadena conteniendo la salida.
</p>
<pre class="example">(%i1) printf( false, &quot;~a ~a ~4f ~a ~@r&quot;, 
              &quot;String&quot;,sym,bound,sqrt(12),144), bound = 1.234;
(%o1)                 String sym 1.23 2*sqrt(3) CXLIV
(%i2) printf( false,&quot;~{~a ~}&quot;,[&quot;one&quot;,2,&quot;THREE&quot;] );
(%o2)                          one 2 THREE 
(%i3) printf(true,&quot;~{~{~9,1f ~}~%~}&quot;,mat ),
          mat = args(matrix([1.1,2,3.33],[4,5,6],[7,8.88,9]))$
      1.1       2.0       3.3 
      4.0       5.0       6.0 
      7.0       8.9       9.0 
(%i4) control: &quot;~:(~r~) bird~p ~[is~;are~] singing.&quot;$
(%i5) printf( false,control, n,n,if n=1 then 1 else 2 ), n=2;
(%o5)                    Two birds are singing.
</pre>
<p>La directiva <code>~h</code> se ha introducido para formatear decimales grandes. 
</p>
<pre class="example">~w,d,e,x,o,p@H
 w : width
 d : decimal digits behind floating point
 e : minimal exponent digits
 x : preferred exponent
 o : overflow character
 p : padding character
 @ : display sign for positive numbers
</pre>
<pre class="example">(%i1) fpprec : 1000$
(%i2) printf(true, &quot;|~h|~%&quot;, 2.b0^-64)$
|0.0000000000000000000542101086242752217003726400434970855712890625|
(%i3) fpprec : 26$
(%i4) printf(true, &quot;|~h|~%&quot;, sqrt(2))$
|1.4142135623730950488016887|
(%i5) fpprec : 24$
(%i6) printf(true, &quot;|~h|~%&quot;, sqrt(2))$
|1.41421356237309504880169|
(%i7) printf(true, &quot;|~28h|~%&quot;, sqrt(2))$
|   1.41421356237309504880169|
(%i8) printf(true, &quot;|~28,,,,,'*h|~%&quot;, sqrt(2))$
|***1.41421356237309504880169|
(%i9) printf(true, &quot;|~,18h|~%&quot;, sqrt(2))$
|1.414213562373095049|
(%i10) printf(true, &quot;|~,,,-3h|~%&quot;, sqrt(2))$
|1414.21356237309504880169b-3|
(%i11) printf(true, &quot;|~,,2,-3h|~%&quot;, sqrt(2))$
|1414.21356237309504880169b-03|
(%i12) printf(true, &quot;|~20h|~%&quot;, sqrt(2))$
|1.41421356237309504880169|
(%i13) printf(true, &quot;|~20,,,,'+h|~%&quot;, sqrt(2))$
|++++++++++++++++++++|
</pre></dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>readchar</b><i> (<var>stream</var>)</i>
<a name="IDX2689"></a>
</dt>
<dd><p>Elimina y devuelve el primer car&aacute;cter de <var>stream</var>. 
Si se ha alcanzado el final del fichero, <code>readchar</code> devuelve <code>false</code>.
</p>
<p>Para un ejemplo, v&eacute;ase <code>make_string_input_stream</code>.
</p></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>readline</b><i> (<var>stream</var>) </i>
<a name="IDX2690"></a>
</dt>
<dd><p>Devuelve una cadena con los caracteres desde la posici&oacute;n actual en el flujo
de datos <var>stream</var> hasta el final de la l&iacute;nea, o <code>false</code>
si se ha alcanzado el final del fichero.
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>sprint</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX2691"></a>
</dt>
<dd><p>Eval&uacute;a y muestra sus argumentos uno tras otro en un rengl&oacute;n comenzando por 
su extremo izquierdo. 
</p>
<p>La funci&oacute;n <code>newline()</code>, que se carga autom&aacute;ticamente desde <code>stringproc.lisp</code>,
puede ser de utilidad si se quiere intercalar un salto de l&iacute;nea.
</p>
<pre class="example">(%i1) for n:0 thru 19 do sprint( fib(n) )$
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181
(%i2) for n:0 thru 22 do ( 
         sprint(fib(n)), if mod(n,10)=9 then newline() )$
0 1 1 2 3 5 8 13 21 34 
55 89 144 233 377 610 987 1597 2584 4181 
6765 10946 17711 
</pre>
</dd></dl>

<hr size="6">
<a name="Funciones-y-variables-para-caracteres"></a>
<a name="SEC362"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC361" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC363" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC359" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC359" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC364" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_81.html#SEC376" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 76.3 Funciones y variables para caracteres </h2>

<dl>
<dt><u>Funci&oacute;n:</u> <b>alphacharp</b><i> (<var>char</var>)</i>
<a name="IDX2692"></a>
</dt>
<dd><p>Devuelve <code>true</code> si <var>char</var> es una car&aacute;cter alfab&eacute;tico.
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>alphanumericp</b><i> (<var>char</var>) </i>
<a name="IDX2693"></a>
</dt>
<dd><p>Devuelve <code>true</code> si <var>char</var> es una car&aacute;cter alfab&eacute;tico o
un d&iacute;gito.
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>ascii</b><i> (<var>int</var>)</i>
<a name="IDX2694"></a>
</dt>
<dd><p>Devuelve el car&aacute;cter correspondiente al n&uacute;mero ASCII <var>int</var>,
debiendo ser <em>-1 &lt; int &lt; 256</em>.
</p>
<pre class="example">(%i1) for n from 0 thru 255 do ( 
  tmp: ascii(n),
  if alphacharp(tmp) then sprint(tmp), if n=96 then newline() )$
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
a b c d e f g h i j k l m n o p q r s t u v w x y z
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>cequal</b><i> (<var>char_1</var>, <var>char_2</var>)          </i>
<a name="IDX2695"></a>
</dt>
<dd><p>Devuelve <code>true</code> si <var>char_1</var> y <var>char_2</var> son el mismo car&aacute;cter. 
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>cequalignore</b><i> (<var>char_1</var>, <var>char_2</var>)</i>
<a name="IDX2696"></a>
</dt>
<dd><p>Como <code>cequal</code>, pero ignora si las letras est&aacute;n en may&uacute;sculas o
min&uacute;sculas.
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>cgreaterp</b><i> (<var>char_1</var>, <var>char_2</var>)    </i>
<a name="IDX2697"></a>
</dt>
<dd><p>Devuelve  <code>true</code> si el n&uacute;mero ASCII de <var>char_1</var> es mayor que el 
de <var>char_2</var>. 
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>cgreaterpignore</b><i> (<var>char_1</var>, <var>char_2</var>)</i>
<a name="IDX2698"></a>
</dt>
<dd><p>Como <code>cgreaterp</code>, pero ignora si las letras est&aacute;n en may&uacute;sculas o
min&uacute;sculas.
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>charp</b><i> (<var>obj</var>)</i>
<a name="IDX2699"></a>
</dt>
<dd><p>Devuelve <code>true</code> si <var>obj</var> es un car&aacute;cter de Maxima.
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>cint</b><i> (<var>char</var>) </i>
<a name="IDX2700"></a>
</dt>
<dd><p>Devuelve el n&uacute;mero ASCII de <var>char</var>.
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>clessp</b><i> (<var>char_1</var>, <var>char_2</var>)</i>
<a name="IDX2701"></a>
</dt>
<dd><p>Devuelve  <code>true</code> si el n&uacute;mero ASCII de <var>char_1</var> es menor que el 
de <var>char_2</var>.  
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>clesspignore</b><i> (<var>char_1</var>, <var>char_2</var>)</i>
<a name="IDX2702"></a>
</dt>
<dd><p>Como <code>clessp</code>, pero ignora si las letras est&aacute;n en may&uacute;sculas o
min&uacute;sculas.
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>constituent</b><i> (<var>char</var>)</i>
<a name="IDX2703"></a>
</dt>
<dd><p>Devuelve <code>true</code> si <var>char</var> es un car&aacute;cter gr&aacute;fico y no el
car&aacute;cter espacio. Un car&aacute;cter gr&aacute;fico es el que se puede ver y con un
espacio a&ntilde;adido; <code>constituent</code> est&aacute; definido por Paul Graham,
ANSI Common Lisp, 1996, page 67.
</p>
<pre class="example">(%i1) for n from 0 thru 255 do ( 
tmp: ascii(n), if constituent(tmp) then sprint(tmp) )$
! &quot; #  %  ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; &lt; = &gt; ? @ A B
C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c
d e f g h i j k l m n o p q r s t u v w x y z { | } ~
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>cunlisp</b><i> (<var>lisp_char</var>) </i>
<a name="IDX2704"></a>
</dt>
<dd><p>Convierte un car&aacute;cter Lisp en uno de Maxima. El uso de esta funci&oacute;n por
parte del usuario no ser&aacute; necesario.
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>digitcharp</b><i> (<var>char</var>)    </i>
<a name="IDX2705"></a>
</dt>
<dd><p>Devuelve <code>true</code> si <var>char</var> es un d&iacute;gito. 
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>lcharp</b><i> (<var>obj</var>) </i>
<a name="IDX2706"></a>
</dt>
<dd><p>Devuelve <code>true</code> si <var>obj</var> es un car&aacute;cter de Lisp.
El uso de esta funci&oacute;n por parte del usuario no ser&aacute; necesario.
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>lowercasep</b><i> (<var>char</var>)  </i>
<a name="IDX2707"></a>
</dt>
<dd><p>Devuelve  <code>true</code> si <var>char</var> es un car&aacute;cter en min&uacute;scula.
</p></dd></dl>

<dl>
<dt><u>Variable:</u> <b>newline</b>
<a name="IDX2708"></a>
</dt>
<dd><p>El car&aacute;cter de nueva l&iacute;nea. 
</p></dd></dl>

<dl>
<dt><u>Variable:</u> <b>space</b>
<a name="IDX2709"></a>
</dt>
<dd><p>El car&aacute;cter de espacio.
</p></dd></dl>

<dl>
<dt><u>Variable:</u> <b>tab</b>
<a name="IDX2710"></a>
</dt>
<dd><p>El car&aacute;cter de tabulaci&oacute;n.
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>uppercasep</b><i> (<var>char</var>)  </i>
<a name="IDX2711"></a>
</dt>
<dd><p>Devuelve <code>true</code> si <var>char</var> es un car&aacute;cter en may&uacute;scula.
</p></dd></dl>

<hr size="6">
<a name="Funciones-y-variables-para-cadenas"></a>
<a name="SEC363"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC362" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC364" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC359" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC359" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC364" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_81.html#SEC376" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 76.4 Funciones y variables para cadenas </h2>



<dl>
<dt><u>Funci&oacute;n:</u> <b>base64</b><i> (<var>string</var>)</i>
<a name="IDX2712"></a>
</dt>
<dd><p>Devuelve la representaci&oacute;n en base 64 de <var>string</var> en formato de
cadena de caracteres.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) base64 : base64(&quot;foo bar baz&quot;);
(%o1)                       Zm9vIGJhciBiYXo=
(%i2) string : base64_decode(base64);
(%o2)                          foo bar baz
</pre></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>base64_decode</b><i> (<var>base64-string</var>)</i>
<a name="IDX2713"></a>
</dt>
<dd><p>Decodifica la cadena de caracteres <var>base64-string</var>, codificada
en base 64, y devuelve la cadena original.
</p>
<p>Para un ejemplo, v&eacute;ase <code>base64</code>.
</p></dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>charat</b><i> (<var>string</var>, <var>n</var>)</i>
<a name="IDX2714"></a>
</dt>
<dd><p>Devuelve el <var>n</var>-&eacute;simo car&aacute;cter de <var>string</var>.
Al primer car&aacute;cter de <var>string</var> le corresponde <var>n</var> = 1.
</p>
<pre class="example">(%i1) charat(&quot;Lisp&quot;,1);
(%o1)                           L
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>charlist</b><i> (<var>string</var>) </i>
<a name="IDX2715"></a>
</dt>
<dd><p>Devuelve una lista con todos los caracteres de <var>string</var>. 
</p>
<pre class="example">(%i1) charlist(&quot;Lisp&quot;);
(%o1)                     [L, i, s, p]
(%i2) %[1];
(%o2)                           L
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>eval_string</b><i> (<var>str</var>)</i>
<a name="IDX2716"></a>
</dt>
<dd><p>Analiza sint&aacute;cticamente la cadena <var>str</var> como una expresi&oacute;n de Maxima
y la eval&uacute;a. La cadena <var>str</var> puede terminar o no con cualquiera de los 
s&iacute;mbolos de final de sentencia (d&oacute;lar <code>$</code> o punto y coma <code>;</code>).
S&oacute;lo se analiza la primera expresi&oacute;n si hay m&aacute;s de una.
</p>
<p>Se emitir&aacute; un mensaje de error si <var>str</var> no es una cadena.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) eval_string (&quot;foo: 42; bar: foo^2 + baz&quot;);
(%o1)                       42
(%i2) eval_string (&quot;(foo: 42, bar: foo^2 + baz)&quot;);
(%o2)                   baz + 1764
</pre>
<p>V&eacute;ase tambi&eacute;n <code>parse_string</code>.
</p></dd></dl>





<dl>
<dt><u>Funci&oacute;n:</u> <b>md5sum</b><i> (<var>string</var>)</i>
<a name="IDX2717"></a>
</dt>
<dd><p>Devuelve, en formato de cadena de caracteres, el resultado de la suma de verificaci&oacute;n
md5 del argumento <var>string</var>. Para obtener el valor devuelto por la funci&oacute;n como
n&uacute;mero entero, fijar la base num&eacute;rica de entrada a 16 y a~nadir como prefijo
el cero.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) string : md5sum(&quot;foo bar baz&quot;);
(%o1)                  ab07acbb1e496801937adfa772424bf7
(%i2) ibase : obase : 16.$

(%i3) integer : parse_string(sconcat(0, string));
(%o3)                 0ab07acbb1e496801937adfa772424bf7
</pre></dd></dl>






<dl>
<dt><u>Funci&oacute;n:</u> <b>parse_string</b><i> (<var>str</var>)</i>
<a name="IDX2718"></a>
</dt>
<dd><p>Analiza sint&aacute;cticamente la cadena <var>str</var> como una expresi&oacute;n de Maxima,
pero no la eval&uacute;a. La cadena <var>str</var> puede terminar o no con cualquiera de los 
s&iacute;mbolos de final de sentencia (d&oacute;lar <code>$</code> o punto y coma <code>;</code>).
S&oacute;lo se analiza la primera expresi&oacute;n si hay m&aacute;s de una.
</p>
<p>Se emitir&aacute; un mensaje de error si <var>str</var> no es una cadena.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) parse_string (&quot;foo: 42; bar: foo^2 + baz&quot;);
(%o1)                    foo : 42
(%i2) parse_string (&quot;(foo: 42, bar: foo^2 + baz)&quot;);
                                   2
(%o2)          (foo : 42, bar : foo  + baz)
</pre>
<p>V&eacute;ase tambi&eacute;n <code>eval_string</code>.
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>scopy</b><i> (<var>string</var>) </i>
<a name="IDX2719"></a>
</dt>
<dd><p>Devuelve una copia nueva de la cadena <var>string</var>. 
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>sdowncase</b><i> (<var>string</var>) </i>
<a name="IDX2720"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>sdowncase</b><i> (<var>string</var>, <var>start</var>) </i>
<a name="IDX2721"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>sdowncase</b><i> (<var>string</var>, <var>start</var>, <var>end</var>) </i>
<a name="IDX2722"></a>
</dt>
<dd><p>Convierte caracteres en min&uacute;scula a may&uacute;scula. V&eacute;ase tambi&eacute;n <code>supcase</code>.
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>sequal</b><i> (<var>string_1</var>, <var>string_2</var>) </i>
<a name="IDX2723"></a>
</dt>
<dd><p>Devuelve <code>true</code> si <var>string_1</var> y <var>string_2</var> son dos cadenas de caracteres iguales. 
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>sequalignore</b><i> (<var>string_1</var>, <var>string_2</var>)</i>
<a name="IDX2724"></a>
</dt>
<dd><p>Igual que <code>sequal</code> pero no diferencia entre min&uacute;sculas y may&uacute;sculas.. 
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>sexplode</b><i> (<var>string</var>)</i>
<a name="IDX2725"></a>
</dt>
<dd><p>El nombre <code>sexplode</code> es un seud&oacute;nimo de la funci&oacute;n <code>charlist</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>simplode</b><i> (<var>list</var>)  </i>
<a name="IDX2726"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>simplode</b><i> (<var>list</var>, <var>delim</var>)  </i>
<a name="IDX2727"></a>
</dt>
<dd><p>La funci&oacute;n <code>simplode</code> admite como entrada una lista de expresiones para
luego convertirla en una cadena de caracteres. Si no se utiliza la opci&oacute;n <var>delim</var>
para indicar el delimitador, entonces <code>simplode</code> no 
hace uso de ninguno. El valor de <var>delim</var> puede ser cualquier cadena.
</p>
<pre class="example">(%i1) simplode([&quot;xx[&quot;,3,&quot;]:&quot;,expand((x+y)^3)]);
(%o1)             xx[3]:y^3+3*x*y^2+3*x^2*y+x^3
(%i2) simplode( sexplode(&quot;stars&quot;),&quot; * &quot; );
(%o2)                   s * t * a * r * s
(%i3) simplode( [&quot;One&quot;,&quot;more&quot;,&quot;coffee.&quot;],&quot; &quot; );
(%o3)                   One more coffee.
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>sinsert</b><i> (<var>seq</var>, <var>string</var>, <var>pos</var>) </i>
<a name="IDX2728"></a>
</dt>
<dd><p>Devuelve la concatenaci&oacute;n de las cadenas <code>substring (<var>string</var>, 1, <var>pos</var> - 1)</code>,
<var>seq</var> y <code>substring (<var>string</var>, <var>pos</var>)</code>.
N&oacute;tese que al primer car&aacute;cter de <var>string</var> le corresponde la posici&oacute;n 1.
</p>
<pre class="example">(%i1) s: &quot;A submarine.&quot;$
(%i2) concat( substring(s,1,3),&quot;yellow &quot;,substring(s,3) );
(%o2)                  A yellow submarine.
(%i3) sinsert(&quot;hollow &quot;,s,3);
(%o3)                  A hollow submarine.
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>sinvertcase</b><i> (<var>string</var>)  </i>
<a name="IDX2729"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>sinvertcase</b><i> (<var>string</var>, <var>start</var>)  </i>
<a name="IDX2730"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>sinvertcase</b><i> (<var>string</var>, <var>start</var>, <var>end</var>)  </i>
<a name="IDX2731"></a>
</dt>
<dd><p>Devuelve la misma cadena <var>string</var> pero con todos sus caracteres desde la
posici&oacute;n <var>start</var> hasta <var>end</var> invertidos, esto es, las
may&uacute;sculas se convierten en min&uacute;sculas y &eacute;stas en may&uacute;sculas.
Si no se incluye el argumento <var>end</var>, se invierten todos los caracteres 
desde <var>start</var> hasta el final de la cadena.
</p>

<pre class="example">(%i1) sinvertcase(&quot;sInvertCase&quot;);
(%o1)                      SiNVERTcASE
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>slength</b><i> (<var>string</var>) </i>
<a name="IDX2732"></a>
</dt>
<dd><p>Devuelve el n&uacute;mero de caracteres de <var>string</var>. 
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>smake</b><i> (<var>num</var>, <var>char</var>) </i>
<a name="IDX2733"></a>
</dt>
<dd><p>Construye una cadena de longitud <var>num</var> con todos sus
caracteres iguales a <var>char</var>. 
</p>
<pre class="example">(%i1) smake(3,&quot;w&quot;);
(%o1)                          www
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>smismatch</b><i> (<var>string_1</var>, <var>string_2</var>) </i>
<a name="IDX2734"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>smismatch</b><i> (<var>string_1</var>, <var>string_2</var>, <var>test</var>) </i>
<a name="IDX2735"></a>
</dt>
<dd><p>Devuelve la posici&oacute;n del primer car&aacute;cter de <var>string_1</var> distinto del
correpondiente a <var>string_2</var>. La respuesta ser&aacute; <code>false</code> si no existe
tal car&aacute;cter. Por defecto, la funci&oacute;n de comparaci&oacute;n es <code>sequal</code>.
Si se quiere ignorar la diferencia entre may&uacute;sculas y min&uacute;sculas, h&aacute;gase uso de 
<code>sequalignore</code> para el argumento <var>test</var>.
</p>
<pre class="example">(%i1) smismatch(&quot;seven&quot;,&quot;seventh&quot;);
(%o1)                           6
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>split</b><i> (<var>string</var>)  </i>
<a name="IDX2736"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>split</b><i> (<var>string</var>, <var>delim</var>)  </i>
<a name="IDX2737"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>split</b><i> (<var>string</var>, <var>delim</var>, <var>multiple</var>) </i>
<a name="IDX2738"></a>
</dt>
<dd><p>Devuelve la lista de todos los lexemas (<i>tokens</i>) de <var>string</var>.
La funci&oacute;n <code>split</code> utiliza <var>delim</var> como delimitador, y en caso
de no ser utilizado este argumento, ser&aacute; utilizado el espacio en blanco
como delimitador por defecto. El argumento <var>multiple</var> es una variable
booleana con valor <code>true</code> por defecto. Los delimitadores m&uacute;ltiples 
se leen como uno solo, lo que resulta de utilidad si las tabulaciones son 
almacenadas como secuencias de espacios en blanco. Si a <var>multiple</var> se 
le asigna el valor <code>false</code>, se consirarar&aacute;n todos los delimitadores.
</p>
<pre class="example">(%i1) split(&quot;1.2   2.3   3.4   4.5&quot;);
(%o1)                 [1.2, 2.3, 3.4, 4.5]
(%i2) split(&quot;first;;third;fourth&quot;,&quot;;&quot;,false);
(%o2)               [first, , third, fourth]
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>sposition</b><i> (<var>char</var>, <var>string</var>) </i>
<a name="IDX2739"></a>
</dt>
<dd><p>Devuelve la posici&oacute;n del primer car&aacute;cter de <var>string</var> que
coincide con <var>char</var>. Al primer car&aacute;cter de <var>string</var>
le corresponde la posici&oacute;n 1.
Para cuando se quiera ignorar la diferencia entre may&uacute;sculas y 
min&uacute;sculas, v&eacute;ase <var>ssearch</var>.
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>sremove</b><i> (<var>seq</var>, <var>string</var>)  </i>
<a name="IDX2740"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>sremove</b><i> (<var>seq</var>, <var>string</var>, <var>test</var>)  </i>
<a name="IDX2741"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>sremove</b><i> (<var>seq</var>, <var>string</var>, <var>test</var>, <var>start</var>)  </i>
<a name="IDX2742"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>sremove</b><i> (<var>seq</var>, <var>string</var>, <var>test</var>, <var>start</var>, <var>end</var>)</i>
<a name="IDX2743"></a>
</dt>
<dd><p>Devuelve la cadena <var>string</var> pero sin las subcadenas que coinciden con <var>seq</var>.
La funci&oacute;n de comparaci&oacute;n por defecto es <code>sequal</code>.
Si se quiere ignorar la diferencia entre may&uacute;sculas y min&uacute;sculas, h&aacute;gase uso de 
<code>sequalignore</code> para el argumento <var>test</var>.
Util&iacute;cense <var>start</var> y <var>end</var> para acotar la b&uacute;squeda.
Al primer car&aacute;cter de <var>string</var> le corresponde la posici&oacute;n 1.
</p>
<pre class="example">(%i1) sremove(&quot;n't&quot;,&quot;I don't like coffee.&quot;);
(%o1)                   I do like coffee.
(%i2) sremove (&quot;DO &quot;,%,'sequalignore);
(%o2)                    I like coffee.
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>sremovefirst</b><i> (<var>seq</var>, <var>string</var>)  </i>
<a name="IDX2744"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>sremovefirst</b><i> (<var>seq</var>, <var>string</var>, <var>test</var>)  </i>
<a name="IDX2745"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>sremovefirst</b><i> (<var>seq</var>, <var>string</var>, <var>test</var>, <var>start</var>)  </i>
<a name="IDX2746"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>sremovefirst</b><i> (<var>seq</var>, <var>string</var>, <var>test</var>, <var>start</var>, <var>end</var>)  </i>
<a name="IDX2747"></a>
</dt>
<dd><p>Act&uacute;a de forma similar a la funci&oacute;n <code>sremove</code>, pero s&oacute;lo elimina
la primera aparici&oacute;n de la subcadena <code>seq</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>sreverse</b><i> (<var>string</var>) </i>
<a name="IDX2748"></a>
</dt>
<dd><p>Devuelve una cadena con todos los caracteres de <var>string</var> en orden inverso.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>ssearch</b><i> (<var>seq</var>, <var>string</var>)  </i>
<a name="IDX2749"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>ssearch</b><i> (<var>seq</var>, <var>string</var>, <var>test</var>)  </i>
<a name="IDX2750"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>ssearch</b><i> (<var>seq</var>, <var>string</var>, <var>test</var>, <var>start</var>)  </i>
<a name="IDX2751"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>ssearch</b><i> (<var>seq</var>, <var>string</var>, <var>test</var>, <var>start</var>, <var>end</var>)</i>
<a name="IDX2752"></a>
</dt>
<dd><p>Devuelve la posici&oacute;n de la primera subcadena de <var>string</var> que coincide con
la cadena <var>seq</var>.
La funci&oacute;n de comparaci&oacute;n por defecto es <code>sequal</code>.
Si se quiere ignorar la diferencia entre may&uacute;sculas y min&uacute;sculas, h&aacute;gase uso de 
<code>sequalignore</code> para el argumento <var>test</var>.
Util&iacute;cense <var>start</var> y <var>end</var> para acotar la b&uacute;squeda.
Al primer car&aacute;cter de <var>string</var> le corresponde la posici&oacute;n 1.
</p>
<pre class="example">(%i1) ssearch(&quot;~s&quot;,&quot;~{~S ~}~%&quot;,'sequalignore);
(%o1)                                  4
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>ssort</b><i> (<var>string</var>) </i>
<a name="IDX2753"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>ssort</b><i> (<var>string</var>, <var>test</var>) </i>
<a name="IDX2754"></a>
</dt>
<dd><p>Devuelve una cadena con todos los caracteres de <var>string</var> en un orden
tal que no haya dos caracteres sucesivos <var>c</var> y <var>d</var> que verifiquen
que <code>test (<var>c</var>, <var>d</var>)</code> sea igual <code>false</code> y 
<code>test (<var>d</var>, <var>c</var>)</code> igual a <code>true</code>.
La funci&oacute;n de comparaci&oacute;n <var>test</var> por defecto es  <var>clessp</var>, siendo
el conjunto de posibles valores para este argumento 
<code>{clessp, clesspignore, cgreaterp, cgreaterpignore, cequal, cequalignore}</code>.
</p>
<pre class="example">(%i1) ssort(&quot;I don't like Mondays.&quot;);
(%o1)                    '.IMaddeiklnnoosty
(%i2) ssort(&quot;I don't like Mondays.&quot;,'cgreaterpignore);
(%o2)                 ytsoonnMlkIiedda.'   
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>ssubst</b><i> (<var>new</var>, <var>old</var>, <var>string</var>) </i>
<a name="IDX2755"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>ssubst</b><i> (<var>new</var>, <var>old</var>, <var>string</var>, <var>test</var>) </i>
<a name="IDX2756"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>ssubst</b><i> (<var>new</var>, <var>old</var>, <var>string</var>, <var>test</var>, <var>start</var>) </i>
<a name="IDX2757"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>ssubst</b><i> (<var>new</var>, <var>old</var>, <var>string</var>, <var>test</var>, <var>start</var>, <var>end</var>) </i>
<a name="IDX2758"></a>
</dt>
<dd><p>Devuelve una cadena similar a <var>string</var> pero en la que aquellas subcadenas 
coincidentes con <var>old</var> han sido sustituidas por <var>new</var>. Las subcadenas
<var>old</var> y <var>new</var> no necesitan ser de la misma longitud. 
La funci&oacute;n de comparaci&oacute;n por defecto es <code>sequal</code>.
Si se quiere ignorar la diferencia entre may&uacute;sculas y min&uacute;sculas durante
la b&uacute;squeda de <var>old</var>, h&aacute;gase uso de 
<code>sequalignore</code> para el argumento <var>test</var>.
Util&iacute;cense <var>start</var> y <var>end</var> para acotar la b&uacute;squeda.
Al primer car&aacute;cter de <var>string</var> le corresponde la posici&oacute;n 1.
</p>
<pre class="example">(%i1) ssubst(&quot;like&quot;,&quot;hate&quot;,&quot;I hate Thai food. I hate green tea.&quot;);
(%o1)          I like Thai food. I like green tea.
(%i2) ssubst(&quot;Indian&quot;,&quot;thai&quot;,%,'sequalignore,8,12);
(%o2)         I like Indian food. I like green tea.
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>ssubstfirst</b><i> (<var>new</var>, <var>old</var>, <var>string</var>) </i>
<a name="IDX2759"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>ssubstfirst</b><i> (<var>new</var>, <var>old</var>, <var>string</var>, <var>test</var>) </i>
<a name="IDX2760"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>ssubstfirst</b><i> (<var>new</var>, <var>old</var>, <var>string</var>, <var>test</var>, <var>start</var>) </i>
<a name="IDX2761"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>ssubstfirst</b><i> (<var>new</var>, <var>old</var>, <var>string</var>, <var>test</var>, <var>start</var>, <var>end</var>) </i>
<a name="IDX2762"></a>
</dt>
<dd><p>Act&uacute;a de forma similar a la funci&oacute;n <code>subst</code>, pero s&oacute;lo hace
la sustituci&oacute;n en la primera coincidencia con <var>old</var>. 
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>strim</b><i> (<var>seq</var>,<var>string</var>) </i>
<a name="IDX2763"></a>
</dt>
<dd><p>Devuelve la cadena <var>string</var> pero recortando los caracteres
de <var>seq</var> que tuviese en sus extremos.
</p>
<pre class="example">(%i1) &quot;/* comment */&quot;$
(%i2) strim(&quot; /*&quot;,%);
(%o2)                        comment
(%i3) slength(%);
(%o3)                           7
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>striml</b><i> (<var>seq</var>, <var>string</var>) </i>
<a name="IDX2764"></a>
</dt>
<dd><p>Act&uacute;a de forma similar a <code>strim</code>, pero s&oacute;lo recorta
en el extremo final de <var>string</var>.
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>strimr</b><i> (<var>seq</var>, <var>string</var>) </i>
<a name="IDX2765"></a>
</dt>
<dd><p>Act&uacute;a de forma similar a <code>strim</code>, pero s&oacute;lo recorta
en el extremo inicial de <var>string</var>.
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>stringp</b><i> (<var>obj</var>) </i>
<a name="IDX2766"></a>
</dt>
<dd><p>Devuelve <code>true</code> si <var>obj</var> es una cadena.
V&eacute;ase un ejemplo en la introducci&oacute;n.
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>substring</b><i> (<var>string</var>, <var>start</var>)</i>
<a name="IDX2767"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>substring</b><i> (<var>string</var>, <var>start</var>, <var>end</var>) </i>
<a name="IDX2768"></a>
</dt>
<dd><p>Devuelve la subcadena de <var>string</var> que comienza en la posici&oacute;n
<var>start</var> y termina en la posici&oacute;n <var>end</var>.
El car&aacute;cter en la posici&oacute;n <var>end</var> no se incluye.
En caso de no suministrarse el argumento <var>end</var>, la subcadena
se extender&aacute; hasta el final. 
Al primer car&aacute;cter de <var>string</var> le corresponde la posici&oacute;n 1.
</p>
<pre class="example">(%i1) substring(&quot;substring&quot;,4);
(%o1)                        string
(%i2) substring(%,4,6);
(%o2)                          in
</pre>

</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>supcase</b><i> (<var>string</var>) </i>
<a name="IDX2769"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>supcase</b><i> (<var>string</var>, <var>start</var>) </i>
<a name="IDX2770"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>supcase</b><i> (<var>string</var>, <var>start</var>, <var>end</var>) </i>
<a name="IDX2771"></a>
</dt>
<dd><p>Devuelve la cadena <var>string</var> con todos sus caracteres entre las posiciones
<var>start</var> y <var>end</var> en min&uacute;scula transformados a may&uacute;scula.
En caso de no suministrarse el argumento <var>end</var>, los cambios
se extender&aacute;n hasta el final.
</p>
<pre class="example">(%i1) supcase(&quot;english&quot;,1,2);
(%o1)                        English
</pre>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>tokens</b><i> (<var>string</var>) </i>
<a name="IDX2772"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>tokens</b><i> (<var>string</var>, <var>test</var>) </i>
<a name="IDX2773"></a>
</dt>
<dd><p>Devuelve la lista de todos los lexemas (<i>tokens</i>) de <var>string</var>.
Los lexemas son subcadenas cuyos caracteres satisfacen la  condici&oacute;n <var>test</var>.
Si no se suministra el argumento <var>test</var>, se utilizar&aacute; la condici&oacute;n
<var>constituent</var>, siendo el conjunto de las otras alternativas
<code>{constituent, alphacharp, digitcharp, lowercasep, uppercasep, charp, characterp, alphanumericp}</code>.
</p>
<pre class="example">(%i1) tokens(&quot;24 October 2005&quot;);
(%o1)                  [24, October, 2005]
(%i2) tokens(&quot;05-10-24&quot;,'digitcharp);
(%o2)                     [05, 10, 24]
(%i3) map(parse_string,%);
(%o3)                      [5, 10, 24]
</pre>
</dd></dl>

<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC359" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_77.html#SEC364" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_81.html#SEC376" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Jaime Villate</em> on <em>octubre, 13 2014</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
