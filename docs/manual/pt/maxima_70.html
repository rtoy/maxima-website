<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on Outubro, 19 2014 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual do Maxima: 70. stringproc</title>

<meta name="description" content="Manual do Maxima: 70. stringproc">
<meta name="keywords" content="Manual do Maxima: 70. stringproc">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body
{
    color: black;
    background: white; 
    margin-left: 8%;
    margin-right: 13%;
}

h1
{
    margin-left: +8%;
    font-size: 150%;
    font-family: sans-serif
}

h2
{
    font-size: 125%;
    font-family: sans-serif
}

h3
{
    font-size: 100%;
    font-family: sans-serif
}

h2,h3,h4,h5,h6 { margin-left: +4%; }

div.textbox
{
    border: solid;
    border-width: thin;
    /* width: 100%; */
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em
}

div.titlebox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
    background: rgb(200,255,255);
    font-family: sans-serif
}

div.synopsisbox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
     background: rgb(255,220,255);
    /*background: rgb(200,255,255); */
    /* font-family: fixed */
}

pre.example
{
    border: 1px solid gray;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 1em;
    padding-right: 1em;
    /* background: rgb(247,242,180); */ /* kind of sandy */
    /* background: rgb(200,255,255); */ /* sky blue */
    background-color: #F1F5F9; /* light blue-gray */
    /* font-family: "Lucida Console", monospace */
}

div.spacerbox
{
    border: none;
    padding-top: 2em;
    padding-bottom: 2em
}

div.image
{
    margin: 0;
    padding: 1em;
    text-align: center;
}

div.categorybox
{
    border: 1px solid gray;
    padding-top: 0px;
    padding-bottom: 0px;
    padding-left: 1em;
    padding-right: 1em;
    background: rgb(247,242,220);
}


-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="pt" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="stringproc"></a>
<a name="SEC257"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_69.html#SEC256" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC258" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_69.html#SEC255" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_71.html#SEC262" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC274" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 70. stringproc </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC258">70.1 Introdu&ccedil;&atilde;o a manipula&ccedil;&atilde;o de sequ&ecirc;ncias de caracteres</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC259">70.2 Defini&ccedil;&otilde;es para entrada e sa&iacute;da</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC260">70.3 Defini&ccedil;&otilde;es para caracteres</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC261">70.4 Defini&ccedil;&otilde;es para sequ&ecirc;ncias de caracteres</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Introdu_00e7_00e3o-a-manipula_00e7_00e3o-de-sequ_00eancias-de-caracteres"></a>
<a name="SEC258"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC257" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC259" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC257" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC257" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_71.html#SEC262" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC274" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 70.1 Introdu&ccedil;&atilde;o a manipula&ccedil;&atilde;o de sequ&ecirc;ncias de caracteres </h2>

<p>O ficheiro <code>stringproc.lisp</code> amplia a compatibilidade do Maxima de trabalhar com sequ&ecirc;ncias de caracteres 
e adiciona algumas fun&ccedil;&otilde;es &uacute;teis a entrada e sa&iacute;da de dados.
</p>
<p>Para esclarecimentos e erros por favor mande um e-mail para van.nek at arcor.de .
</p>
<p>Para disponibilizar <code>stringproc.lisp</code> para uso digite <code>load(&quot;stringproc&quot;);</code>.
</p>
<p>No Maxima uma sequ&ecirc;ncia de caracteres &eacute; facilmente contru&iacute;da digitando &quot;texto&quot; (qualquer texto desejado entre aspas duplas).
Note que sequ&ecirc;ncias de caracteres do Maxima n&atilde;o s&atilde;o sequ&ecirc;ncias de caracteres do Lisp e vice-versa.
Testes podem ser conclu&iacute;dos com <code>stringp</code> e <code>lstringp</code>.
Se por alguma raz&atilde;o tiver um valor,
que &eacute; uma sequ&ecirc;ncia de caracteres do Lisp, talvez quando estiver usando a fun&ccedil;&atilde;o <code>sconcat</code> do Maxima, poder&aacute; converter via <code>sunlisp</code>. 
</p>

<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) m: &quot;text&quot;;
(%o2)                         text
(%i3) [stringp(m),lstringp(m)];
(%o3)                     [true, false]
(%i4) l: sconcat(&quot;text&quot;);
(%o4)                         text
(%i5) [stringp(l),lstringp(l)];
(%o5)                     [false, true]
(%i6) stringp( sunlisp(l) );
(%o6)                         true
</pre>
<p>Todas as fun&ccedil;&otilde;es em <code>stringproc.lisp</code>, que retornarem sequ&ecirc;ncias de caracteres, retornam sequ&ecirc;ncias de caracteres do Maxima.
</p>
<p>Caracteres s&atilde;o introduzidos como sequ&ecirc;ncias de caracteres do Maxima de comprimento 1.
Com certeza, esses caracteres n&atilde;o s&atilde;o caracteres do Lisp.
Testes podem ser realizados com <code>charp</code> ( <code>lcharp</code> e convers&otilde;es do Lisp para o Maxima com <code>cunlisp</code>).
</p>

<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) c: &quot;e&quot;;
(%o2)                           e
(%i3) [charp(c),lcharp(c)];
(%o3)                     [true, false]
(%i4) supcase(c);
(%o4)                           E
(%i5) charp(%);
(%o5)                         true
</pre>
<p>Novamente, todas as fun&ccedil;&otilde;es em <code>stringproc.lisp</code>, que
retornam caracteres, retornam caracteres do Maxima.  devido a esse
facto, que os caracteres introduzidos s&atilde;o sequ&ecirc;ncias de caracteres
de comprimento 1, pode usar muitas das fun&ccedil;&otilde;es de sequ&ecirc;ncia de
caracteres tamb&eacute;m para caracteres. Como visto, <code>supcase</code> &eacute; um
exemplo.
</p>
<p>&Eacute; importante saber,
que o primeiro caractere em uma sequ&ecirc;ncia de caracteres do Maxima &eacute;st&aacute; na posi&ccedil;&atilde;o 1.
Isso &eacute; designado devido ao facto de o primeiro elemento em uma lista do Maxima est&aacute; na posi&ccedil;&atilde;o 1 tamb&eacute;m.
Veja defini&ccedil;&otilde;es de <code>charat</code> e de <code>charlist</code> para obter exemplos.
</p>
<p>Em aplica&ccedil;&otilde;es fn&ccedil;&otilde;es de sequ&ecirc;ncia de caractere s&atilde;o
muitas vezes usadas quando estamos trabalhando com ficheiros.  Poder&aacute;
encontrar&aacute; algumas fun&ccedil;&otilde;es &uacute;teis de fluxo e de impress&atilde;o em
<code>stringproc.lisp</code>.  O seguinte exemplo mostra algumas das
fun&ccedil;&otilde;es aqui introduzidas no trabalho.
</p>
<p>Exemplo: 
</p>
<p><code>openw</code> retorna um fluxo de sa&iacute;da para um ficheiro,
<code>printf</code> ent&atilde;o permite escrita formatada para esse ficheiro. Veja
<code>printf</code> para detalhes.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) s: openw(&quot;E:/file.txt&quot;);
(%o2)                    #&lt;output stream E:/file.txt&gt;
(%i3) for n:0 thru 10 do printf( s, &quot;~d &quot;, fib(n) );
(%o3)                                done
(%i4) printf( s, &quot;~%~d ~f ~a ~a ~f ~e ~a~%&quot;, 
              42,1.234,sqrt(2),%pi,1.0e-2,1.0e-2,1.0b-2 );
(%o4)                                false
(%i5) close(s);
(%o5)                                true
</pre>
<p>Ap&oacute;s fechar o fluxo pode abr&iacute;-lo novamente, dessa vez
com dire&ccedil;&atilde;o de entrada.  <code>readline</code> retorna a linha completa
como uma sequ&ecirc;ncia de caracteres. O pacote <code>stringproc</code> agora
oferece muitas fun&ccedil;&otilde;es para manipula&ccedil;&atilde;o de sequ&ecirc;ncias de
caracteres. A troca de indica&ccedil;&otilde;es/fichas pode ser realizada por
<code>split</code> ou por <code>tokens</code>.
</p>
<pre class="example">(%i6) s: openr(&quot;E:/file.txt&quot;);
(%o6)                     #&lt;input stream E:/file.txt&gt;
(%i7) readline(s);
(%o7)                     0 1 1 2 3 5 8 13 21 34 55 
(%i8) line: readline(s);
(%o8)               42 1.234 sqrt(2) %pi 0.01 1.0E-2 1.0b-2
(%i9) list: tokens(line);
(%o9)           [42, 1.234, sqrt(2), %pi, 0.01, 1.0E-2, 1.0b-2]
(%i10) map( parsetoken, list );
(%o10)           [42, 1.234, false, false, 0.01, 0.01, false]
</pre>
<p><code>parsetoken</code> somente analiza n&uacute;meros inteiros e em ponto flutuante. A an&aacute;lise de s&iacute;mbolos ou grandes n&uacute;meros em ponto flutuante 
precisa de <code>parse_string</code>, que pode ser disponibilizada para uso atrav&eacute;s de <code>eval_string.lisp</code>.
</p>
<pre class="example">(%i11) load(&quot;eval_string&quot;)$
(%i12) map( parse_string, list );
(%o12)           [42, 1.234, sqrt(2), %pi, 0.01, 0.01, 1.0b-2]
(%i13) float(%);
(%o13) [42.0, 1.234, 1.414213562373095, 3.141592653589793, 0.01, 0.01, 0.01]
(%i14) readline(s);
(%o14)                               false
(%i15) close(s)$
</pre>
<p><code>readline</code> retorna <code>false</code> quado o fim de ficheiro acontecer.
</p>
<hr size="6">
<a name="Defini_00e7_00f5es-para-entrada-e-sa_00edda"></a>
<a name="SEC259"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC258" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC260" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC257" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC257" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_71.html#SEC262" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC274" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 70.2 Defini&ccedil;&otilde;es para entrada e sa&iacute;da </h2>

<p>Exemplo: 
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) s: openw(&quot;E:/file.txt&quot;);
(%o2)                     #&lt;output stream E:/file.txt&gt;
(%i3) control: 
&quot;~2tAn atom: ~20t~a~%~2tand a list: ~20t~{~r ~}~%~2tand an integer: ~20t~d~%&quot;$
(%i4) printf( s,control, 'true,[1,2,3],42 )$
(%o4)                                false
(%i5) close(s);
(%o5)                                true
(%i6) s: openr(&quot;E:/file.txt&quot;);
(%o6)                     #&lt;input stream E:/file.txt&gt;
(%i7) while stringp( tmp:readline(s) ) do print(tmp)$
  An atom:          true 
  and a list:       one two three  
  and an integer:   42 
(%i8) close(s)$
</pre>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>close</b><i> (<var>fluxo</var>) </i>
<a name="IDX1923"></a>
</dt>
<dd><p>Fecha  <var>fluxo</var> e retorna <code>true</code> se <var>fluxo</var> tiver sido aberto anteriormente. 
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>flength</b><i> (<var>fluxo</var>)</i>
<a name="IDX1924"></a>
</dt>
<dd><p>Retorna o n&uacute;mero de elementos em <var>fluxo</var>. 
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>fposition</b><i> (<var>fluxo</var>)</i>
<a name="IDX1925"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>fposition</b><i> (<var>fluxo</var>, <var>pos</var>)</i>
<a name="IDX1926"></a>
</dt>
<dd><p>Retorna a posi&ccedil;&atilde;o corrente em <var>fluxo</var>, se <var>pos</var> n&atilde;o est&aacute; sendo usada.
Se <var>pos</var> estiver sendo usada,
<code>fposition</code> escolhe a posi&ccedil;&atilde;o em <var>fluxo</var>.
<var>pos</var> tem que ser um n&uacute;mero positivo,
o primeiro elemento em <var>fluxo</var> est&aacute; na posi&ccedil;&atilde;o 1.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>freshline</b><i> () </i>
<a name="IDX1927"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>freshline</b><i> (<var>fluxo</var>) </i>
<a name="IDX1928"></a>
</dt>
<dd><p>escreve uma nova linha (em <var>fluxo</var>),
se a posi&ccedil;&atilde;o actual n&atilde;o for um in&iacute;cio de linha.
Veja tamb&eacute;m <code>newline</code>.
</p></dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>newline</b><i> () </i>
<a name="IDX1929"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>newline</b><i> (<var>fluxo</var>) </i>
<a name="IDX1930"></a>
</dt>
<dd><p>Escreve uma nova linha (para <var>fluxo</var>).
Veja <code>sprint</code> para um exemplo de uso de <code>newline()</code>.
Note que existem alguns casos, onde <code>newline()</code>n&atilde;o trabalha como esperado. 
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>opena</b><i> (<var>ficheiro</var>) </i>
<a name="IDX1931"></a>
</dt>
<dd><p>Retorna um fluxo de sa&iacute;da para <var>ficheiro</var>.
Se um ficheiro j&aacute; existente tiver sido aberto, <code>opena</code> anexa os elementos ao final do ficheiro.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>openr</b><i> (<var>ficheiro</var>) </i>
<a name="IDX1932"></a>
</dt>
<dd><p>Retorna um fluxo para <var>ficheiro</var>.
Se <var>ficheiro</var> n&atilde;o existir, ele ser&aacute; criado.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>openw</b><i> (<var>ficheiro</var>) </i>
<a name="IDX1933"></a>
</dt>
<dd><p>Retorna um fluxo de sa&iacute;da para <var>ficheiro</var>.
Se <var>ficheiro</var> n&atilde;o existir, ser&aacute; criado.
Se um ficheiro j&aacute; existente for aberto, <code>openw</code> modifica destrutivametne o <var>ficheiro</var>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>printf</b><i> (<var>dest</var>, <var>seq_caracte</var>)</i>
<a name="IDX1934"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>printf</b><i> (<var>dest</var>, <var>seq_caracte</var>, <var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1935"></a>
</dt>
<dd><p>Torna a fun&ccedil;&atilde;o FORMAT do Lisp Comum dispon&iacute;vel no Maxima. 
(Retirado de gcl.info: &quot;format produces formatted output by outputting the caracteres of 
control-string string and observing that a tilde introduces a directive.
The caractere after the tilde,
possibly preceded by prefix parameters and modifiers,
specifies what kind of formatting is desired.
Most directives use one or more elements of args to create their output.&quot;)
</p>
<p>A seguinte descri&ccedil;&atilde;o e oa exemplos podem fornecer uma id&eacute;ia de uso de <code>printf</code>.
Veja um refer&ecirc;ncia de Lisp para maiores informa&ccedil;&otilde;es.
</p>
<pre class="example">   ~%       nova linha
   ~&amp;       nov&iacute;ssima line
   ~t       tabula&ccedil;&atilde;o
   ~$       monet&aacute;rio
   ~d       inteiro decimal
   ~b       inteiro bin&aacute;rio
   ~o       inteiro octal
   ~x       inteiro hexadecimal
   ~br      inteiro de base b
   ~r       soletra um inteiro
   ~p       plural
   ~f       ponto flutuante
   ~e       nota&ccedil;&atilde;o cient&iacute;fica
   ~g       ~f ou ~e, dependendo  da magnitude
   ~a       como mostrado pela fun&ccedil;&atilde;o print do Maxima
   ~s       sequ&ecirc;ncias de caracteres entre &quot;aspas duplas&quot;
   ~~       ~
   ~&lt;       justifica&ccedil;&atilde;o de texto, ~&gt; terminador de justifica&ccedil;&atilde;o de texto
   ~(       convers&atilde;o de caixa alta/baixa, ~) terminador de convers&atilde;o de caixa
   ~[       selec&ccedil;&atilde;o, ~] terminador de selec&ccedil;&atilde;o 
   ~{       itera&ccedil;&atilde;o, ~} terminador de itera&ccedil;&atilde;o
</pre>
<p>Por favor note que n&atilde;o existe especificador de formato para grandes
n&uacute;meros em ponto flutuante. Todavia grandes n&uacute;meros em ponto
flutuante podem simplesmente serem mostrados por meio da directiva
<code>~a</code>.  <code>~s</code> mostra as sequ&ecirc;ncias de caracteres entre &quot;aspas
duplas&quot;; pode evitar isso usando <code>~a</code>.  Note que a directiva de
selec&ccedil;&atilde;o <code>~[</code> &eacute; indexada em zero.  Tamb&eacute;m note que existem
algumas directivas, que n&atilde;o trabalham no Maxima.  Por exemplo,
<code>~:[</code> falha.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) printf( false, &quot;~a ~a ~4f ~a ~@r&quot;, 
              &quot;String&quot;,sym,bound,sqrt(12),144), bound = 1.234;
(%o2)                 String sym 1.23 2*sqrt(3) CXLIV
(%i3) printf( false,&quot;~{~a ~}&quot;,[&quot;one&quot;,2,&quot;THREE&quot;] );
(%o3)                          one 2 THREE 
(%i4) printf( true,&quot;~{~{~9,1f ~}~%~}&quot;,mat ),
              mat = args( matrix([1.1,2,3.33],[4,5,6],[7,8.88,9]) )$
      1.1       2.0       3.3 
      4.0       5.0       6.0 
      7.0       8.9       9.0 
(%i5) control: &quot;~:(~r~) bird~p ~[is~;are~] singing.&quot;$
(%i6) printf( false,control, n,n,if n=1 then 0 else 1 ), n=2;
(%o6)                    Two birds are singing.
</pre>
<p>Se <var>dest</var> for um fluxo ou <code>true</code>, ent&atilde;o <code>printf</code> retorna <code>false</code>.
De outra forma, <code>printf</code> retorna uma sequ&ecirc;ncia de caracteres contendo a sa&iacute;da.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>readline</b><i> (<var>fluxo</var>) </i>
<a name="IDX1936"></a>
</dt>
<dd><p>Retorna uma sequ&ecirc;ncia de caracteres contendo os caracteres a partir da posi&ccedil;&atilde;o corrente em <var>fluxo</var> at&eacute; o fim de linha ou <var>false</var> se o fim de linha do ficheiro for encontrado.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sprint</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1937"></a>
</dt>
<dd><p>Avalia e mostra seus argumentos um ap&oacute;s o outro `sobre uma linha'
iniciando na posi&ccedil;&atilde;o mais &agrave; esquerda.  Os n&uacute;meros s&atilde;o
mostrados com o '-' &agrave; direita do n&uacute;mero, e isso desconsidera o
comprimento da linha. <code>newline()</code>, que pode ser chamada a partir de
<code>stringproc.lisp</code> pode ser &uacute;til, se desejar colocar uma parada de
linha interm&eacute;dia.
</p>
<pre class="example">(%i1) for n:0 thru 22 do sprint( fib(n) )$
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 
(%i2) load(&quot;stringproc&quot;)$
(%i3) for n:0 thru 22 do ( 
         sprint(fib(n)), if mod(n,10)=9 then newline() )$
0 1 1 2 3 5 8 13 21 34 
55 89 144 233 377 610 987 1597 2584 4181 
6765 10946 17711 
</pre>
</dd></dl>

<hr size="6">
<a name="Defini_00e7_00f5es-para-caracteres"></a>
<a name="SEC260"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC259" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC261" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC257" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC257" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_71.html#SEC262" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC274" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 70.3 Defini&ccedil;&otilde;es para caracteres </h2>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>alphacharp</b><i> (<var>caractere</var>)    </i>
<a name="IDX1938"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>caractere</var> for um caractere alfab&eacute;tico. 
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>alphanumericp</b><i> (<var>caractere</var>) </i>
<a name="IDX1939"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>caractere</var> for um caractere alfab&eacute;tico ou um d&iacute;gito. 
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ascii</b><i> (<var>int</var>) </i>
<a name="IDX1940"></a>
</dt>
<dd><p>Retorna o caractere correspondente ao c&oacute;digo num&eacute;rico ASCII <var>int</var>.
( -1 &lt; int &lt; 256 )
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) for n from 0 thru 255 do ( 
tmp: ascii(n), if alphacharp(tmp) then sprint(tmp), if n=96 then newline() )$
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
a b c d e f g h i j k l m n o p q r s t u v w x y z
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>cequal</b><i> (<var>caractere_1</var>, <var>caractere_2</var>)          </i>
<a name="IDX1941"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>caractere_1</var> e <var>caractere_2</var> forem os mesmos. 
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>cequalignore</b><i> (<var>caractere_1</var>, <var>caractere_2</var>)    </i>
<a name="IDX1942"></a>
</dt>
<dd><p>como <code>cequal</code> mas ignora a caixa alta/baixa. 
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>cgreaterp</b><i> (<var>caractere_1</var>, <var>caractere_2</var>)       </i>
<a name="IDX1943"></a>
</dt>
<dd><p>Retorna <code>true</code> se o c&oacute;digo num&eacute;rico ASCII do <var>caractere_1</var> for maior que o c&oacute;digo num&eacute;rico ASCII do <var>caractere_2</var>. 
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>cgreaterpignore</b><i> (<var>caractere_1</var>, <var>caractere_2</var>)</i>
<a name="IDX1944"></a>
</dt>
<dd><p>Como <code>cgreaterp</code> mas ignora a caixa alta/baixa. 
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>charp</b><i> (<var>obj</var>) </i>
<a name="IDX1945"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>obj</var> for um caractere do Maxima.
Veja na se&ccedil;&atilde;o &quot;Introdu&ccedil;&atilde;o a manipula&ccedil;&atilde;o de sequ&ecirc;ncias de caracteres&quot; para ter um exemplo.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>cint</b><i> (<var>caractere</var>) </i>
<a name="IDX1946"></a>
</dt>
<dd><p>Retorna o c&oacute;digo num&eacute;ico ASCII de <var>caractere</var>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>clessp</b><i> (<var>caractere_1</var>, <var>caractere_2</var>)</i>
<a name="IDX1947"></a>
</dt>
<dd><p>Retorna <code>true</code> se o c&oacute;digo num&eacute;rico ASCII de <var>caractere_1</var> for menor que o c&oacute;digo num&eacute;rico ASCII de <var>caractere_2</var>. 
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>clesspignore</b><i> (<var>caractere_1</var>, <var>caractere_2</var>)</i>
<a name="IDX1948"></a>
</dt>
<dd><p>Como em <code>clessp</code> ignora a caixa alta/baixa. 
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>constituent</b><i> (<var>caractere</var>)   </i>
<a name="IDX1949"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>caractere</var> for caractere  gr&aacute;fico e n&atilde;o o caractere de espa&ccedil;o em branco.
Um caractere gr&aacute;fico &eacute; um caractere que se pode ver, adicionado o caractere de espa&ccedil;o em branco.
(<code>constituent</code> foi definida por Paul Graham, em ANSI Common Lisp, 1996, p&aacute;gina 67.)
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) for n from 0 thru 255 do ( 
tmp: ascii(n), if constituent(tmp) then sprint(tmp) )$
! &quot; #  %  ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; &lt; = &gt; ? @ A B
C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c
d e f g h i j k l m n o p q r s t u v w x y z { | } ~
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>cunlisp</b><i> (<var>lisp_char</var>) </i>
<a name="IDX1950"></a>
</dt>
<dd><p>Converte um caractere do Lisp em um caractere do Maxima.  (&Eacute;
poss&iacute;vel que n&atilde;o chegue a precisar dessa fun&ccedil;&atilde;o.)
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>digitcharp</b><i> (<var>caractere</var>)    </i>
<a name="IDX1951"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>caractere</var> for um d&iacute;gito (algarismo de 0 a 9). 
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>lcharp</b><i> (<var>obj</var>) </i>
<a name="IDX1952"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>obj</var> for um caractere do Lisp.
(Pode n&atilde;o precisar dessa fun&ccedil;&atilde;o.)
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>lowercasep</b><i> (<var>caractere</var>)    </i>
<a name="IDX1953"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>caractere</var> for um caractere em caixa baixa. 
</p>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>newline</b>
<a name="IDX1954"></a>
</dt>
<dd><p>O caractere de nova linha. 
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>space</b>
<a name="IDX1955"></a>
</dt>
<dd><p>O caractere de espa&ccedil;o em branco.
</p>
</dd></dl>

<dl>
<dt><u>Vari&aacute;vel:</u> <b>tab</b>
<a name="IDX1956"></a>
</dt>
<dd><p>O caractere de tabula&ccedil;&atilde;o.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>uppercasep</b><i> (<var>caractere</var>)    </i>
<a name="IDX1957"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>caractere</var> for um caractere em caixa alta. 
</p>
</dd></dl>

<hr size="6">
<a name="Defini_00e7_00f5es-para-sequ_00eancias-de-caracteres"></a>
<a name="SEC261"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC260" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_71.html#SEC262" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC257" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC257" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_71.html#SEC262" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC274" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 70.4 Defini&ccedil;&otilde;es para sequ&ecirc;ncias de caracteres </h2>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sunlisp</b><i> (<var>lisp_string</var>) </i>
<a name="IDX1958"></a>
</dt>
<dd><p>Converte uma sequ&ecirc;ncia de caracteres do Lisp em uma sequ&ecirc;ncia de caracteres do Maxima.
(Em geral, pode n&atilde;o chegar a precisar dessa fun&ccedil;&atilde;o.)
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>lstringp</b><i> (<var>obj</var>) </i>
<a name="IDX1959"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>obj</var> is uma sequ&ecirc;ncia de caracteres do Lisp.
(Em geral, pode n&atilde;o chegar a precisar dessa fun&ccedil;&atilde;o.)
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>stringp</b><i> (<var>obj</var>) </i>
<a name="IDX1960"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>obj</var> for uma sequ&ecirc;ncia de caracteres do Maxima.
Veja a introdu&ccedil;&atilde;o para obter exemplos.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>charat</b><i> (<var>seq_caracte</var>, <var>n</var>) </i>
<a name="IDX1961"></a>
</dt>
<dd><p>Retorna o <var>n</var>-&eacute;simo caractere de <var>seq_caracte</var>.
O primeiro caractere em <var>seq_caracte</var> &eacute; retornado com <var>n</var> = 1.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) charat(&quot;Lisp&quot;,1);
(%o2)                           L
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>charlist</b><i> (<var>seq_caracte</var>) </i>
<a name="IDX1962"></a>
</dt>
<dd><p>Retorna a lsita de todos os caracteres em <var>seq_caracte</var>. 
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) charlist(&quot;Lisp&quot;);
(%o2)                     [L, i, s, p]
(%i3) %[1];
(%o3)                           L
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>parsetoken</b><i> (<var>seq_caracte</var>)  </i>
<a name="IDX1963"></a>
</dt>
<dd><p><code>parsetoken</code> converte a primeira ficha em <var>seq_caracte</var> para o correspondente n&uacute;mero ou retorna <code>false</code> se o n&uacute;mero n&atilde;o puder ser determinado.
O conjunto de delimitadores para a troca de fichas &eacute; <code>{space, comma, semicolon, tab, newline}</code>
</p>
<p>Nota de tradu&ccedil;&atilde;o:
espa&ccedil;o, v&iacute;rgula, ponto e v&iacute;rgula, tabula&ccedil;&atilde;o e nova linha.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) 2*parsetoken(&quot;1.234 5.678&quot;);
(%o2)                         2.468
</pre>
<p>Para analizar, pode tamb&eacute;m usar a fun&ccedil;&atilde;o <code>parse_string</code>.
Veja a descri&ccedil;&atilde;o no ficheiro 'share\contrib\eval_string.lisp'.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sconc</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1964"></a>
</dt>
<dd><p>Avalia seus argumentos e concatena-os em uma sequ&ecirc;ncia de caracteres.
<code>sconc</code> &eacute; como <code>sconcat</code> mas retorna uma sequ&ecirc;ncia de caracteres do Maxima.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) sconc(&quot;xx[&quot;,3,&quot;]:&quot;,expand((x+y)^3));
(%o2)             xx[3]:y^3+3*x*y^2+3*x^2*y+x^3
(%i3) stringp(%);
(%o3)                         true
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>scopy</b><i> (<var>seq_caracte</var>) </i>
<a name="IDX1965"></a>
</dt>
<dd><p>Retorna uma c&oacute;pia de <var>seq_caracte</var> como uma nova sequ&ecirc;ncia de caracteres. 
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sdowncase</b><i> (<var>seq_caracte</var>) </i>
<a name="IDX1966"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sdowncase</b><i> (<var>seq_caracte</var>, <var>in&iacute;cio</var>) </i>
<a name="IDX1967"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sdowncase</b><i> (<var>seq_caracte</var>, <var>in&iacute;cio</var>, <var>fim</var>) </i>
<a name="IDX1968"></a>
</dt>
<dd><p>Como em <code>supcase</code>, mas caracteres em caixa alta s&atilde;o convertidos para caracteres em caixa baixa. 
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sequal</b><i> (<var>seq_caracte__1</var>, <var>seq_caracte__2</var>) </i>
<a name="IDX1969"></a>
</dt>
<dd><p>Retorna <code>true</code> se <var>seq_caracte__1</var> e <var>seq_caracte__2</var> tiverem o mesmo comprimento e contiverem os mesmos caracteres. 
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sequalignore</b><i> (<var>seq_caracte__1</var>, <var>seq_caracte__2</var>)</i>
<a name="IDX1970"></a>
</dt>
<dd><p>Como em <code>sequal</code> mas igonara a caixa alta/baixa. 
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sexplode</b><i> (<var>seq_caracte</var>)</i>
<a name="IDX1971"></a>
</dt>
<dd><p><code>sexplode</code> &eacute; um apelido para a fun&ccedil;&atilde;o <code>charlist</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>simplode</b><i> (<var>lista</var>)  </i>
<a name="IDX1972"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>simplode</b><i> (<var>lista</var>, <var>delim</var>)  </i>
<a name="IDX1973"></a>
</dt>
<dd><p><code>simplode</code> takes uma <code>lista</code> ou express&otilde;es  e concatena-as em uma sequ&ecirc;ncia de caracteres.
Se nenhum delimitador <var>delim</var> for usado, <code>simplode</code> funciona como <code>sconc</code> e n&atilde;o utiliza delimitador.
<var>delim</var> pode ser qualquer sequ&ecirc;ncia de caracteres.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) simplode([&quot;xx[&quot;,3,&quot;]:&quot;,expand((x+y)^3)]);
(%o2)             xx[3]:y^3+3*x*y^2+3*x^2*y+x^3
(%i3) simplode( sexplode(&quot;stars&quot;),&quot; * &quot; );
(%o3)                   s * t * a * r * s
(%i4) simplode( [&quot;One&quot;,&quot;more&quot;,&quot;coffee.&quot;],&quot; &quot; );
(%o4)                   One more coffee.
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sinsert</b><i> (<var>seq</var>, <var>seq_caracte</var>, <var>pos</var>)  </i>
<a name="IDX1974"></a>
</dt>
<dd><p>Retorna uma sequ&ecirc;ncia de caracteres que &eacute; uma concatena&ccedil;&atilde;o de <code>substring (<var>seq_caracte</var>, 1, <var>pos</var> - 1)</code>,
a sequ&ecirc;ncia de caracteres <var>seq</var> e <code>substring (<var>seq_caracte</var>, <var>pos</var>)</code>.
Note que o primeiro caractere est&aacute; em <var>seq_caracte</var> e est&aacute; na posi&ccedil;&atilde;o 1.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) s: &quot;A submarine.&quot;$
(%i3) sconc( substring(s,1,3),&quot;yellow &quot;,substring(s,3) );
(%o3)                  A yellow submarine.
(%i4) sinsert(&quot;hollow &quot;,s,3);
(%o4)                  A hollow submarine.
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sinvertcase</b><i> (<var>seq_caracte</var>)  </i>
<a name="IDX1975"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sinvertcase</b><i> (<var>seq_caracte</var>, <var>in&iacute;cio</var>)  </i>
<a name="IDX1976"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sinvertcase</b><i> (<var>seq_caracte</var>, <var>in&iacute;cio</var>, <var>fim</var>)  </i>
<a name="IDX1977"></a>
</dt>
<dd><p>Retorna <var>seq_caracte</var> excepto que cada caractere da posi&ccedil;&atilde;o <var>in&iacute;cio</var> at&eacute; a posi&ccedil;&atilde;o <var>fim</var> est&aacute; invertido.
Se a posi&ccedil;&atilde;o <var>fim</var> n&atilde;o for fornecida,
todos os caracteres do in&iacute;cio ao <var>fim</var> de <var>seq_caracte</var> s&atilde;o substitu&iacute;dos.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) sinvertcase(&quot;sInvertCase&quot;);
(%o2)                      SiNVERTcASE
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>slength</b><i> (<var>seq_caracte</var>) </i>
<a name="IDX1978"></a>
</dt>
<dd><p>Retorna n&uacute;mero de caracteres em <var>seq_caracte</var>. 
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>smake</b><i> (<var>num</var>, <var>caractere</var>) </i>
<a name="IDX1979"></a>
</dt>
<dd><p>Retorna uma nova sequ&ecirc;ncia de caracteres repetindo <var>num</var> vezes <var>caractere</var>. 
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) smake(3,&quot;w&quot;);
(%o2)                          www
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>smismatch</b><i> (<var>seq_caracte__1</var>, <var>seq_caracte__2</var>) </i>
<a name="IDX1980"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>smismatch</b><i> (<var>seq_caracte__1</var>, <var>seq_caracte__2</var>, <var>test</var>) </i>
<a name="IDX1981"></a>
</dt>
<dd><p>Retorna a posi&ccedil;&atilde;o do primeiro caractere de <var>seq_caracte__1</var> no qual <var>seq_caracte__1</var> e <var>seq_caracte__2</var> diferem ou <code>false</code> em caso contr&aacute;rio.
A fun&ccedil;&atilde;o padrao de teste para coincid&ecirc;ncia &eacute; <code>sequal</code>.
Se <code>smismatch</code> pode ignorar a caixa alta/baixa, use <code>sequalignore</code> como fun&ccedil;&atilde;o de teste.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) smismatch(&quot;seven&quot;,&quot;seventh&quot;);
(%o2)                           6
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>split</b><i> (<var>seq_caracte</var>)  </i>
<a name="IDX1982"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>split</b><i> (<var>seq_caracte</var>, <var>delim</var>)  </i>
<a name="IDX1983"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>split</b><i> (<var>seq_caracte</var>, <var>delim</var>, <var>multiple</var>)  </i>
<a name="IDX1984"></a>
</dt>
<dd><p>Retorna a lista de todas as fichas em <var>seq_caracte</var>.
Cada ficha &eacute; uma sequ&ecirc;ncia de caracteres n&atilde;o analisada.
<code>split</code> usa <var>delim</var> como delimitador.
Se <var>delim</var> n&atilde;o for fornecido, o caractere de espa&ccedil;o &eacute; o delimitador padr&atilde;o.
<var>multiple</var> &eacute; uma vari&aacute;vel booleana com <code>true</code> como valor padr&atilde;o.
Multiplos delimitadores s&atilde;o lidos como um.
Essa fun&ccedil;&atilde;o &eacute; &uacute;til se tabula&ccedil;&otilde;es s&atilde;o gravadas com caracteres de espa&ccedil;o multiplos.
Se <var>multiple</var> for escolhido para <code>false</code>, cada delimitador &eacute; considerado.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) split(&quot;1.2   2.3   3.4   4.5&quot;);
(%o2)                 [1.2, 2.3, 3.4, 4.5]
(%i3) split(&quot;first;;third;fourth&quot;,&quot;;&quot;,false);
(%o3)               [first, , third, fourth]
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sposition</b><i> (<var>caractere</var>, <var>seq_caracte</var>) </i>
<a name="IDX1985"></a>
</dt>
<dd><p>Retorna a posi&ccedil;&atilde;o do primeiro caractere em <var>seq_caracte</var> que coincide com <var>caractere</var>.
O primeiro caractere em <var>seq_caracte</var> est&aacute; na posi&ccedil;&atilde;o 1.
Para que os caracteres que coincidirem desconsiderem a caixa alta/baixa veja <code>ssearch</code>.
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sremove</b><i> (<var>seq</var>, <var>seq_caracte</var>)  </i>
<a name="IDX1986"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sremove</b><i> (<var>seq</var>, <var>seq_caracte</var>, <var>test</var>)  </i>
<a name="IDX1987"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sremove</b><i> (<var>seq</var>, <var>seq_caracte</var>, <var>test</var>, <var>in&iacute;cio</var>)  </i>
<a name="IDX1988"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sremove</b><i> (<var>seq</var>, <var>seq_caracte</var>, <var>test</var>, <var>in&iacute;cio</var>, <var>fim</var>)  </i>
<a name="IDX1989"></a>
</dt>
<dd><p>Retorna uma sequ&ecirc;ncia de caracteres como <var>seq_caracte</var> mas com todas as subsequ&ecirc;ncias de caracteres que coincidirem com <var>seq</var>.
A fun&ccedil;&atilde;o padr&atilde;o de teste de coincid&ecirc;ncia &eacute; <code>sequal</code>.
Se <code>sremove</code> puder ignorar a caixa alta/baixa enquanto busca por <var>seq</var>, use <code>sequalignore</code> como teste.
Use <var>in&iacute;cio</var> e <var>fim</var> para limitar a busca.
Note que o primeiro caractere em <var>seq_caracte</var> est&aacute; na posi&ccedil;&atilde;o 1.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) sremove(&quot;n't&quot;,&quot;I don't like coffee.&quot;);
(%o2)                   I do like coffee.
(%i3) sremove (&quot;DO &quot;,%,'sequalignore);
(%o3)                    I like coffee.
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sremovefirst</b><i> (<var>seq</var>, <var>seq_caracte</var>)  </i>
<a name="IDX1990"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sremovefirst</b><i> (<var>seq</var>, <var>seq_caracte</var>, <var>test</var>)  </i>
<a name="IDX1991"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sremovefirst</b><i> (<var>seq</var>, <var>seq_caracte</var>, <var>test</var>, <var>in&iacute;cio</var>)  </i>
<a name="IDX1992"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sremovefirst</b><i> (<var>seq</var>, <var>seq_caracte</var>, <var>test</var>, <var>in&iacute;cio</var>, <var>fim</var>)  </i>
<a name="IDX1993"></a>
</dt>
<dd><p>Como em <code>sremove</code> excepto que a primeira subsequ&ecirc;ncia de caracteres que coincide com <code>seq</code> &eacute; removida. 
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>sreverse</b><i> (<var>seq_caracte</var>) </i>
<a name="IDX1994"></a>
</dt>
<dd><p>Retorna uma sequ&ecirc;ncia de caracteres com todos os caracteres de <var>seq_caracte</var> em ordem reversa. 
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ssearch</b><i> (<var>seq</var>, <var>seq_caracte</var>)  </i>
<a name="IDX1995"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ssearch</b><i> (<var>seq</var>, <var>seq_caracte</var>, <var>test</var>)  </i>
<a name="IDX1996"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ssearch</b><i> (<var>seq</var>, <var>seq_caracte</var>, <var>test</var>, <var>in&iacute;cio</var>)  </i>
<a name="IDX1997"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ssearch</b><i> (<var>seq</var>, <var>seq_caracte</var>, <var>test</var>, <var>in&iacute;cio</var>, <var>fim</var>)</i>
<a name="IDX1998"></a>
</dt>
<dd><p>Retorna a posi&ccedil;&atilde;o da primeira subsequ&ecirc;ncia de caracteres de <var>seq_caracte</var> que coincide com a sequ&ecirc;ncia de caracteres <var>seq</var>.
A fun&ccedil;&atilde;o padr&atilde;o de teste de coincid&ecirc;ncia &eacute; <code>sequal</code>.
Se <code>ssearch</code> puder igonorar a caixa alta/baixa, use <code>sequalignore</code> como fun&ccedil;&atilde;o de teste.
Use <var>in&iacute;cio</var> e <var>fim</var> para limitar a busca.
Note que o primeiro caracter em <var>seq_caracte</var> est&aacute; na posi&ccedil;&atilde;o 1.
</p>
<pre class="example">(%i1) ssearch(&quot;~s&quot;,&quot;~{~S ~}~%&quot;,'sequalignore);
(%o1)                                  4
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ssort</b><i> (<var>seq_caracte</var>) </i>
<a name="IDX1999"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ssort</b><i> (<var>seq_caracte</var>, <var>test</var>) </i>
<a name="IDX2000"></a>
</dt>
<dd><p>Retorna uma sequ&ecirc;ncia de caracteres que cont&eacute;m todos os caracteres de <var>seq_caracte</var> em uma ordem tal que n&atilde;o existam dois caracteres <var>c</var> sucessivos e <var>d</var> seja tal que <code>test (<var>c</var>, <var>d</var>)</code> seja <code>false</code> e <code>test (<var>d</var>, <var>c</var>)</code> seja <code>true</code>.
A fun&ccedil;&atilde;o padr&atilde;o de teste para ordena&ccedil;&atilde;o &eacute; <var>clessp</var>.
O conjunto de fun&ccedil;&otilde;es de teste &eacute; <code>{clessp, clesspignore, cgreaterp, cgreaterpignore, cequal, cequalignore}</code>.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) ssort(&quot;I don't like Mondays.&quot;);
(%o2)                    '.IMaddeiklnnoosty
(%i3) ssort(&quot;I don't like Mondays.&quot;,'cgreaterpignore);
(%o3)                 ytsoonnMlkIiedda.'   
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ssubst</b><i> (<var>nova</var>, <var>antiga</var>, <var>seq_caracte</var>) </i>
<a name="IDX2001"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ssubst</b><i> (<var>nova</var>, <var>antiga</var>, <var>seq_caracte</var>, <var>test</var>) </i>
<a name="IDX2002"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ssubst</b><i> (<var>nova</var>, <var>antiga</var>, <var>seq_caracte</var>, <var>test</var>, <var>in&iacute;cio</var>) </i>
<a name="IDX2003"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ssubst</b><i> (<var>nova</var>, <var>antiga</var>, <var>seq_caracte</var>, <var>test</var>, <var>in&iacute;cio</var>, <var>fim</var>) </i>
<a name="IDX2004"></a>
</dt>
<dd><p>Retorna uma sequ&ecirc;ncia de caracteres como <var>seq_caracte</var> excepto que todas as subsequ&ecirc;ncias de caracteres que coincidirem com <var>antiga</var> s&atilde;o substitu&iacute;das por <var>nova</var>.
<var>antiga</var> e <var>nova</var> n&atilde;o precisam ser de mesmo comprimento.
A fun&ccedil;&atilde;o padr&atilde;o de teste para coincid&ecirc;ncia &eacute; para coincid&ecirc;ncias &eacute; <code>sequal</code>.
Se <code>ssubst</code> puder ignorar a cixa alta/baixa enquanto procurando por <var>antiga</var>, use <code>sequalignore</code> como fun&ccedil;&atilde;o de teste.
Use <var>in&iacute;cio</var> e <var>fim</var> para limitar a busca.
Note que o primeiro caractere em <var>seq_caracte</var> est&aacute; na posi&ccedil;&atilde;o 1.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) ssubst(&quot;like&quot;,&quot;hate&quot;,&quot;I hate Thai food. I hate green tea.&quot;);
(%o2)          I like Thai food. I like green tea.
(%i3) ssubst(&quot;Indian&quot;,&quot;thai&quot;,%,'sequalignore,8,12);
(%o3)         I like Indian food. I like green tea.
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ssubstfirst</b><i> (<var>nova</var>, <var>antiga</var>, <var>seq_caracte</var>) </i>
<a name="IDX2005"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ssubstfirst</b><i> (<var>nova</var>, <var>antiga</var>, <var>seq_caracte</var>, <var>test</var>) </i>
<a name="IDX2006"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ssubstfirst</b><i> (<var>nova</var>, <var>antiga</var>, <var>seq_caracte</var>, <var>test</var>, <var>in&iacute;cio</var>) </i>
<a name="IDX2007"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>ssubstfirst</b><i> (<var>nova</var>, <var>antiga</var>, <var>seq_caracte</var>, <var>test</var>, <var>in&iacute;cio</var>, <var>fim</var>) </i>
<a name="IDX2008"></a>
</dt>
<dd><p>Como em <code>subst</code> excepto que somente a primeira subsequ&ecirc;ncia de caracteres que coincidir com <var>antiga</var> &eacute; substitu&iacute;da. 
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>strim</b><i> (<var>seq</var>,<var>seq_caracte</var>) </i>
<a name="IDX2009"></a>
</dt>
<dd><p>Retorna uma sequ&ecirc;ncia de caracteres como <var>seq_caracte</var>,
mas com todos os caracteres que aparecerem em <var>seq</var> removidos de ambas as extremidades. 
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) &quot;/* comment */&quot;$
(%i3) strim(&quot; /*&quot;,%);
(%o3)                        comment
(%i4) slength(%);
(%o4)                           7
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>striml</b><i> (<var>seq</var>, <var>seq_caracte</var>) </i>
<a name="IDX2010"></a>
</dt>
<dd><p>Como em <code>strim</code> excepto que somente a extremidade esquerda de <var>seq_caracte</var> &eacute; recordada. 
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>strimr</b><i> (<var>seq</var>, <var>seq_caracte</var>) </i>
<a name="IDX2011"></a>
</dt>
<dd><p>Como em <code>strim</code> excepto que somente a extremidade direita de sequ&ecirc;ncia de caracteres &eacute; recortada. 
</p>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>substring</b><i> (<var>seq_caracte</var>, <var>in&iacute;cio</var>)</i>
<a name="IDX2012"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>substring</b><i> (<var>seq_caracte</var>, <var>in&iacute;cio</var>, <var>fim</var>) </i>
<a name="IDX2013"></a>
</dt>
<dd><p>Retorna a subsequ&ecirc;ncia de caracteres de <var>seq_caracte</var> come&ccedil;ando na posi&ccedil;&atilde;o <var>in&iacute;cio</var> e terminando na posi&ccedil;&atilde;o <var>fim</var>.
O caractere na posi&ccedil;&atilde;o <var>fim</var> n&atilde;o &eacute; inclu&iacute;do.
Se <var>fim</var> n&atilde;o for fornecido, a subsequ&ecirc;ncia de caracteres cont&eacute;m o restante da sequ&ecirc;ncia de caracteres.
Note que o primeiro caractere em <var>seq_caracte</var> est&aacute; na posi&ccedil;&atilde;o 1.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) substring(&quot;substring&quot;,4);
(%o2)                        string
(%i3) substring(%,4,6);
(%o3)                          in
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>supcase</b><i> (<var>seq_caracte</var>) </i>
<a name="IDX2014"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>supcase</b><i> (<var>seq_caracte</var>, <var>in&iacute;cio</var>) </i>
<a name="IDX2015"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>supcase</b><i> (<var>seq_caracte</var>, <var>in&iacute;cio</var>, <var>fim</var>) </i>
<a name="IDX2016"></a>
</dt>
<dd><p>Retorna <var>seq_caracte</var> excepto que caracteres em caixa baixa a partir da posi&ccedil;&atilde;o <var>in&iacute;cio</var> at&eacute; a posi&ccedil;&atilde;o <var>fim</var> s&atilde;o substitu&iacute;dos pelo correspondente caracteres em cixa alta.
Se <var>fim</var> n&atilde;o for fornecido,
todos os caracteres em caixa baixa de <var>in&iacute;cio</var> at&eacute; o fim de <var>seq_caracte</var> s&atilde;o substitu&iacute;dos.
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) supcase(&quot;english&quot;,1,2);
(%o2)                        English
</pre>
</dd></dl>

<dl>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>tokens</b><i> (<var>seq_caracte</var>) </i>
<a name="IDX2017"></a>
</dt>
<dt><u>Fun&ccedil;&atilde;o:</u> <b>tokens</b><i> (<var>seq_caracte</var>, <var>test</var>) </i>
<a name="IDX2018"></a>
</dt>
<dd><p>Retorna uma lista de fichas, que tiverem sido extr&iacute;dos de <var>seq_caracte</var>.
As fichas s&atilde;o subsequ&ecirc;ncias de caracteres cujos caracteres satisfazem a uma determinada fun&ccedil;&atilde;o de teste.
Se o teste n&atilde;o for fornecido, <var>constituent</var> &eacute; usada como teste padr&atilde;o.
<code>{constituent, alphacharp, digitcharp, lowercasep, uppercasep, charp, characterp, alphanumericp}</code> &eacute; o conjunto de fn&ccedil;~oes de teste. 
(A vers&atilde;o Lisp de <code>tokens</code> &eacute; escrita por Paul Graham. ANSI Common Lisp, 1996, page 67.)
</p>
<pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) tokens(&quot;24 October 2005&quot;);
(%o2)                  [24, October, 2005]
(%i3) tokens(&quot;05-10-24&quot;,'digitcharp);
(%o3)                     [05, 10, 24]
(%i4) map(parsetoken,%);
(%o4)                      [5, 10, 24]
</pre>
</dd></dl>

<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC257" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_71.html#SEC262" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC274" title="Index">&Iacute;ndice</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Jaime Villate</em> on <em>Outubro, 19 2014</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
