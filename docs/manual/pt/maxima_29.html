<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Manual do Maxima 5.46.0: Definições para Simplificação</title>

<meta name="description" content="Manual do Maxima 5.46.0: Definições para Simplificação">
<meta name="keywords" content="Manual do Maxima 5.46.0: Definições para Simplificação">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="maxima_toc.html#Top" rel="start" title="Top">
<link href="maxima_218.html#g_t_00cdndice-de-Fun_00e7_00f5es-e-Vari_00e1veis" rel="index" title="Índice de Funções e Variáveis">
<link href="maxima_toc.html#SEC_Contents" rel="contents" title="Sum&aacute;rio">
<link href="maxima_28.html#Simplifica_00e7_00e3o" rel="up" title="Simplificação">
<link href="maxima_30.html#Cria_00e7_00e3o-de-Gr_00e1ficos" rel="next" title="Criação de Gráficos">
<link href="maxima_28.html#Simplifica_00e7_00e3o" rel="previous" title="Simplificação">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 1em; padding-bottom: 1em;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%; display: block; margin-left: auto; margin-right: auto}

-->
</style>

<link rel="icon" href="figures/favicon.ico">

</head>

<body lang="pt" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="Defini_00e7_00f5es-para-Simplifica_00e7_00e3o"></a>
<div class="header">
<p>
Previous: <a href="maxima_28.html#Simplifica_00e7_00e3o" accesskey="p" rel="previous">Simplificação</a>, Acima: <a href="maxima_28.html#Simplifica_00e7_00e3o" accesskey="u" rel="up">Simplificação</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Sum&aacute;rio" rel="contents">Conte&uacute;do</a>][<a href="maxima_218.html#g_t_00cdndice-de-Fun_00e7_00f5es-e-Vari_00e1veis" title="&Iacute;ndice" rel="index">&Iacute;ndice</a>]</p>
</div>
<a name="Definicoes-para-Simplificacao"></a>
<h3 class="section">7.1 Definições para Simplificação</h3>

<a name="Item_003a-Simplification_002fdefvr_002faskexp"></a><dl>
<dt><a name="index-askexp"></a>Variável de sistema: <strong>askexp</strong></dt>
<dd><p>Quando <code>asksign</code> é chamada, <code>askexp</code> é a expressão que
<code>asksign</code> está a testar.
</p>
<p>Antigamente, era possível para um utilizador inspecionar
<code>askexp</code> parando o Maxima com control-A.
</p></dd></dl>

<a name="Item_003a-Simplification_002fdeffn_002faskinteger"></a><dl>
<dt><a name="index-askinteger"></a>Função: <strong>askinteger</strong> <em>(<var>expr</var>, integer)</em></dt>
<dt><a name="index-askinteger-1"></a>Função: <strong>askinteger</strong> <em>(<var>expr</var>)</em></dt>
<dt><a name="index-askinteger-2"></a>Função: <strong>askinteger</strong> <em>(<var>expr</var>, even)</em></dt>
<dt><a name="index-askinteger-3"></a>Função: <strong>askinteger</strong> <em>(<var>expr</var>, odd)</em></dt>
<dd>
<p><code>askinteger (<var>expr</var>, integer)</code> tenta determinar a partir da
base de dados do <code>assume</code> se <var>expr</var> é um inteiro. Se não conseguir,
<code>askinteger</code> perguntará ao utilizador, na linha de comandos,
e inserirá essa informação na base de dados do
<code>assume</code>, se for possível.  <code>askinteger
(<var>expr</var>)</code> é equivalente a <code>askinteger (<var>expr</var>, integer)</code>.
</p>
<p>Da mesma forma, <code>askinteger (<var>expr</var>, even)</code> e <code>askinteger
(<var>expr</var>, odd)</code> tentam determinar se <var>expr</var> é um inteiro par ou
inteiro ímpar, respectivamente.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdeffn_002fasksign"></a><dl>
<dt><a name="index-asksign"></a>Função: <strong>asksign</strong> <em>(<var>expr</var>)</em></dt>
<dd><p>Primeiro tenta determinar se a expressão especificada é positiva,
negativa, ou zero. Se isso não for possível,
<code>asksign</code> perguntará ao utilizador as questões necessárias
para completar a sua dedução. As respostas do utilizador
serão guardadas na base de dados pelo tempo que durar a cálculo
actual. O valor de retorno de <code>asksign</code> será <code>pos</code>,
<code>neg</code>, ou <code>zero</code>.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdeffn_002fdemoivre"></a><dl>
<dt><a name="index-demoivre"></a>Função: <strong>demoivre</strong> <em>(<var>expr</var>)</em></dt>
<dt><a name="index-demoivre-1"></a>Variável de opção: <strong>demoivre</strong></dt>
<dd>
<p>A função <code>demoivre (expr)</code> transforma uma
expressão sem modificar a variável global <code>demoivre</code>.
</p>
<p>Quando a variável <code>demoivre</code> for <code>true</code>, as exponenciais
complexas serão convertidas em expressões equivalentes em termos das
funções circulares: <code>exp (a + b*%i)</code> simplifica
para <code>%e^a * (cos(b) + %i*sin(b))</code> se <code>b</code> não incluir
<code>%i</code>.  <code>a</code> e <code>b</code> não serão expandidos.
</p>
<p>O valor padrão de <code>demoivre</code> é <code>false</code>.
</p>
<p><code>exponentialize</code> converte funções circulares e
hiperbólicas para a forma exponencial.  <code>demoivre</code> e
<code>exponentialize</code> não podem ambas serem <code>true</code> ao mesmo
tempo.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002fdomain"></a><dl>
<dt><a name="index-domain"></a>Variável de opção: <strong>domain</strong></dt>
<dd><p>Valor por omissão: <code>real</code>
</p>
<p>Quando a <code>domain</code> for dado o valor <code>complex</code>, <code>sqrt(x^2)</code>
permanecerá <code>sqrt (x^2)</code> em lugar de retornar <code>abs(x)</code>.
</p>

</dd></dl>

<a name="Item_003a-Simplification_002fdeffn_002fexpand"></a><dl>
<dt><a name="index-expand"></a>Função: <strong>expand</strong> <em>(<var>expr</var>)</em></dt>
<dt><a name="index-expand-1"></a>Função: <strong>expand</strong> <em>(<var>expr</var>, <var>p</var>, <var>n</var>)</em></dt>
<dd><p>Expande a expressão <var>expr</var>.  Nos rodutos de somas e exponenciais
de somas são expandidos os produtos, os numeradores de expressões
racionais que incluirem somas serão quebrados nas suas respectivas
parcelas, e os produtos (comutativos e não comutativos) são
distribuídos sobre as somas em todos os
níveis de <var>expr</var>.
</p>
<p>Para polinómios se pode usar frequêntemente <code>ratexpand</code> que
possui um algoritmo mais eficiente.
</p>
<p><code>maxnegex</code> e <code>maxposex</code> controlam o máximo expoente negativo
e o máximo expoente positivo, respectivamente, que irão expandir.
</p>
<p><code>expand (<var>expr</var>, <var>p</var>, <var>n</var>)</code> expande <var>expr</var>, usando
<var>p</var> para <code>maxposex</code> e <var>n</var> para <code>maxnegex</code>.  Isso é
útil para expandir partes numa expressão mas não toda.
</p>
<p><code>expon</code> - o expoente da maior potência negativa que é
automaticamente expandida (independente de chamadas a <code>expand</code>).
Por Exemplo se <code>expon</code> for 4 então <code>(x+1)^(-5)</code> não será
automaticamente expandido.
</p>
<p><code>expop</code> - o maior expoente positivo que é automaticamente
expandido.  Dessa forma <code>(x+1)^3</code>, quando digitado, será
automaticamente expandido somente se <code>expop</code> for maior que ou igual
a 3.  Se quiser que <code>(x+1)^n</code> seja expandido onde <code>n</code> for
maior que <code>expop</code>, então <code>expand ((x+1)^n)</code> funcionará
unicamente se <code>maxposex</code> não for menor que <code>n</code>.
</p>
<p>O sinalizador <code>expand</code> usado com <code>ev</code> causa expansão.
</p>
<p>O ficheiro <samp>simplification/facexp.mac</samp>
contém muitas funções relacionadas (em particular
<code>facsum</code>, <code>factorfacsum</code> e <code>collectterms</code>, que são
carregadas automaticamente) e as variáveis (<code>nextlayerfactor</code> e
<code>facsum_combine</code>) que fornecem ao utilizador a possibilidade de
estruturar expressões por expansão controlada.
Uma descrição breve das função
encontra-se no ficheiro <samp>simplification/facexp.usg</samp>.  Há também
uma demonstração disponível com o comando
<code>demo(&quot;facexp&quot;)</code>.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdeffn_002fexpandwrt"></a><dl>
<dt><a name="index-expandwrt"></a>Função: <strong>expandwrt</strong> <em>(<var>expr</var>, <var>x_1</var>, ..., <var>x_n</var>)</em></dt>
<dd><p>Expande a expressão <code>expr</code> com relação às
variáveis <var>x_1</var>, ..., <var>x_n</var>.  Todos os produtos que encvolvam
as variáveis aparecerão explicitamente. O resultado estará livre
de produtos de somas de expressões que não estejam livres das
variáveis.  <var>x_1</var>, ..., <var>x_n</var> podem ser variáveis,
operadores, ou expressões.
</p>
<p>Por omissão, os denominadores não são expandidos, mas isso pode ser
controlado através da variável <code>expandwrt_denom</code>.
</p>
<p>Esta função é carregada automaticamente a partir de
<samp>simplification/stopex.mac</samp>.
</p>
</dd></dl>


<a name="Item_003a-Simplification_002fdefvr_002fexpandwrt_005fdenom"></a><dl>
<dt><a name="index-expandwrt_005fdenom"></a>Variável de opção: <strong>expandwrt_denom</strong></dt>
<dd><p>Valor por omissão: <code>false</code>
</p>
<p><code>expandwrt_denom</code> controla a simplificação de expressões
racionais feita por <code>expandwrt</code>. Se tiver valor <code>true</code>,
então tanto o numerador como o denominador da expressão serão
expandidos conforme os argumentos de <code>expandwrt</code>, mas se
<code>expandwrt_denom</code> for <code>false</code>, então somente o numerador
será expandido.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdeffn_002fexpandwrt_005ffactored"></a><dl>
<dt><a name="index-expandwrt_005ffactored"></a>Função: <strong>expandwrt_factored</strong> <em>(<var>expr</var>, <var>x_1</var>, ..., <var>x_n</var>)</em></dt>
<dd><p>é similar a <code>expandwrt</code>, mas trata os produtos numa forma
diferente.  <code>expandwrt_factored</code> expande somente sobre esses
factores de <code>expr</code> que contiverem as variáveis <var>x_1</var>, ...,
<var>x_n</var>.
</p>
<p>Esta função é carregada automaticamente a partir de
<samp>simplification/stopex.mac</samp>.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002fexpon"></a><dl>
<dt><a name="index-expon"></a>Variável de opção: <strong>expon</strong></dt>
<dd><p>Valor por omissão: 0
</p>
<p><code>expon</code> é o expoente da maior potência negativa que é
automaticamente expandido (independente de chamadas a <code>expand</code>).
Por exemplo, se <code>expon</code> for 4 então <code>(x+1)^(-5)</code> não
será automaticamente expandido.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdeffn_002fexponentialize"></a><dl>
<dt><a name="index-exponentialize"></a>Função: <strong>exponentialize</strong> <em>(<var>expr</var>)</em></dt>
<dt><a name="index-exponentialize-1"></a>Variável de opção: <strong>exponentialize</strong></dt>
<dd>
<p>A função <code>exponentialize (expr)</code> converte as
funções circulares e hiperbólicas em <var>expr</var> para
exponenciais, sem modificar a variável global <code>exponentialize</code>.
</p>
<p>Quando a variável <code>exponentialize</code> for <code>true</code>, todas as
funções circulares e hiperbólicas são convertidas
para a forma exponencial. O valor por omissão é <code>false</code>.
</p>
<p><code>demoivre</code> converte exponenciais complexas em
funções circulares.  <code>exponentialize</code> e
<code>demoivre</code> não podem ambas serem <code>true</code> ao mesmo tempo.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002fexpop"></a><dl>
<dt><a name="index-expop"></a>Variável de opção: <strong>expop</strong></dt>
<dd><p>Valor por omissão: 0
</p>
<p><code>expop</code> - o maior expoente positivo que é automaticamente
expandido.  Dessa forma <code>(x+1)^3</code>, será automaticamente expandido
somente se <code>expop</code> for maior que ou igual a 3.  Se quiser que
<code>(x+1)^n</code> seja expandido onde <code>n</code> for maior que <code>expop</code>,
então <code>expand ((x+1)^n)</code> funcionará somente se <code>maxposex</code>
não for menor que <code>n</code>.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002ffactlim"></a><dl>
<dt><a name="index-factlim"></a>Variável de opção: <strong>factlim</strong></dt>
<dd><p>Valor por omissão: -1
</p>
<p><code>factlim</code> especifica o maior factorial que é automaticamente
expandido. Se for -1 então todos os inteiros são expandidos.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdeffn_002fintosum"></a><dl>
<dt><a name="index-intosum"></a>Função: <strong>intosum</strong> <em>(<var>expr</var>)</em></dt>
<dd><p>Move factores multiplicativos fora de um somatório para dentro.  Se um
índice for usado na expressão de fora, então a
função tentará achar um índice
razoável, o mesmo que é feito para <code>sumcontract</code>.  Isto é
essencialmente a ideia inversa da propriedade <code>outative</code> de
somatórios, mas repare que não elimina essa propriedade, apenas faz
com que seja ignorada.
</p>
<p>Em alguns casos, poderá ser necessário um
<code>scanmap(multthru,<var>expr</var>)</code> antes de <code>intosum</code>.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002flassociative"></a><dl>
<dt><a name="index-lassociative"></a>Declaração: <strong>lassociative</strong></dt>
<dd><p><code>declare (g, lassociative)</code> diz ao simplificador do Maxima que
<code>g</code> é associativa à esquerda.  E.g., <code>g (g (a, b), g (c,
d))</code> irá simplificar para <code>g (g (g (a, b), c), d)</code>.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002flinear"></a><dl>
<dt><a name="index-linear-1"></a>Declaração: <strong>linear</strong></dt>
<dd><p>Uma das propriedades operativas do Maxima. As funções de
uma única variável <code>f</code> assim declaradas fazem com que a
expressão <code>f(x + y)</code> seja expandida em <code>f(x) + f(y)</code>, a
expressão <code>f(a*x)</code> transforma-se em <code>a*f(x)</code> se <code>a</code> for
uma constante. Para funções de dois ou mais argumentos,
a linearidade define-se igual que no caso de <code>sum</code> ou
<code>integrate</code>, isto é, <code>f (a*x + b, x)</code> retorna <code>a*f(x,x)
+ b*f(1,x)</code>, se <code>a</code> e <code>b</code> forem independentesx de <code>x</code>.
</p>
<p><code>linear</code> é equivalente a <code>additive</code> e <code>outative</code>.
Veja também <code>opproperties</code>.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002fmainvar"></a><dl>
<dt><a name="index-mainvar"></a>Declaração: <strong>mainvar</strong></dt>
<dd><p>Permite declarar variáveis do tipo <code>mainvar</code> (variável
principal).  A escala de ordenação para átomos é
essencialmente: números &lt; constantes (e.g., <code>%e</code>, <code>%pi</code>) &lt;
escalares &lt; outras variáveis &lt; mainvars.  Por exemplo, compare
<code>expand ((X+Y)^4)</code> com <code>(declare (x, mainvar), expand
((x+y)^4))</code>.  (Nota: este recurso deverá ser usado com cautela. Por
exemplo, se subtrair uma expressão, na qual <code>x</code> for uma
<code>mainvar</code>, da mesma expressão, mas onde <code>x</code> não for
<code>mainvar</code>, poderá precisar de resimplificação,
por exemplo, com <code>ev (expr, simp)</code>, para que sejam canceladas.
Também, se grava uma expressão na qual <code>x</code> for uma
<code>mainvar</code>, provavelmente deverá também gravar <code>x</code>.)
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002fmaxapplydepth"></a><dl>
<dt><a name="index-maxapplydepth"></a>Variável de opção: <strong>maxapplydepth</strong></dt>
<dd><p>Valor por omissão: 10000
</p>
<p><code>maxapplydepth</code> é a profundidade máxima ate a qual <code>apply1</code>
e <code>apply2</code> deverão descer.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002fmaxapplyheight"></a><dl>
<dt><a name="index-maxapplyheight"></a>Variável de opção: <strong>maxapplyheight</strong></dt>
<dd><p>Valor por omissão: 10000
</p>
<p><code>maxapplyheight</code> é nível máximo a ser atingido
por <code>applyb1</code> antes de abandonar.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002fmaxnegex"></a><dl>
<dt><a name="index-maxnegex"></a>Variável de opção: <strong>maxnegex</strong></dt>
<dd><p>Valor por omissão: 1000
</p>
<p><code>maxnegex</code> é o maior expoente negativo que será expandido pelo
comando <code>expand</code> (veja também <code>maxposex</code>).
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002fmaxposex"></a><dl>
<dt><a name="index-maxposex"></a>Variável de opção: <strong>maxposex</strong></dt>
<dd><p>Valor por omissão: 1000
</p>
<p><code>maxposex</code> é o maior expoente que será expandido com o comando
<code>expand</code> (veja também <code>maxnegex</code>).
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002fmultiplicative"></a><dl>
<dt><a name="index-multiplicative"></a>Declaração: <strong>multiplicative</strong></dt>
<dd><p><code>declare (f, multiplicative)</code> diz ao simplificador do Maxima que
<code>f</code> é multiplicativa.
</p>
<ol>
<li> Se <code>f</code> for uma função de uma única variável,
sempre que o simplificador encontrar <code>f</code> aplicada a um produto,
<code>f</code> será distribuida nesse produto.  Por exemplo, <code>f(x*y)</code>
simplifica para <code>f(x)*f(y)</code>.
</li><li> Se <code>f</code> for uma função de 2 ou mais argumentos, a
multiplicatividade entende-se como multiplicatividade no primeiro
argumento de <code>f</code>. Por exemplo, <code>f (g(x) * h(x), x)</code> simplifica
para <code>f (g(x) ,x) * f (h(x), x)</code>.
</li></ol>

<p>Esta simplificação não é feita quando <code>f</code> for
aplicada a expressões da forma <code>product (x[i], i, m, n)</code>.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002fnegdistrib"></a><dl>
<dt><a name="index-negdistrib"></a>Variável de opção: <strong>negdistrib</strong></dt>
<dd><p>Valor por omissão: <code>true</code>
</p>
<p>Quando <code>negdistrib</code> for <code>true</code>, -1 distribue sobre uma
expressão. Por exemplo, <code>-(x + y)</code> transforma-se em <code>- y -
x</code>.  Mudando o valor de <code>negdistrib</code> para <code>false</code> permitirá
que <code>- (x + y)</code> seja mostrado como foi escrito. Embora isso possa
ser útil, tenha muito cuidado: esta variável e a variável
<code>simp</code> não deveriam ser escolhidas sempre como <code>false</code>,
excepto em forma local no seu Maxima.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002fnegsumdispflag"></a><dl>
<dt><a name="index-negsumdispflag"></a>Variável de opção: <strong>negsumdispflag</strong></dt>
<dd><p>Valor por omissão: <code>true</code>
</p>
<p>Quando <code>negsumdispflag</code> for <code>true</code>, <code>x - y</code> é mostrado
como <code>x - y</code> em lugar de como <code>- y + x</code>. Mudando para
<code>false</code> faz com que não seja feita a verificação
especial para a apresentação da diferença entre duas
expressões.  Uma aplicação é para que <code>a +
%i*b</code> e <code>a - %i*b</code> sejam mostrados na mesma forma.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002fnoeval"></a><dl>
<dt><a name="index-noeval"></a>Símbolo especial: <strong>noeval</strong></dt>
<dd><p><code>noeval</code> suprime a fase de avaliação de <code>ev</code>.
Isso é útil conjuntamente com outras condições e para fazer com
que expressões sejam simplificadas sem serem reavaliadas.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002fnoun"></a><dl>
<dt><a name="index-noun"></a>Declaração: <strong>noun</strong></dt>
<dd><p><code>noun</code> é uma das opções do comando
<code>declare</code>.  Faz com que as funções assim declaradas sejam
substantivos (noun), implicando que não sejam avaliadas
automaticamente.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002fnoundisp"></a><dl>
<dt><a name="index-noundisp"></a>Variável de opção: <strong>noundisp</strong></dt>
<dd><p>Valor por omissão: <code>false</code>
</p>
<p>Quando <code>noundisp</code> for <code>true</code>, os substantivos (nouns) são
mostrados com um apóstrofo. Sempre que se mostra a
definição de uma função, essa variável
é igual a <code>true</code>.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002fnouns"></a><dl>
<dt><a name="index-nouns"></a>Símbolo especial: <strong>nouns</strong></dt>
<dd><p><code>nouns</code> é um <code>evflag</code> (sinalizador de
avaliação). Quando usado como uma opção
para o comando <code>ev</code>, <code>nouns</code> converte todas as formas
substantivas (noun), na expressão a ser avaliada, para verbos
(&quot;verbs&quot;), isto é, avalia essas expressões. Veja também
<code>noun</code>, <code>nounify</code>, <code>verb</code>, e <code>verbify</code>.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002fnumer"></a><dl>
<dt><a name="index-numer"></a>Símbolo especial: <strong>numer</strong></dt>
<dd><p><code>numer</code> faz com que algumas funções matemáticas
(incluindo exponenciação) com argumentos numéricos
sejam avaliadas em ponto flutuante. Isto faz com que variáveis em
<code>expr</code> que tiverem valores numéricos sejam
substituídas pelos seus valores correspondentes.
<code>numer</code> também activa a opção <code>float</code>.
</p>
</dd></dl>


<a name="Item_003a-Simplification_002fdeffn_002fnumerval"></a><dl>
<dt><a name="index-numerval"></a>Função: <strong>numerval</strong> <em>(<var>x_1</var>, <var>expr_1</var>, ..., <var>var_n</var>, <var>expr_n</var>)</em></dt>
<dd><p>Declara as variáveis <code>x_1</code>, ..., <var>x_n</var> com valores
numéricos iguais a <code>expr_1</code>, ..., <code>expr_n</code>.  O valor
numérico é avaliado e substituido para a variável em quaisquer
expressões em que a variável aparecer, se o sinalizador <code>numer</code>
for igual a <code>true</code>. Veja também <code>ev</code>.
</p>
<p>As expressões <code>expr_1</code>, ..., <code>expr_n</code> podem ser quaisquer,
não necessariamente numéricas.
</p></dd></dl>


<a name="Item_003a-Simplification_002fdefvr_002fopproperties"></a><dl>
<dt><a name="index-opproperties"></a>Variável de sistema: <strong>opproperties</strong></dt>
<dd>
<p><code>opproperties</code> é a lista de propriedades de operadores especiais
reconhecidas pelo simplificador do Maxima: <code>linear</code>,
<code>additive</code>, <code>multiplicative</code>, <code>outative</code>, <code>evenfun</code>,
<code>oddfun</code>, <code>commutative</code>, <code>symmetric</code>,
<code>antisymmetric</code>, <code>nary</code>, <code>lassociative</code>,
<code>rassociative</code>.
</p>
</dd></dl>


<a name="Item_003a-Simplification_002fdefvr_002fopsubst"></a><dl>
<dt><a name="index-opsubst-3"></a>Variável de opção: <strong>opsubst</strong></dt>
<dd><p>Valor por omissão: <code>true</code>
</p>
<p>Quando <code>opsubst</code> for <code>false</code>, <code>subst</code> não tenta
substituir dentro de um operador de uma expressão.  Por exemplo, 
<code>(opsubst: false, subst (x^2, r, r+r[0]))</code>.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002foutative"></a><dl>
<dt><a name="index-outative"></a>Declaração: <strong>outative</strong></dt>
<dd><p><code>declare (f, outative)</code> diz ao simplificador do Maxima que factores
constantes no argumento de <code>f</code> podem ser puxados para fora.
</p>
<ol>
<li> Se <code>f</code> for uma função de uma única variável,
sempre que o simplificador encontrar <code>f</code> aplicada a um produto, os
factores que forem constantes nesse produto serão puxados para
fora. Por exemplo, <code>f(a*x)</code> simplificará para <code>a*f(x)</code> se
<code>a</code> for uma constante.  Factores de constantes não at&ocirc;micas
não serão puxados para fora.
</li><li> Se <code>f</code> for uma função de 2 ou mais argumentos, a
colocação para fora é definida como no caso de
<code>sum</code> ou <code>integrate</code>, isto é, <code>f (a*g(x), x)</code> irá
simplificar para <code>a * f(g(x), x)</code> se <code>a</code> não depender de
<code>x</code>.
</li></ol>

<p><code>sum</code>, <code>integrate</code>, e <code>limit</code> são todas do tipo
<code>outative</code>.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002fposfun"></a><dl>
<dt><a name="index-posfun"></a>Declaração: <strong>posfun</strong></dt>
<dd><p><code>declare (f, posfun)</code> declara <code>f</code> como função
positiva.  <code>is (f(x) &gt; 0)</code> retorna <code>true</code>.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdeffn_002fradcan"></a><dl>
<dt><a name="index-radcan"></a>Função: <strong>radcan</strong> <em>(<var>expr</var>)</em></dt>
<dd><p>Simplifica <var>expr</var>, que pode conter logaritmos,
exponenciais, e radicais, convertendo essa expressão numa forma
canónica sobre uma ampla classe de expressões e com uma dada
ordenação de variáveis; isto é, todas as formas
funcionalmente equivalentes são mapeadas numa única forma.  Para uma
classe ampla de expressões, <code>radcan</code> produz uma forma regular.
Duas expressões equivalentes nessa classe não possuem
necessáriamente a mesma aparência, mas as suas diferenças podem
ser simplificadas por <code>radcan</code> para zero.
</p>
<p>Para algumas expressões <code>radcan</code> demora muito tempo. Esse é o
custo de explorar as realções entre as componentes da expressão
para simplificar expoentes usando factorização e expansão em
frações parciais.
</p>
<p>Quando <code>%e_to_numlog</code> for <code>true</code>, <code>%e^(r*log(expr))</code>
simplifica para <code>expr^r</code> se <code>r</code> for um número racional.
</p>
<p>Quando <code>radexpand</code> for <code>false</code>, certas
transformações são inibidas.  <code>radcan (sqrt
(1-x))</code> permanece <code>sqrt (1-x)</code> e não é simplificada para
<code>%i sqrt (x-1)</code>.  <code>radcan (sqrt (x^2 - 2*x + 11))</code> permanece
<code>sqrt (x^2 - 2*x + 1)</code> e não é simplificada para <code>x - 1</code>.
</p>
<p><code>example (radcan)</code> mostra alguns exemplos.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002fradexpand"></a><dl>
<dt><a name="index-radexpand"></a>Variável de opção: <strong>radexpand</strong></dt>
<dd><p>Valor por omissão: <code>true</code>
</p>
<p><code>radexpand</code> controla algumas simplificações de
radicais.
</p>
<p>Quando <code>radexpand</code> for <code>all</code>, todos os factores que forem
potências de ordem n, dentro de uma raiz de ordem n, serão puxados
para fora do radical. Por exemplo, se <code>radexpand</code> for <code>all</code>,
<code>sqrt (16*x^2)</code> simplifica para <code>4*x</code>.
</p>
<p>Mais particularmente, considere <code>sqrt (x^2)</code>.
</p><ul>
<li> Se <code>radexpand</code> for <code>all</code> ou <code>assume (x &gt; 0)</code> tiver sido
executado, <code>sqrt(x^2)</code> simplifica para <code>x</code>.
</li><li> Se <code>radexpand</code> for <code>true</code> e <code>domain</code> for <code>real</code>
(valores usados por omissão), <code>sqrt(x^2)</code> simplifica para
<code>abs(x)</code>.
</li><li> Se <code>radexpand</code> for <code>false</code>, ou <code>radexpand</code> for
<code>true</code> e <code>domain</code> for <code>complex</code>, <code>sqrt(x^2)</code> não
é simplificado.
</li></ul>

<p>Note que, neste exemplo, <code>domain</code> somente interessa quando
<code>radexpand</code> for <code>true</code>.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002fradsubstflag"></a><dl>
<dt><a name="index-radsubstflag"></a>Variável de opção: <strong>radsubstflag</strong></dt>
<dd><p>Valor por omissão: <code>false</code>
</p>
<p>Se <code>radsubstflag</code> for <code>true</code>, permite a <code>ratsubst</code> fazer
substituições tais como <code>u</code> por <code>sqrt (x)</code> em
<code>x</code>.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002frassociative"></a><dl>
<dt><a name="index-rassociative"></a>Declaração: <strong>rassociative</strong></dt>
<dd><p><code>declare (g, rassociative)</code> diz ao simplificador do Maxima que
<code>g</code> é associativa à direita, isto é, <code>g(g(a, b), g(c, d))</code>
simplifica para <code>g(a, g(b, g(c, d)))</code>.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdeffn_002fscsimp"></a><dl>
<dt><a name="index-scsimp"></a>Função: <strong>scsimp</strong> <em>(<var>expr</var>, <var>rule_1</var>, ..., <var>rule_n</var>)</em></dt>
<dd><p>Simplificação Sequêncial Comparativa (método devido
a Stoute).  <code>scsimp</code> tenta simplificar <var>expr</var> conforme as
regras <var>rule_1</var>, ..., <var>rule_n</var>.  Se uma expressão pequena for
obtida, o processo repete-se.  De outra forma após todas as
simplificações serem tentadas, <code>scsimp</code> retorna a
resposta original.
</p>
<p><code>example (scsimp)</code> mostra alguns exemplos.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002fsimpsum"></a><dl>
<dt><a name="index-simpsum"></a>Variável de opção: <strong>simpsum</strong></dt>
<dd><p>Valor por omissão: <code>false</code>
</p>
<p>Quando <code>simpsum</code> for <code>true</code>, o resultado de um comando
<code>sum</code> é simplificado.  Essa simplificação pode
algumas vezes produzir uma forma fechada.  Se <code>simpsum</code> for
<code>false</code>, ou se a forma com apóstrofo <code>'sum</code> for usada, o
valor é uma forma substantiva aditiva que é uma
representação da notação sigma usada em
matemática.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdeffn_002fsumcontract"></a><dl>
<dt><a name="index-sumcontract"></a>Função: <strong>sumcontract</strong> <em>(<var>expr</var>)</em></dt>
<dd><p>Combina vários somatórios que possuem limites superiores e inferiores
que diferem por constantes. O resultado é uma expressão que contém
apenas um somatório mais todos os termos adicionais que tiveram de ser
extraídos para obter essa forma.  <code>sumcontract</code>
combina todas as somas compatíveis e usa os indices de uma
das somas, se puder, ou tenta formar um índice razoável
se não poder usar nenhum dos que foram fornecidos.
</p>
<p>Poderá ser necessário usar <code>intosum (<var>expr</var>)</code> antes de
<code>sumcontract</code>.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002fsumexpand"></a><dl>
<dt><a name="index-sumexpand"></a>Variável de opção: <strong>sumexpand</strong></dt>
<dd><p>Valor por omissão: <code>false</code>
</p>
<p>Quando <code>sumexpand</code> for <code>true</code>, produtos de somas e somas
exponeciadas simplificam para somas aninhadas.
</p>
<p>Veja também <code>cauchysum</code>.
</p>
<p>Exemplos:
</p>
<div class="example">
<pre class="example">(%i1) sumexpand: true$
(%i2) sum (f (i), i, 0, m) * sum (g (j), j, 0, n);
                     m      n
                    ====   ====
                    \      \
(%o2)                &gt;      &gt;     f(i1) g(i2)
                    /      /
                    ====   ====
                    i1 = 0 i2 = 0
(%i3) sum (f (i), i, 0, m)^2;
                     m      m
                    ====   ====
                    \      \
(%o3)                &gt;      &gt;     f(i3) f(i4)
                    /      /
                    ====   ====
                    i3 = 0 i4 = 0
</pre></div>

</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002fsumsplitfact"></a><dl>
<dt><a name="index-sumsplitfact"></a>Variável de opção: <strong>sumsplitfact</strong></dt>
<dd><p>Valor por omissão: <code>true</code>
</p>
<p>Quando <code>sumsplitfact</code> for <code>false</code>,
<code>minfactorial</code> é aplicado após <code>factcomb</code>.
</p>
</dd></dl>

<a name="Item_003a-Simplification_002fdefvr_002fsymmetric"></a><dl>
<dt><a name="index-symmetric"></a>Declaração: <strong>symmetric</strong></dt>
<dd><p><code>declare (h, symmetric)</code> diz ao simplificador do Maxima que
<code>h</code> é uma função simétrica.  Nomeadamente,
<code>h (x, z, y)</code> simplifica para <code>h (x, y, z)</code>.
</p>
<p><code>commutative</code> é sin&ocirc;nimo de <code>symmetric</code>.
</p>
</dd></dl>


<a name="Item_003a-Simplification_002fdeffn_002funknown"></a><dl>
<dt><a name="index-unknown"></a>Função: <strong>unknown</strong> <em>(<var>expr</var>)</em></dt>
<dd><p>Retorna <code>true</code> se e somente se <var>expr</var> contém um operador ou
função não reconhecida pelo simplificador do Maxima.
</p>
</dd></dl>


<hr>
<div class="header">
<p>
Previous: <a href="maxima_28.html#Simplifica_00e7_00e3o" accesskey="p" rel="previous">Simplificação</a>, Acima: <a href="maxima_28.html#Simplifica_00e7_00e3o" accesskey="u" rel="up">Simplificação</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Sum&aacute;rio" rel="contents">Conte&uacute;do</a>][<a href="maxima_218.html#g_t_00cdndice-de-Fun_00e7_00f5es-e-Vari_00e1veis" title="&Iacute;ndice" rel="index">&Iacute;ndice</a>]</p>
</div>



</body>
</html>
